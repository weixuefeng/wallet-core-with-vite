import * as $protobuf from "protobufjs";
/** Namespace TW. */
export namespace TW {

    /** Namespace Aeternity. */
    namespace Aeternity {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput fromAddress */
                fromAddress?: (string|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput amount */
                amount?: (Uint8Array|null);

                /** SigningInput fee */
                fee?: (Uint8Array|null);

                /** SigningInput payload */
                payload?: (string|null);

                /** SigningInput ttl */
                ttl?: (Long|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aeternity.Proto.ISigningInput);

                /** SigningInput fromAddress. */
                public fromAddress: string;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput amount. */
                public amount: Uint8Array;

                /** SigningInput fee. */
                public fee: Uint8Array;

                /** SigningInput payload. */
                public payload: string;

                /** SigningInput ttl. */
                public ttl: Long;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Aeternity.Proto.ISigningInput): TW.Aeternity.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aeternity.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aeternity.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aeternity.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aeternity.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aeternity.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);

                /** SigningOutput signature */
                signature?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aeternity.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /** SigningOutput signature. */
                public signature: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Aeternity.Proto.ISigningOutput): TW.Aeternity.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aeternity.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aeternity.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aeternity.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aeternity.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aeternity.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Aion. */
    namespace Aion {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput nonce */
                nonce?: (Uint8Array|null);

                /** SigningInput gasPrice */
                gasPrice?: (Uint8Array|null);

                /** SigningInput gasLimit */
                gasLimit?: (Uint8Array|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput amount */
                amount?: (Uint8Array|null);

                /** SigningInput payload */
                payload?: (Uint8Array|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput timestamp */
                timestamp?: (Long|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aion.Proto.ISigningInput);

                /** SigningInput nonce. */
                public nonce: Uint8Array;

                /** SigningInput gasPrice. */
                public gasPrice: Uint8Array;

                /** SigningInput gasLimit. */
                public gasLimit: Uint8Array;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput amount. */
                public amount: Uint8Array;

                /** SigningInput payload. */
                public payload: Uint8Array;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput timestamp. */
                public timestamp: Long;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Aion.Proto.ISigningInput): TW.Aion.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aion.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aion.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aion.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aion.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aion.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aion.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Aion.Proto.ISigningOutput): TW.Aion.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aion.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aion.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aion.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aion.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aion.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Common. */
    namespace Common {

        /** Namespace Proto. */
        namespace Proto {

            /** SigningError enum. */
            enum SigningError {
                OK = 0,
                Error_general = 1,
                Error_internal = 2,
                Error_low_balance = 3,
                Error_zero_amount_requested = 4,
                Error_missing_private_key = 5,
                Error_invalid_private_key = 15,
                Error_invalid_address = 16,
                Error_invalid_utxo = 17,
                Error_invalid_utxo_amount = 18,
                Error_wrong_fee = 6,
                Error_signing = 7,
                Error_tx_too_big = 8,
                Error_missing_input_utxos = 9,
                Error_not_enough_utxos = 10,
                Error_script_redeem = 11,
                Error_script_output = 12,
                Error_script_witness_program = 13,
                Error_invalid_memo = 14,
                Error_input_parse = 19,
                Error_no_support_n2n = 20,
                Error_signatures_count = 21,
                Error_invalid_params = 22,
                Error_invalid_requested_token_amount = 23,
                Error_not_supported = 24
            }
        }
    }

    /** Namespace Algorand. */
    namespace Algorand {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer toAddress */
                toAddress?: (string|null);

                /** Transfer amount */
                amount?: (Long|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Algorand.Proto.ITransfer);

                /** Transfer toAddress. */
                public toAddress: string;

                /** Transfer amount. */
                public amount: Long;

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.Algorand.Proto.ITransfer): TW.Algorand.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.Algorand.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Algorand.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Algorand.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Algorand.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Algorand.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AssetTransfer. */
            interface IAssetTransfer {

                /** AssetTransfer toAddress */
                toAddress?: (string|null);

                /** AssetTransfer amount */
                amount?: (Long|null);

                /** AssetTransfer assetId */
                assetId?: (Long|null);
            }

            /** Represents an AssetTransfer. */
            class AssetTransfer implements IAssetTransfer {

                /**
                 * Constructs a new AssetTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Algorand.Proto.IAssetTransfer);

                /** AssetTransfer toAddress. */
                public toAddress: string;

                /** AssetTransfer amount. */
                public amount: Long;

                /** AssetTransfer assetId. */
                public assetId: Long;

                /**
                 * Creates a new AssetTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AssetTransfer instance
                 */
                public static create(properties?: TW.Algorand.Proto.IAssetTransfer): TW.Algorand.Proto.AssetTransfer;

                /**
                 * Encodes the specified AssetTransfer message. Does not implicitly {@link TW.Algorand.Proto.AssetTransfer.verify|verify} messages.
                 * @param message AssetTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Algorand.Proto.IAssetTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AssetTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AssetTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Algorand.Proto.AssetTransfer;

                /**
                 * Verifies an AssetTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AssetTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AssetTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Algorand.Proto.AssetTransfer;

                /**
                 * Creates a plain object from an AssetTransfer message. Also converts values to other types if specified.
                 * @param message AssetTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Algorand.Proto.AssetTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AssetTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AssetOptIn. */
            interface IAssetOptIn {

                /** AssetOptIn assetId */
                assetId?: (Long|null);
            }

            /** Represents an AssetOptIn. */
            class AssetOptIn implements IAssetOptIn {

                /**
                 * Constructs a new AssetOptIn.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Algorand.Proto.IAssetOptIn);

                /** AssetOptIn assetId. */
                public assetId: Long;

                /**
                 * Creates a new AssetOptIn instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AssetOptIn instance
                 */
                public static create(properties?: TW.Algorand.Proto.IAssetOptIn): TW.Algorand.Proto.AssetOptIn;

                /**
                 * Encodes the specified AssetOptIn message. Does not implicitly {@link TW.Algorand.Proto.AssetOptIn.verify|verify} messages.
                 * @param message AssetOptIn message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Algorand.Proto.IAssetOptIn, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AssetOptIn message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AssetOptIn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Algorand.Proto.AssetOptIn;

                /**
                 * Verifies an AssetOptIn message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AssetOptIn message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AssetOptIn
                 */
                public static fromObject(object: { [k: string]: any }): TW.Algorand.Proto.AssetOptIn;

                /**
                 * Creates a plain object from an AssetOptIn message. Also converts values to other types if specified.
                 * @param message AssetOptIn
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Algorand.Proto.AssetOptIn, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AssetOptIn to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput genesisId */
                genesisId?: (string|null);

                /** SigningInput genesisHash */
                genesisHash?: (Uint8Array|null);

                /** SigningInput note */
                note?: (Uint8Array|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput firstRound */
                firstRound?: (Long|null);

                /** SigningInput lastRound */
                lastRound?: (Long|null);

                /** SigningInput fee */
                fee?: (Long|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);

                /** SigningInput transfer */
                transfer?: (TW.Algorand.Proto.ITransfer|null);

                /** SigningInput assetTransfer */
                assetTransfer?: (TW.Algorand.Proto.IAssetTransfer|null);

                /** SigningInput assetOptIn */
                assetOptIn?: (TW.Algorand.Proto.IAssetOptIn|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Algorand.Proto.ISigningInput);

                /** SigningInput genesisId. */
                public genesisId: string;

                /** SigningInput genesisHash. */
                public genesisHash: Uint8Array;

                /** SigningInput note. */
                public note: Uint8Array;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput firstRound. */
                public firstRound: Long;

                /** SigningInput lastRound. */
                public lastRound: Long;

                /** SigningInput fee. */
                public fee: Long;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /** SigningInput transfer. */
                public transfer?: (TW.Algorand.Proto.ITransfer|null);

                /** SigningInput assetTransfer. */
                public assetTransfer?: (TW.Algorand.Proto.IAssetTransfer|null);

                /** SigningInput assetOptIn. */
                public assetOptIn?: (TW.Algorand.Proto.IAssetOptIn|null);

                /** SigningInput messageOneof. */
                public messageOneof?: ("transfer"|"assetTransfer"|"assetOptIn");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Algorand.Proto.ISigningInput): TW.Algorand.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Algorand.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Algorand.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Algorand.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Algorand.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Algorand.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput signature */
                signature?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Algorand.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput signature. */
                public signature: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Algorand.Proto.ISigningOutput): TW.Algorand.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Algorand.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Algorand.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Algorand.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Algorand.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Algorand.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Aptos. */
    namespace Aptos {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransferMessage. */
            interface ITransferMessage {

                /** TransferMessage to */
                to?: (string|null);

                /** TransferMessage amount */
                amount?: (Long|null);
            }

            /** Represents a TransferMessage. */
            class TransferMessage implements ITransferMessage {

                /**
                 * Constructs a new TransferMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITransferMessage);

                /** TransferMessage to. */
                public to: string;

                /** TransferMessage amount. */
                public amount: Long;

                /**
                 * Creates a new TransferMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITransferMessage): TW.Aptos.Proto.TransferMessage;

                /**
                 * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Aptos.Proto.TransferMessage.verify|verify} messages.
                 * @param message TransferMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITransferMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TransferMessage;

                /**
                 * Verifies a TransferMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TransferMessage;

                /**
                 * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                 * @param message TransferMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TransferMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a StructTag. */
            interface IStructTag {

                /** StructTag accountAddress */
                accountAddress?: (string|null);

                /** StructTag module */
                module?: (string|null);

                /** StructTag name */
                name?: (string|null);
            }

            /** Represents a StructTag. */
            class StructTag implements IStructTag {

                /**
                 * Constructs a new StructTag.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.IStructTag);

                /** StructTag accountAddress. */
                public accountAddress: string;

                /** StructTag module. */
                public module: string;

                /** StructTag name. */
                public name: string;

                /**
                 * Creates a new StructTag instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StructTag instance
                 */
                public static create(properties?: TW.Aptos.Proto.IStructTag): TW.Aptos.Proto.StructTag;

                /**
                 * Encodes the specified StructTag message. Does not implicitly {@link TW.Aptos.Proto.StructTag.verify|verify} messages.
                 * @param message StructTag message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.IStructTag, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StructTag message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns StructTag
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.StructTag;

                /**
                 * Verifies a StructTag message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a StructTag message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns StructTag
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.StructTag;

                /**
                 * Creates a plain object from a StructTag message. Also converts values to other types if specified.
                 * @param message StructTag
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.StructTag, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this StructTag to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenTransferMessage. */
            interface ITokenTransferMessage {

                /** TokenTransferMessage to */
                to?: (string|null);

                /** TokenTransferMessage amount */
                amount?: (Long|null);

                /** TokenTransferMessage function */
                "function"?: (TW.Aptos.Proto.IStructTag|null);
            }

            /** Represents a TokenTransferMessage. */
            class TokenTransferMessage implements ITokenTransferMessage {

                /**
                 * Constructs a new TokenTransferMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITokenTransferMessage);

                /** TokenTransferMessage to. */
                public to: string;

                /** TokenTransferMessage amount. */
                public amount: Long;

                /** TokenTransferMessage function. */
                public function?: (TW.Aptos.Proto.IStructTag|null);

                /**
                 * Creates a new TokenTransferMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenTransferMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITokenTransferMessage): TW.Aptos.Proto.TokenTransferMessage;

                /**
                 * Encodes the specified TokenTransferMessage message. Does not implicitly {@link TW.Aptos.Proto.TokenTransferMessage.verify|verify} messages.
                 * @param message TokenTransferMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITokenTransferMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenTransferMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenTransferMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TokenTransferMessage;

                /**
                 * Verifies a TokenTransferMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenTransferMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenTransferMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TokenTransferMessage;

                /**
                 * Creates a plain object from a TokenTransferMessage message. Also converts values to other types if specified.
                 * @param message TokenTransferMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TokenTransferMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenTransferMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenTransferCoinsMessage. */
            interface ITokenTransferCoinsMessage {

                /** TokenTransferCoinsMessage to */
                to?: (string|null);

                /** TokenTransferCoinsMessage amount */
                amount?: (Long|null);

                /** TokenTransferCoinsMessage function */
                "function"?: (TW.Aptos.Proto.IStructTag|null);
            }

            /** Represents a TokenTransferCoinsMessage. */
            class TokenTransferCoinsMessage implements ITokenTransferCoinsMessage {

                /**
                 * Constructs a new TokenTransferCoinsMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITokenTransferCoinsMessage);

                /** TokenTransferCoinsMessage to. */
                public to: string;

                /** TokenTransferCoinsMessage amount. */
                public amount: Long;

                /** TokenTransferCoinsMessage function. */
                public function?: (TW.Aptos.Proto.IStructTag|null);

                /**
                 * Creates a new TokenTransferCoinsMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenTransferCoinsMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITokenTransferCoinsMessage): TW.Aptos.Proto.TokenTransferCoinsMessage;

                /**
                 * Encodes the specified TokenTransferCoinsMessage message. Does not implicitly {@link TW.Aptos.Proto.TokenTransferCoinsMessage.verify|verify} messages.
                 * @param message TokenTransferCoinsMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITokenTransferCoinsMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenTransferCoinsMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenTransferCoinsMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TokenTransferCoinsMessage;

                /**
                 * Verifies a TokenTransferCoinsMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenTransferCoinsMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenTransferCoinsMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TokenTransferCoinsMessage;

                /**
                 * Creates a plain object from a TokenTransferCoinsMessage message. Also converts values to other types if specified.
                 * @param message TokenTransferCoinsMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TokenTransferCoinsMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenTransferCoinsMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ManagedTokensRegisterMessage. */
            interface IManagedTokensRegisterMessage {

                /** ManagedTokensRegisterMessage function */
                "function"?: (TW.Aptos.Proto.IStructTag|null);
            }

            /** Represents a ManagedTokensRegisterMessage. */
            class ManagedTokensRegisterMessage implements IManagedTokensRegisterMessage {

                /**
                 * Constructs a new ManagedTokensRegisterMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.IManagedTokensRegisterMessage);

                /** ManagedTokensRegisterMessage function. */
                public function?: (TW.Aptos.Proto.IStructTag|null);

                /**
                 * Creates a new ManagedTokensRegisterMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ManagedTokensRegisterMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.IManagedTokensRegisterMessage): TW.Aptos.Proto.ManagedTokensRegisterMessage;

                /**
                 * Encodes the specified ManagedTokensRegisterMessage message. Does not implicitly {@link TW.Aptos.Proto.ManagedTokensRegisterMessage.verify|verify} messages.
                 * @param message ManagedTokensRegisterMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.IManagedTokensRegisterMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ManagedTokensRegisterMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ManagedTokensRegisterMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.ManagedTokensRegisterMessage;

                /**
                 * Verifies a ManagedTokensRegisterMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ManagedTokensRegisterMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ManagedTokensRegisterMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.ManagedTokensRegisterMessage;

                /**
                 * Creates a plain object from a ManagedTokensRegisterMessage message. Also converts values to other types if specified.
                 * @param message ManagedTokensRegisterMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.ManagedTokensRegisterMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ManagedTokensRegisterMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CreateAccountMessage. */
            interface ICreateAccountMessage {

                /** CreateAccountMessage authKey */
                authKey?: (string|null);
            }

            /** Represents a CreateAccountMessage. */
            class CreateAccountMessage implements ICreateAccountMessage {

                /**
                 * Constructs a new CreateAccountMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ICreateAccountMessage);

                /** CreateAccountMessage authKey. */
                public authKey: string;

                /**
                 * Creates a new CreateAccountMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CreateAccountMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.ICreateAccountMessage): TW.Aptos.Proto.CreateAccountMessage;

                /**
                 * Encodes the specified CreateAccountMessage message. Does not implicitly {@link TW.Aptos.Proto.CreateAccountMessage.verify|verify} messages.
                 * @param message CreateAccountMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ICreateAccountMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CreateAccountMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CreateAccountMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.CreateAccountMessage;

                /**
                 * Verifies a CreateAccountMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CreateAccountMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CreateAccountMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.CreateAccountMessage;

                /**
                 * Creates a plain object from a CreateAccountMessage message. Also converts values to other types if specified.
                 * @param message CreateAccountMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.CreateAccountMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CreateAccountMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OfferNftMessage. */
            interface IOfferNftMessage {

                /** OfferNftMessage receiver */
                receiver?: (string|null);

                /** OfferNftMessage creator */
                creator?: (string|null);

                /** OfferNftMessage collectionName */
                collectionName?: (string|null);

                /** OfferNftMessage name */
                name?: (string|null);

                /** OfferNftMessage propertyVersion */
                propertyVersion?: (Long|null);

                /** OfferNftMessage amount */
                amount?: (Long|null);
            }

            /** Represents an OfferNftMessage. */
            class OfferNftMessage implements IOfferNftMessage {

                /**
                 * Constructs a new OfferNftMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.IOfferNftMessage);

                /** OfferNftMessage receiver. */
                public receiver: string;

                /** OfferNftMessage creator. */
                public creator: string;

                /** OfferNftMessage collectionName. */
                public collectionName: string;

                /** OfferNftMessage name. */
                public name: string;

                /** OfferNftMessage propertyVersion. */
                public propertyVersion: Long;

                /** OfferNftMessage amount. */
                public amount: Long;

                /**
                 * Creates a new OfferNftMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OfferNftMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.IOfferNftMessage): TW.Aptos.Proto.OfferNftMessage;

                /**
                 * Encodes the specified OfferNftMessage message. Does not implicitly {@link TW.Aptos.Proto.OfferNftMessage.verify|verify} messages.
                 * @param message OfferNftMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.IOfferNftMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OfferNftMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OfferNftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.OfferNftMessage;

                /**
                 * Verifies an OfferNftMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OfferNftMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OfferNftMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.OfferNftMessage;

                /**
                 * Creates a plain object from an OfferNftMessage message. Also converts values to other types if specified.
                 * @param message OfferNftMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.OfferNftMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OfferNftMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CancelOfferNftMessage. */
            interface ICancelOfferNftMessage {

                /** CancelOfferNftMessage receiver */
                receiver?: (string|null);

                /** CancelOfferNftMessage creator */
                creator?: (string|null);

                /** CancelOfferNftMessage collectionName */
                collectionName?: (string|null);

                /** CancelOfferNftMessage name */
                name?: (string|null);

                /** CancelOfferNftMessage propertyVersion */
                propertyVersion?: (Long|null);
            }

            /** Represents a CancelOfferNftMessage. */
            class CancelOfferNftMessage implements ICancelOfferNftMessage {

                /**
                 * Constructs a new CancelOfferNftMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ICancelOfferNftMessage);

                /** CancelOfferNftMessage receiver. */
                public receiver: string;

                /** CancelOfferNftMessage creator. */
                public creator: string;

                /** CancelOfferNftMessage collectionName. */
                public collectionName: string;

                /** CancelOfferNftMessage name. */
                public name: string;

                /** CancelOfferNftMessage propertyVersion. */
                public propertyVersion: Long;

                /**
                 * Creates a new CancelOfferNftMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CancelOfferNftMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.ICancelOfferNftMessage): TW.Aptos.Proto.CancelOfferNftMessage;

                /**
                 * Encodes the specified CancelOfferNftMessage message. Does not implicitly {@link TW.Aptos.Proto.CancelOfferNftMessage.verify|verify} messages.
                 * @param message CancelOfferNftMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ICancelOfferNftMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CancelOfferNftMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CancelOfferNftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.CancelOfferNftMessage;

                /**
                 * Verifies a CancelOfferNftMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CancelOfferNftMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CancelOfferNftMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.CancelOfferNftMessage;

                /**
                 * Creates a plain object from a CancelOfferNftMessage message. Also converts values to other types if specified.
                 * @param message CancelOfferNftMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.CancelOfferNftMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CancelOfferNftMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ClaimNftMessage. */
            interface IClaimNftMessage {

                /** ClaimNftMessage sender */
                sender?: (string|null);

                /** ClaimNftMessage creator */
                creator?: (string|null);

                /** ClaimNftMessage collectionName */
                collectionName?: (string|null);

                /** ClaimNftMessage name */
                name?: (string|null);

                /** ClaimNftMessage propertyVersion */
                propertyVersion?: (Long|null);
            }

            /** Represents a ClaimNftMessage. */
            class ClaimNftMessage implements IClaimNftMessage {

                /**
                 * Constructs a new ClaimNftMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.IClaimNftMessage);

                /** ClaimNftMessage sender. */
                public sender: string;

                /** ClaimNftMessage creator. */
                public creator: string;

                /** ClaimNftMessage collectionName. */
                public collectionName: string;

                /** ClaimNftMessage name. */
                public name: string;

                /** ClaimNftMessage propertyVersion. */
                public propertyVersion: Long;

                /**
                 * Creates a new ClaimNftMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ClaimNftMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.IClaimNftMessage): TW.Aptos.Proto.ClaimNftMessage;

                /**
                 * Encodes the specified ClaimNftMessage message. Does not implicitly {@link TW.Aptos.Proto.ClaimNftMessage.verify|verify} messages.
                 * @param message ClaimNftMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.IClaimNftMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ClaimNftMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ClaimNftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.ClaimNftMessage;

                /**
                 * Verifies a ClaimNftMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ClaimNftMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ClaimNftMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.ClaimNftMessage;

                /**
                 * Creates a plain object from a ClaimNftMessage message. Also converts values to other types if specified.
                 * @param message ClaimNftMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.ClaimNftMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ClaimNftMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TortugaClaim. */
            interface ITortugaClaim {

                /** TortugaClaim idx */
                idx?: (Long|null);
            }

            /** Represents a TortugaClaim. */
            class TortugaClaim implements ITortugaClaim {

                /**
                 * Constructs a new TortugaClaim.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITortugaClaim);

                /** TortugaClaim idx. */
                public idx: Long;

                /**
                 * Creates a new TortugaClaim instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TortugaClaim instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITortugaClaim): TW.Aptos.Proto.TortugaClaim;

                /**
                 * Encodes the specified TortugaClaim message. Does not implicitly {@link TW.Aptos.Proto.TortugaClaim.verify|verify} messages.
                 * @param message TortugaClaim message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITortugaClaim, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TortugaClaim message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TortugaClaim
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TortugaClaim;

                /**
                 * Verifies a TortugaClaim message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TortugaClaim message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TortugaClaim
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TortugaClaim;

                /**
                 * Creates a plain object from a TortugaClaim message. Also converts values to other types if specified.
                 * @param message TortugaClaim
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TortugaClaim, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TortugaClaim to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TortugaStake. */
            interface ITortugaStake {

                /** TortugaStake amount */
                amount?: (Long|null);
            }

            /** Represents a TortugaStake. */
            class TortugaStake implements ITortugaStake {

                /**
                 * Constructs a new TortugaStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITortugaStake);

                /** TortugaStake amount. */
                public amount: Long;

                /**
                 * Creates a new TortugaStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TortugaStake instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITortugaStake): TW.Aptos.Proto.TortugaStake;

                /**
                 * Encodes the specified TortugaStake message. Does not implicitly {@link TW.Aptos.Proto.TortugaStake.verify|verify} messages.
                 * @param message TortugaStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITortugaStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TortugaStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TortugaStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TortugaStake;

                /**
                 * Verifies a TortugaStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TortugaStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TortugaStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TortugaStake;

                /**
                 * Creates a plain object from a TortugaStake message. Also converts values to other types if specified.
                 * @param message TortugaStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TortugaStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TortugaStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TortugaUnstake. */
            interface ITortugaUnstake {

                /** TortugaUnstake amount */
                amount?: (Long|null);
            }

            /** Represents a TortugaUnstake. */
            class TortugaUnstake implements ITortugaUnstake {

                /**
                 * Constructs a new TortugaUnstake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITortugaUnstake);

                /** TortugaUnstake amount. */
                public amount: Long;

                /**
                 * Creates a new TortugaUnstake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TortugaUnstake instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITortugaUnstake): TW.Aptos.Proto.TortugaUnstake;

                /**
                 * Encodes the specified TortugaUnstake message. Does not implicitly {@link TW.Aptos.Proto.TortugaUnstake.verify|verify} messages.
                 * @param message TortugaUnstake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITortugaUnstake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TortugaUnstake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TortugaUnstake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TortugaUnstake;

                /**
                 * Verifies a TortugaUnstake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TortugaUnstake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TortugaUnstake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TortugaUnstake;

                /**
                 * Creates a plain object from a TortugaUnstake message. Also converts values to other types if specified.
                 * @param message TortugaUnstake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TortugaUnstake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TortugaUnstake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a LiquidStaking. */
            interface ILiquidStaking {

                /** LiquidStaking smartContractAddress */
                smartContractAddress?: (string|null);

                /** LiquidStaking stake */
                stake?: (TW.Aptos.Proto.ITortugaStake|null);

                /** LiquidStaking unstake */
                unstake?: (TW.Aptos.Proto.ITortugaUnstake|null);

                /** LiquidStaking claim */
                claim?: (TW.Aptos.Proto.ITortugaClaim|null);
            }

            /** Represents a LiquidStaking. */
            class LiquidStaking implements ILiquidStaking {

                /**
                 * Constructs a new LiquidStaking.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ILiquidStaking);

                /** LiquidStaking smartContractAddress. */
                public smartContractAddress: string;

                /** LiquidStaking stake. */
                public stake?: (TW.Aptos.Proto.ITortugaStake|null);

                /** LiquidStaking unstake. */
                public unstake?: (TW.Aptos.Proto.ITortugaUnstake|null);

                /** LiquidStaking claim. */
                public claim?: (TW.Aptos.Proto.ITortugaClaim|null);

                /** LiquidStaking liquidStakeTransactionPayload. */
                public liquidStakeTransactionPayload?: ("stake"|"unstake"|"claim");

                /**
                 * Creates a new LiquidStaking instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns LiquidStaking instance
                 */
                public static create(properties?: TW.Aptos.Proto.ILiquidStaking): TW.Aptos.Proto.LiquidStaking;

                /**
                 * Encodes the specified LiquidStaking message. Does not implicitly {@link TW.Aptos.Proto.LiquidStaking.verify|verify} messages.
                 * @param message LiquidStaking message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ILiquidStaking, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LiquidStaking message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns LiquidStaking
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.LiquidStaking;

                /**
                 * Verifies a LiquidStaking message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a LiquidStaking message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns LiquidStaking
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.LiquidStaking;

                /**
                 * Creates a plain object from a LiquidStaking message. Also converts values to other types if specified.
                 * @param message LiquidStaking
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.LiquidStaking, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this LiquidStaking to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a NftMessage. */
            interface INftMessage {

                /** NftMessage offerNft */
                offerNft?: (TW.Aptos.Proto.IOfferNftMessage|null);

                /** NftMessage cancelOfferNft */
                cancelOfferNft?: (TW.Aptos.Proto.ICancelOfferNftMessage|null);

                /** NftMessage claimNft */
                claimNft?: (TW.Aptos.Proto.IClaimNftMessage|null);
            }

            /** Represents a NftMessage. */
            class NftMessage implements INftMessage {

                /**
                 * Constructs a new NftMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.INftMessage);

                /** NftMessage offerNft. */
                public offerNft?: (TW.Aptos.Proto.IOfferNftMessage|null);

                /** NftMessage cancelOfferNft. */
                public cancelOfferNft?: (TW.Aptos.Proto.ICancelOfferNftMessage|null);

                /** NftMessage claimNft. */
                public claimNft?: (TW.Aptos.Proto.IClaimNftMessage|null);

                /** NftMessage nftTransactionPayload. */
                public nftTransactionPayload?: ("offerNft"|"cancelOfferNft"|"claimNft");

                /**
                 * Creates a new NftMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NftMessage instance
                 */
                public static create(properties?: TW.Aptos.Proto.INftMessage): TW.Aptos.Proto.NftMessage;

                /**
                 * Encodes the specified NftMessage message. Does not implicitly {@link TW.Aptos.Proto.NftMessage.verify|verify} messages.
                 * @param message NftMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.INftMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NftMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NftMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.NftMessage;

                /**
                 * Verifies a NftMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NftMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NftMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.NftMessage;

                /**
                 * Creates a plain object from a NftMessage message. Also converts values to other types if specified.
                 * @param message NftMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.NftMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NftMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput sender */
                sender?: (string|null);

                /** SigningInput sequenceNumber */
                sequenceNumber?: (Long|null);

                /** SigningInput maxGasAmount */
                maxGasAmount?: (Long|null);

                /** SigningInput gasUnitPrice */
                gasUnitPrice?: (Long|null);

                /** SigningInput expirationTimestampSecs */
                expirationTimestampSecs?: (Long|null);

                /** SigningInput chainId */
                chainId?: (number|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput anyEncoded */
                anyEncoded?: (string|null);

                /** SigningInput transfer */
                transfer?: (TW.Aptos.Proto.ITransferMessage|null);

                /** SigningInput tokenTransfer */
                tokenTransfer?: (TW.Aptos.Proto.ITokenTransferMessage|null);

                /** SigningInput createAccount */
                createAccount?: (TW.Aptos.Proto.ICreateAccountMessage|null);

                /** SigningInput nftMessage */
                nftMessage?: (TW.Aptos.Proto.INftMessage|null);

                /** SigningInput registerToken */
                registerToken?: (TW.Aptos.Proto.IManagedTokensRegisterMessage|null);

                /** SigningInput liquidStakingMessage */
                liquidStakingMessage?: (TW.Aptos.Proto.ILiquidStaking|null);

                /** SigningInput tokenTransferCoins */
                tokenTransferCoins?: (TW.Aptos.Proto.ITokenTransferCoinsMessage|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ISigningInput);

                /** SigningInput sender. */
                public sender: string;

                /** SigningInput sequenceNumber. */
                public sequenceNumber: Long;

                /** SigningInput maxGasAmount. */
                public maxGasAmount: Long;

                /** SigningInput gasUnitPrice. */
                public gasUnitPrice: Long;

                /** SigningInput expirationTimestampSecs. */
                public expirationTimestampSecs: Long;

                /** SigningInput chainId. */
                public chainId: number;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput anyEncoded. */
                public anyEncoded: string;

                /** SigningInput transfer. */
                public transfer?: (TW.Aptos.Proto.ITransferMessage|null);

                /** SigningInput tokenTransfer. */
                public tokenTransfer?: (TW.Aptos.Proto.ITokenTransferMessage|null);

                /** SigningInput createAccount. */
                public createAccount?: (TW.Aptos.Proto.ICreateAccountMessage|null);

                /** SigningInput nftMessage. */
                public nftMessage?: (TW.Aptos.Proto.INftMessage|null);

                /** SigningInput registerToken. */
                public registerToken?: (TW.Aptos.Proto.IManagedTokensRegisterMessage|null);

                /** SigningInput liquidStakingMessage. */
                public liquidStakingMessage?: (TW.Aptos.Proto.ILiquidStaking|null);

                /** SigningInput tokenTransferCoins. */
                public tokenTransferCoins?: (TW.Aptos.Proto.ITokenTransferCoinsMessage|null);

                /** SigningInput transactionPayload. */
                public transactionPayload?: ("transfer"|"tokenTransfer"|"createAccount"|"nftMessage"|"registerToken"|"liquidStakingMessage"|"tokenTransferCoins");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Aptos.Proto.ISigningInput): TW.Aptos.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aptos.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionAuthenticator. */
            interface ITransactionAuthenticator {

                /** TransactionAuthenticator signature */
                signature?: (Uint8Array|null);

                /** TransactionAuthenticator publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a TransactionAuthenticator. */
            class TransactionAuthenticator implements ITransactionAuthenticator {

                /**
                 * Constructs a new TransactionAuthenticator.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ITransactionAuthenticator);

                /** TransactionAuthenticator signature. */
                public signature: Uint8Array;

                /** TransactionAuthenticator publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new TransactionAuthenticator instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionAuthenticator instance
                 */
                public static create(properties?: TW.Aptos.Proto.ITransactionAuthenticator): TW.Aptos.Proto.TransactionAuthenticator;

                /**
                 * Encodes the specified TransactionAuthenticator message. Does not implicitly {@link TW.Aptos.Proto.TransactionAuthenticator.verify|verify} messages.
                 * @param message TransactionAuthenticator message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ITransactionAuthenticator, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionAuthenticator message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionAuthenticator
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.TransactionAuthenticator;

                /**
                 * Verifies a TransactionAuthenticator message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionAuthenticator message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionAuthenticator
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.TransactionAuthenticator;

                /**
                 * Creates a plain object from a TransactionAuthenticator message. Also converts values to other types if specified.
                 * @param message TransactionAuthenticator
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.TransactionAuthenticator, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionAuthenticator to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** The raw transaction (bytes) */
                rawTxn?: (Uint8Array|null);

                /** Public key and signature to authenticate */
                authenticator?: (TW.Aptos.Proto.ITransactionAuthenticator|null);

                /** Signed and encoded transaction bytes. */
                encoded?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Aptos.Proto.ISigningOutput);

                /** The raw transaction (bytes) */
                public rawTxn: Uint8Array;

                /** Public key and signature to authenticate */
                public authenticator?: (TW.Aptos.Proto.ITransactionAuthenticator|null);

                /** Signed and encoded transaction bytes. */
                public encoded: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Aptos.Proto.ISigningOutput): TW.Aptos.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aptos.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Aptos.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Aptos.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Aptos.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Aptos.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Barz. */
    namespace Barz {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a ContractAddressInput. */
            interface IContractAddressInput {

                /** ContractAddressInput entryPoint */
                entryPoint?: (string|null);

                /** ContractAddressInput factory */
                factory?: (string|null);

                /** ContractAddressInput accountFacet */
                accountFacet?: (string|null);

                /** ContractAddressInput verificationFacet */
                verificationFacet?: (string|null);

                /** ContractAddressInput facetRegistry */
                facetRegistry?: (string|null);

                /** ContractAddressInput defaultFallback */
                defaultFallback?: (string|null);

                /** ContractAddressInput bytecode */
                bytecode?: (string|null);

                /** ContractAddressInput publicKey */
                publicKey?: (string|null);

                /** ContractAddressInput salt */
                salt?: (number|null);
            }

            /** Represents a ContractAddressInput. */
            class ContractAddressInput implements IContractAddressInput {

                /**
                 * Constructs a new ContractAddressInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Barz.Proto.IContractAddressInput);

                /** ContractAddressInput entryPoint. */
                public entryPoint: string;

                /** ContractAddressInput factory. */
                public factory: string;

                /** ContractAddressInput accountFacet. */
                public accountFacet: string;

                /** ContractAddressInput verificationFacet. */
                public verificationFacet: string;

                /** ContractAddressInput facetRegistry. */
                public facetRegistry: string;

                /** ContractAddressInput defaultFallback. */
                public defaultFallback: string;

                /** ContractAddressInput bytecode. */
                public bytecode: string;

                /** ContractAddressInput publicKey. */
                public publicKey: string;

                /** ContractAddressInput salt. */
                public salt: number;

                /**
                 * Creates a new ContractAddressInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractAddressInput instance
                 */
                public static create(properties?: TW.Barz.Proto.IContractAddressInput): TW.Barz.Proto.ContractAddressInput;

                /**
                 * Encodes the specified ContractAddressInput message. Does not implicitly {@link TW.Barz.Proto.ContractAddressInput.verify|verify} messages.
                 * @param message ContractAddressInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Barz.Proto.IContractAddressInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractAddressInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ContractAddressInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Barz.Proto.ContractAddressInput;

                /**
                 * Verifies a ContractAddressInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ContractAddressInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ContractAddressInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Barz.Proto.ContractAddressInput;

                /**
                 * Creates a plain object from a ContractAddressInput message. Also converts values to other types if specified.
                 * @param message ContractAddressInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Barz.Proto.ContractAddressInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ContractAddressInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Binance. */
    namespace Binance {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction msgs */
                msgs?: (Uint8Array[]|null);

                /** Transaction signatures */
                signatures?: (Uint8Array[]|null);

                /** Transaction memo */
                memo?: (string|null);

                /** Transaction source */
                source?: (Long|null);

                /** Transaction data */
                data?: (Uint8Array|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITransaction);

                /** Transaction msgs. */
                public msgs: Uint8Array[];

                /** Transaction signatures. */
                public signatures: Uint8Array[];

                /** Transaction memo. */
                public memo: string;

                /** Transaction source. */
                public source: Long;

                /** Transaction data. */
                public data: Uint8Array;

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Binance.Proto.ITransaction): TW.Binance.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Binance.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Signature. */
            interface ISignature {

                /** Signature pubKey */
                pubKey?: (Uint8Array|null);

                /** Signature signature */
                signature?: (Uint8Array|null);

                /** Signature accountNumber */
                accountNumber?: (Long|null);

                /** Signature sequence */
                sequence?: (Long|null);
            }

            /** Represents a Signature. */
            class Signature implements ISignature {

                /**
                 * Constructs a new Signature.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISignature);

                /** Signature pubKey. */
                public pubKey: Uint8Array;

                /** Signature signature. */
                public signature: Uint8Array;

                /** Signature accountNumber. */
                public accountNumber: Long;

                /** Signature sequence. */
                public sequence: Long;

                /**
                 * Creates a new Signature instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Signature instance
                 */
                public static create(properties?: TW.Binance.Proto.ISignature): TW.Binance.Proto.Signature;

                /**
                 * Encodes the specified Signature message. Does not implicitly {@link TW.Binance.Proto.Signature.verify|verify} messages.
                 * @param message Signature message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISignature, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Signature message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Signature
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.Signature;

                /**
                 * Verifies a Signature message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Signature
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.Signature;

                /**
                 * Creates a plain object from a Signature message. Also converts values to other types if specified.
                 * @param message Signature
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.Signature, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Signature to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TradeOrder. */
            interface ITradeOrder {

                /** TradeOrder sender */
                sender?: (Uint8Array|null);

                /** TradeOrder id */
                id?: (string|null);

                /** TradeOrder symbol */
                symbol?: (string|null);

                /** TradeOrder ordertype */
                ordertype?: (Long|null);

                /** TradeOrder side */
                side?: (Long|null);

                /** TradeOrder price */
                price?: (Long|null);

                /** TradeOrder quantity */
                quantity?: (Long|null);

                /** TradeOrder timeinforce */
                timeinforce?: (Long|null);
            }

            /** Represents a TradeOrder. */
            class TradeOrder implements ITradeOrder {

                /**
                 * Constructs a new TradeOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITradeOrder);

                /** TradeOrder sender. */
                public sender: Uint8Array;

                /** TradeOrder id. */
                public id: string;

                /** TradeOrder symbol. */
                public symbol: string;

                /** TradeOrder ordertype. */
                public ordertype: Long;

                /** TradeOrder side. */
                public side: Long;

                /** TradeOrder price. */
                public price: Long;

                /** TradeOrder quantity. */
                public quantity: Long;

                /** TradeOrder timeinforce. */
                public timeinforce: Long;

                /**
                 * Creates a new TradeOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TradeOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITradeOrder): TW.Binance.Proto.TradeOrder;

                /**
                 * Encodes the specified TradeOrder message. Does not implicitly {@link TW.Binance.Proto.TradeOrder.verify|verify} messages.
                 * @param message TradeOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITradeOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TradeOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TradeOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TradeOrder;

                /**
                 * Verifies a TradeOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TradeOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TradeOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TradeOrder;

                /**
                 * Creates a plain object from a TradeOrder message. Also converts values to other types if specified.
                 * @param message TradeOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TradeOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TradeOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CancelTradeOrder. */
            interface ICancelTradeOrder {

                /** CancelTradeOrder sender */
                sender?: (Uint8Array|null);

                /** CancelTradeOrder symbol */
                symbol?: (string|null);

                /** CancelTradeOrder refid */
                refid?: (string|null);
            }

            /** Represents a CancelTradeOrder. */
            class CancelTradeOrder implements ICancelTradeOrder {

                /**
                 * Constructs a new CancelTradeOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ICancelTradeOrder);

                /** CancelTradeOrder sender. */
                public sender: Uint8Array;

                /** CancelTradeOrder symbol. */
                public symbol: string;

                /** CancelTradeOrder refid. */
                public refid: string;

                /**
                 * Creates a new CancelTradeOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CancelTradeOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ICancelTradeOrder): TW.Binance.Proto.CancelTradeOrder;

                /**
                 * Encodes the specified CancelTradeOrder message. Does not implicitly {@link TW.Binance.Proto.CancelTradeOrder.verify|verify} messages.
                 * @param message CancelTradeOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ICancelTradeOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CancelTradeOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CancelTradeOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.CancelTradeOrder;

                /**
                 * Verifies a CancelTradeOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CancelTradeOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CancelTradeOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.CancelTradeOrder;

                /**
                 * Creates a plain object from a CancelTradeOrder message. Also converts values to other types if specified.
                 * @param message CancelTradeOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.CancelTradeOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CancelTradeOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SendOrder. */
            interface ISendOrder {

                /** SendOrder inputs */
                inputs?: (TW.Binance.Proto.SendOrder.IInput[]|null);

                /** SendOrder outputs */
                outputs?: (TW.Binance.Proto.SendOrder.IOutput[]|null);
            }

            /** Represents a SendOrder. */
            class SendOrder implements ISendOrder {

                /**
                 * Constructs a new SendOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISendOrder);

                /** SendOrder inputs. */
                public inputs: TW.Binance.Proto.SendOrder.IInput[];

                /** SendOrder outputs. */
                public outputs: TW.Binance.Proto.SendOrder.IOutput[];

                /**
                 * Creates a new SendOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SendOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ISendOrder): TW.Binance.Proto.SendOrder;

                /**
                 * Encodes the specified SendOrder message. Does not implicitly {@link TW.Binance.Proto.SendOrder.verify|verify} messages.
                 * @param message SendOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISendOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SendOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SendOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SendOrder;

                /**
                 * Verifies a SendOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SendOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SendOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SendOrder;

                /**
                 * Creates a plain object from a SendOrder message. Also converts values to other types if specified.
                 * @param message SendOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SendOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SendOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace SendOrder {

                /** Properties of a Token. */
                interface IToken {

                    /** Token denom */
                    denom?: (string|null);

                    /** Token amount */
                    amount?: (Long|null);
                }

                /** Represents a Token. */
                class Token implements IToken {

                    /**
                     * Constructs a new Token.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Binance.Proto.SendOrder.IToken);

                    /** Token denom. */
                    public denom: string;

                    /** Token amount. */
                    public amount: Long;

                    /**
                     * Creates a new Token instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Token instance
                     */
                    public static create(properties?: TW.Binance.Proto.SendOrder.IToken): TW.Binance.Proto.SendOrder.Token;

                    /**
                     * Encodes the specified Token message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Token.verify|verify} messages.
                     * @param message Token message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Binance.Proto.SendOrder.IToken, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Token message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Token
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SendOrder.Token;

                    /**
                     * Verifies a Token message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Token message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Token
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SendOrder.Token;

                    /**
                     * Creates a plain object from a Token message. Also converts values to other types if specified.
                     * @param message Token
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Binance.Proto.SendOrder.Token, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Token to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an Input. */
                interface IInput {

                    /** Input address */
                    address?: (Uint8Array|null);

                    /** Input coins */
                    coins?: (TW.Binance.Proto.SendOrder.IToken[]|null);
                }

                /** Represents an Input. */
                class Input implements IInput {

                    /**
                     * Constructs a new Input.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Binance.Proto.SendOrder.IInput);

                    /** Input address. */
                    public address: Uint8Array;

                    /** Input coins. */
                    public coins: TW.Binance.Proto.SendOrder.IToken[];

                    /**
                     * Creates a new Input instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Input instance
                     */
                    public static create(properties?: TW.Binance.Proto.SendOrder.IInput): TW.Binance.Proto.SendOrder.Input;

                    /**
                     * Encodes the specified Input message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Input.verify|verify} messages.
                     * @param message Input message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Binance.Proto.SendOrder.IInput, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an Input message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Input
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SendOrder.Input;

                    /**
                     * Verifies an Input message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an Input message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Input
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SendOrder.Input;

                    /**
                     * Creates a plain object from an Input message. Also converts values to other types if specified.
                     * @param message Input
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Binance.Proto.SendOrder.Input, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Input to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an Output. */
                interface IOutput {

                    /** Output address */
                    address?: (Uint8Array|null);

                    /** Output coins */
                    coins?: (TW.Binance.Proto.SendOrder.IToken[]|null);
                }

                /** Represents an Output. */
                class Output implements IOutput {

                    /**
                     * Constructs a new Output.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Binance.Proto.SendOrder.IOutput);

                    /** Output address. */
                    public address: Uint8Array;

                    /** Output coins. */
                    public coins: TW.Binance.Proto.SendOrder.IToken[];

                    /**
                     * Creates a new Output instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Output instance
                     */
                    public static create(properties?: TW.Binance.Proto.SendOrder.IOutput): TW.Binance.Proto.SendOrder.Output;

                    /**
                     * Encodes the specified Output message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Output.verify|verify} messages.
                     * @param message Output message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Binance.Proto.SendOrder.IOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an Output message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Output
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SendOrder.Output;

                    /**
                     * Verifies an Output message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an Output message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Output
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SendOrder.Output;

                    /**
                     * Creates a plain object from an Output message. Also converts values to other types if specified.
                     * @param message Output
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Binance.Proto.SendOrder.Output, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Output to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a TokenIssueOrder. */
            interface ITokenIssueOrder {

                /** TokenIssueOrder from */
                from?: (Uint8Array|null);

                /** TokenIssueOrder name */
                name?: (string|null);

                /** TokenIssueOrder symbol */
                symbol?: (string|null);

                /** TokenIssueOrder totalSupply */
                totalSupply?: (Long|null);

                /** TokenIssueOrder mintable */
                mintable?: (boolean|null);
            }

            /** Represents a TokenIssueOrder. */
            class TokenIssueOrder implements ITokenIssueOrder {

                /**
                 * Constructs a new TokenIssueOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITokenIssueOrder);

                /** TokenIssueOrder from. */
                public from: Uint8Array;

                /** TokenIssueOrder name. */
                public name: string;

                /** TokenIssueOrder symbol. */
                public symbol: string;

                /** TokenIssueOrder totalSupply. */
                public totalSupply: Long;

                /** TokenIssueOrder mintable. */
                public mintable: boolean;

                /**
                 * Creates a new TokenIssueOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenIssueOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITokenIssueOrder): TW.Binance.Proto.TokenIssueOrder;

                /**
                 * Encodes the specified TokenIssueOrder message. Does not implicitly {@link TW.Binance.Proto.TokenIssueOrder.verify|verify} messages.
                 * @param message TokenIssueOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITokenIssueOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenIssueOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenIssueOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TokenIssueOrder;

                /**
                 * Verifies a TokenIssueOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenIssueOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenIssueOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TokenIssueOrder;

                /**
                 * Creates a plain object from a TokenIssueOrder message. Also converts values to other types if specified.
                 * @param message TokenIssueOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TokenIssueOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenIssueOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenMintOrder. */
            interface ITokenMintOrder {

                /** TokenMintOrder from */
                from?: (Uint8Array|null);

                /** TokenMintOrder symbol */
                symbol?: (string|null);

                /** TokenMintOrder amount */
                amount?: (Long|null);
            }

            /** Represents a TokenMintOrder. */
            class TokenMintOrder implements ITokenMintOrder {

                /**
                 * Constructs a new TokenMintOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITokenMintOrder);

                /** TokenMintOrder from. */
                public from: Uint8Array;

                /** TokenMintOrder symbol. */
                public symbol: string;

                /** TokenMintOrder amount. */
                public amount: Long;

                /**
                 * Creates a new TokenMintOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenMintOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITokenMintOrder): TW.Binance.Proto.TokenMintOrder;

                /**
                 * Encodes the specified TokenMintOrder message. Does not implicitly {@link TW.Binance.Proto.TokenMintOrder.verify|verify} messages.
                 * @param message TokenMintOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITokenMintOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenMintOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenMintOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TokenMintOrder;

                /**
                 * Verifies a TokenMintOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenMintOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenMintOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TokenMintOrder;

                /**
                 * Creates a plain object from a TokenMintOrder message. Also converts values to other types if specified.
                 * @param message TokenMintOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TokenMintOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenMintOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenBurnOrder. */
            interface ITokenBurnOrder {

                /** TokenBurnOrder from */
                from?: (Uint8Array|null);

                /** TokenBurnOrder symbol */
                symbol?: (string|null);

                /** TokenBurnOrder amount */
                amount?: (Long|null);
            }

            /** Represents a TokenBurnOrder. */
            class TokenBurnOrder implements ITokenBurnOrder {

                /**
                 * Constructs a new TokenBurnOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITokenBurnOrder);

                /** TokenBurnOrder from. */
                public from: Uint8Array;

                /** TokenBurnOrder symbol. */
                public symbol: string;

                /** TokenBurnOrder amount. */
                public amount: Long;

                /**
                 * Creates a new TokenBurnOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenBurnOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITokenBurnOrder): TW.Binance.Proto.TokenBurnOrder;

                /**
                 * Encodes the specified TokenBurnOrder message. Does not implicitly {@link TW.Binance.Proto.TokenBurnOrder.verify|verify} messages.
                 * @param message TokenBurnOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITokenBurnOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenBurnOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenBurnOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TokenBurnOrder;

                /**
                 * Verifies a TokenBurnOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenBurnOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenBurnOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TokenBurnOrder;

                /**
                 * Creates a plain object from a TokenBurnOrder message. Also converts values to other types if specified.
                 * @param message TokenBurnOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TokenBurnOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenBurnOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenFreezeOrder. */
            interface ITokenFreezeOrder {

                /** TokenFreezeOrder from */
                from?: (Uint8Array|null);

                /** TokenFreezeOrder symbol */
                symbol?: (string|null);

                /** TokenFreezeOrder amount */
                amount?: (Long|null);
            }

            /** Represents a TokenFreezeOrder. */
            class TokenFreezeOrder implements ITokenFreezeOrder {

                /**
                 * Constructs a new TokenFreezeOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITokenFreezeOrder);

                /** TokenFreezeOrder from. */
                public from: Uint8Array;

                /** TokenFreezeOrder symbol. */
                public symbol: string;

                /** TokenFreezeOrder amount. */
                public amount: Long;

                /**
                 * Creates a new TokenFreezeOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenFreezeOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITokenFreezeOrder): TW.Binance.Proto.TokenFreezeOrder;

                /**
                 * Encodes the specified TokenFreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenFreezeOrder.verify|verify} messages.
                 * @param message TokenFreezeOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITokenFreezeOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenFreezeOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenFreezeOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TokenFreezeOrder;

                /**
                 * Verifies a TokenFreezeOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenFreezeOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenFreezeOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TokenFreezeOrder;

                /**
                 * Creates a plain object from a TokenFreezeOrder message. Also converts values to other types if specified.
                 * @param message TokenFreezeOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TokenFreezeOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenFreezeOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenUnfreezeOrder. */
            interface ITokenUnfreezeOrder {

                /** TokenUnfreezeOrder from */
                from?: (Uint8Array|null);

                /** TokenUnfreezeOrder symbol */
                symbol?: (string|null);

                /** TokenUnfreezeOrder amount */
                amount?: (Long|null);
            }

            /** Represents a TokenUnfreezeOrder. */
            class TokenUnfreezeOrder implements ITokenUnfreezeOrder {

                /**
                 * Constructs a new TokenUnfreezeOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITokenUnfreezeOrder);

                /** TokenUnfreezeOrder from. */
                public from: Uint8Array;

                /** TokenUnfreezeOrder symbol. */
                public symbol: string;

                /** TokenUnfreezeOrder amount. */
                public amount: Long;

                /**
                 * Creates a new TokenUnfreezeOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenUnfreezeOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITokenUnfreezeOrder): TW.Binance.Proto.TokenUnfreezeOrder;

                /**
                 * Encodes the specified TokenUnfreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenUnfreezeOrder.verify|verify} messages.
                 * @param message TokenUnfreezeOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITokenUnfreezeOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenUnfreezeOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenUnfreezeOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TokenUnfreezeOrder;

                /**
                 * Verifies a TokenUnfreezeOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenUnfreezeOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenUnfreezeOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TokenUnfreezeOrder;

                /**
                 * Creates a plain object from a TokenUnfreezeOrder message. Also converts values to other types if specified.
                 * @param message TokenUnfreezeOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TokenUnfreezeOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenUnfreezeOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a HTLTOrder. */
            interface IHTLTOrder {

                /** HTLTOrder from */
                from?: (Uint8Array|null);

                /** HTLTOrder to */
                to?: (Uint8Array|null);

                /** HTLTOrder recipientOtherChain */
                recipientOtherChain?: (string|null);

                /** HTLTOrder senderOtherChain */
                senderOtherChain?: (string|null);

                /** HTLTOrder randomNumberHash */
                randomNumberHash?: (Uint8Array|null);

                /** HTLTOrder timestamp */
                timestamp?: (Long|null);

                /** HTLTOrder amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken[]|null);

                /** HTLTOrder expectedIncome */
                expectedIncome?: (string|null);

                /** HTLTOrder heightSpan */
                heightSpan?: (Long|null);

                /** HTLTOrder crossChain */
                crossChain?: (boolean|null);
            }

            /** Represents a HTLTOrder. */
            class HTLTOrder implements IHTLTOrder {

                /**
                 * Constructs a new HTLTOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.IHTLTOrder);

                /** HTLTOrder from. */
                public from: Uint8Array;

                /** HTLTOrder to. */
                public to: Uint8Array;

                /** HTLTOrder recipientOtherChain. */
                public recipientOtherChain: string;

                /** HTLTOrder senderOtherChain. */
                public senderOtherChain: string;

                /** HTLTOrder randomNumberHash. */
                public randomNumberHash: Uint8Array;

                /** HTLTOrder timestamp. */
                public timestamp: Long;

                /** HTLTOrder amount. */
                public amount: TW.Binance.Proto.SendOrder.IToken[];

                /** HTLTOrder expectedIncome. */
                public expectedIncome: string;

                /** HTLTOrder heightSpan. */
                public heightSpan: Long;

                /** HTLTOrder crossChain. */
                public crossChain: boolean;

                /**
                 * Creates a new HTLTOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns HTLTOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.IHTLTOrder): TW.Binance.Proto.HTLTOrder;

                /**
                 * Encodes the specified HTLTOrder message. Does not implicitly {@link TW.Binance.Proto.HTLTOrder.verify|verify} messages.
                 * @param message HTLTOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.IHTLTOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HTLTOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns HTLTOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.HTLTOrder;

                /**
                 * Verifies a HTLTOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a HTLTOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns HTLTOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.HTLTOrder;

                /**
                 * Creates a plain object from a HTLTOrder message. Also converts values to other types if specified.
                 * @param message HTLTOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.HTLTOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this HTLTOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DepositHTLTOrder. */
            interface IDepositHTLTOrder {

                /** DepositHTLTOrder from */
                from?: (Uint8Array|null);

                /** DepositHTLTOrder amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken[]|null);

                /** DepositHTLTOrder swapId */
                swapId?: (Uint8Array|null);
            }

            /** Represents a DepositHTLTOrder. */
            class DepositHTLTOrder implements IDepositHTLTOrder {

                /**
                 * Constructs a new DepositHTLTOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.IDepositHTLTOrder);

                /** DepositHTLTOrder from. */
                public from: Uint8Array;

                /** DepositHTLTOrder amount. */
                public amount: TW.Binance.Proto.SendOrder.IToken[];

                /** DepositHTLTOrder swapId. */
                public swapId: Uint8Array;

                /**
                 * Creates a new DepositHTLTOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DepositHTLTOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.IDepositHTLTOrder): TW.Binance.Proto.DepositHTLTOrder;

                /**
                 * Encodes the specified DepositHTLTOrder message. Does not implicitly {@link TW.Binance.Proto.DepositHTLTOrder.verify|verify} messages.
                 * @param message DepositHTLTOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.IDepositHTLTOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DepositHTLTOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DepositHTLTOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.DepositHTLTOrder;

                /**
                 * Verifies a DepositHTLTOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DepositHTLTOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DepositHTLTOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.DepositHTLTOrder;

                /**
                 * Creates a plain object from a DepositHTLTOrder message. Also converts values to other types if specified.
                 * @param message DepositHTLTOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.DepositHTLTOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DepositHTLTOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ClaimHTLOrder. */
            interface IClaimHTLOrder {

                /** ClaimHTLOrder from */
                from?: (Uint8Array|null);

                /** ClaimHTLOrder swapId */
                swapId?: (Uint8Array|null);

                /** ClaimHTLOrder randomNumber */
                randomNumber?: (Uint8Array|null);
            }

            /** Represents a ClaimHTLOrder. */
            class ClaimHTLOrder implements IClaimHTLOrder {

                /**
                 * Constructs a new ClaimHTLOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.IClaimHTLOrder);

                /** ClaimHTLOrder from. */
                public from: Uint8Array;

                /** ClaimHTLOrder swapId. */
                public swapId: Uint8Array;

                /** ClaimHTLOrder randomNumber. */
                public randomNumber: Uint8Array;

                /**
                 * Creates a new ClaimHTLOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ClaimHTLOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.IClaimHTLOrder): TW.Binance.Proto.ClaimHTLOrder;

                /**
                 * Encodes the specified ClaimHTLOrder message. Does not implicitly {@link TW.Binance.Proto.ClaimHTLOrder.verify|verify} messages.
                 * @param message ClaimHTLOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.IClaimHTLOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ClaimHTLOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ClaimHTLOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.ClaimHTLOrder;

                /**
                 * Verifies a ClaimHTLOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ClaimHTLOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ClaimHTLOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.ClaimHTLOrder;

                /**
                 * Creates a plain object from a ClaimHTLOrder message. Also converts values to other types if specified.
                 * @param message ClaimHTLOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.ClaimHTLOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ClaimHTLOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a RefundHTLTOrder. */
            interface IRefundHTLTOrder {

                /** RefundHTLTOrder from */
                from?: (Uint8Array|null);

                /** RefundHTLTOrder swapId */
                swapId?: (Uint8Array|null);
            }

            /** Represents a RefundHTLTOrder. */
            class RefundHTLTOrder implements IRefundHTLTOrder {

                /**
                 * Constructs a new RefundHTLTOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.IRefundHTLTOrder);

                /** RefundHTLTOrder from. */
                public from: Uint8Array;

                /** RefundHTLTOrder swapId. */
                public swapId: Uint8Array;

                /**
                 * Creates a new RefundHTLTOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RefundHTLTOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.IRefundHTLTOrder): TW.Binance.Proto.RefundHTLTOrder;

                /**
                 * Encodes the specified RefundHTLTOrder message. Does not implicitly {@link TW.Binance.Proto.RefundHTLTOrder.verify|verify} messages.
                 * @param message RefundHTLTOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.IRefundHTLTOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RefundHTLTOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RefundHTLTOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.RefundHTLTOrder;

                /**
                 * Verifies a RefundHTLTOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RefundHTLTOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RefundHTLTOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.RefundHTLTOrder;

                /**
                 * Creates a plain object from a RefundHTLTOrder message. Also converts values to other types if specified.
                 * @param message RefundHTLTOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.RefundHTLTOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RefundHTLTOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransferOut. */
            interface ITransferOut {

                /** TransferOut from */
                from?: (Uint8Array|null);

                /** TransferOut to */
                to?: (Uint8Array|null);

                /** TransferOut amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** TransferOut expireTime */
                expireTime?: (Long|null);
            }

            /** Represents a TransferOut. */
            class TransferOut implements ITransferOut {

                /**
                 * Constructs a new TransferOut.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITransferOut);

                /** TransferOut from. */
                public from: Uint8Array;

                /** TransferOut to. */
                public to: Uint8Array;

                /** TransferOut amount. */
                public amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** TransferOut expireTime. */
                public expireTime: Long;

                /**
                 * Creates a new TransferOut instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferOut instance
                 */
                public static create(properties?: TW.Binance.Proto.ITransferOut): TW.Binance.Proto.TransferOut;

                /**
                 * Encodes the specified TransferOut message. Does not implicitly {@link TW.Binance.Proto.TransferOut.verify|verify} messages.
                 * @param message TransferOut message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITransferOut, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferOut message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TransferOut;

                /**
                 * Verifies a TransferOut message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferOut message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferOut
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TransferOut;

                /**
                 * Creates a plain object from a TransferOut message. Also converts values to other types if specified.
                 * @param message TransferOut
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TransferOut, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferOut to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SideChainDelegate. */
            interface ISideChainDelegate {

                /** SideChainDelegate delegatorAddr */
                delegatorAddr?: (Uint8Array|null);

                /** SideChainDelegate validatorAddr */
                validatorAddr?: (Uint8Array|null);

                /** SideChainDelegate delegation */
                delegation?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainDelegate chainId */
                chainId?: (string|null);
            }

            /** Represents a SideChainDelegate. */
            class SideChainDelegate implements ISideChainDelegate {

                /**
                 * Constructs a new SideChainDelegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISideChainDelegate);

                /** SideChainDelegate delegatorAddr. */
                public delegatorAddr: Uint8Array;

                /** SideChainDelegate validatorAddr. */
                public validatorAddr: Uint8Array;

                /** SideChainDelegate delegation. */
                public delegation?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainDelegate chainId. */
                public chainId: string;

                /**
                 * Creates a new SideChainDelegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SideChainDelegate instance
                 */
                public static create(properties?: TW.Binance.Proto.ISideChainDelegate): TW.Binance.Proto.SideChainDelegate;

                /**
                 * Encodes the specified SideChainDelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainDelegate.verify|verify} messages.
                 * @param message SideChainDelegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISideChainDelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SideChainDelegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SideChainDelegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SideChainDelegate;

                /**
                 * Verifies a SideChainDelegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SideChainDelegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SideChainDelegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SideChainDelegate;

                /**
                 * Creates a plain object from a SideChainDelegate message. Also converts values to other types if specified.
                 * @param message SideChainDelegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SideChainDelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SideChainDelegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SideChainRedelegate. */
            interface ISideChainRedelegate {

                /** SideChainRedelegate delegatorAddr */
                delegatorAddr?: (Uint8Array|null);

                /** SideChainRedelegate validatorSrcAddr */
                validatorSrcAddr?: (Uint8Array|null);

                /** SideChainRedelegate validatorDstAddr */
                validatorDstAddr?: (Uint8Array|null);

                /** SideChainRedelegate amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainRedelegate chainId */
                chainId?: (string|null);
            }

            /** Represents a SideChainRedelegate. */
            class SideChainRedelegate implements ISideChainRedelegate {

                /**
                 * Constructs a new SideChainRedelegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISideChainRedelegate);

                /** SideChainRedelegate delegatorAddr. */
                public delegatorAddr: Uint8Array;

                /** SideChainRedelegate validatorSrcAddr. */
                public validatorSrcAddr: Uint8Array;

                /** SideChainRedelegate validatorDstAddr. */
                public validatorDstAddr: Uint8Array;

                /** SideChainRedelegate amount. */
                public amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainRedelegate chainId. */
                public chainId: string;

                /**
                 * Creates a new SideChainRedelegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SideChainRedelegate instance
                 */
                public static create(properties?: TW.Binance.Proto.ISideChainRedelegate): TW.Binance.Proto.SideChainRedelegate;

                /**
                 * Encodes the specified SideChainRedelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainRedelegate.verify|verify} messages.
                 * @param message SideChainRedelegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISideChainRedelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SideChainRedelegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SideChainRedelegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SideChainRedelegate;

                /**
                 * Verifies a SideChainRedelegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SideChainRedelegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SideChainRedelegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SideChainRedelegate;

                /**
                 * Creates a plain object from a SideChainRedelegate message. Also converts values to other types if specified.
                 * @param message SideChainRedelegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SideChainRedelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SideChainRedelegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SideChainUndelegate. */
            interface ISideChainUndelegate {

                /** SideChainUndelegate delegatorAddr */
                delegatorAddr?: (Uint8Array|null);

                /** SideChainUndelegate validatorAddr */
                validatorAddr?: (Uint8Array|null);

                /** SideChainUndelegate amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainUndelegate chainId */
                chainId?: (string|null);
            }

            /** Represents a SideChainUndelegate. */
            class SideChainUndelegate implements ISideChainUndelegate {

                /**
                 * Constructs a new SideChainUndelegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISideChainUndelegate);

                /** SideChainUndelegate delegatorAddr. */
                public delegatorAddr: Uint8Array;

                /** SideChainUndelegate validatorAddr. */
                public validatorAddr: Uint8Array;

                /** SideChainUndelegate amount. */
                public amount?: (TW.Binance.Proto.SendOrder.IToken|null);

                /** SideChainUndelegate chainId. */
                public chainId: string;

                /**
                 * Creates a new SideChainUndelegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SideChainUndelegate instance
                 */
                public static create(properties?: TW.Binance.Proto.ISideChainUndelegate): TW.Binance.Proto.SideChainUndelegate;

                /**
                 * Encodes the specified SideChainUndelegate message. Does not implicitly {@link TW.Binance.Proto.SideChainUndelegate.verify|verify} messages.
                 * @param message SideChainUndelegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISideChainUndelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SideChainUndelegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SideChainUndelegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SideChainUndelegate;

                /**
                 * Verifies a SideChainUndelegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SideChainUndelegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SideChainUndelegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SideChainUndelegate;

                /**
                 * Creates a plain object from a SideChainUndelegate message. Also converts values to other types if specified.
                 * @param message SideChainUndelegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SideChainUndelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SideChainUndelegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TimeLockOrder. */
            interface ITimeLockOrder {

                /** TimeLockOrder fromAddress */
                fromAddress?: (Uint8Array|null);

                /** TimeLockOrder description */
                description?: (string|null);

                /** TimeLockOrder amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken[]|null);

                /** TimeLockOrder lockTime */
                lockTime?: (Long|null);
            }

            /** Represents a TimeLockOrder. */
            class TimeLockOrder implements ITimeLockOrder {

                /**
                 * Constructs a new TimeLockOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITimeLockOrder);

                /** TimeLockOrder fromAddress. */
                public fromAddress: Uint8Array;

                /** TimeLockOrder description. */
                public description: string;

                /** TimeLockOrder amount. */
                public amount: TW.Binance.Proto.SendOrder.IToken[];

                /** TimeLockOrder lockTime. */
                public lockTime: Long;

                /**
                 * Creates a new TimeLockOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TimeLockOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITimeLockOrder): TW.Binance.Proto.TimeLockOrder;

                /**
                 * Encodes the specified TimeLockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeLockOrder.verify|verify} messages.
                 * @param message TimeLockOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITimeLockOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TimeLockOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TimeLockOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TimeLockOrder;

                /**
                 * Verifies a TimeLockOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TimeLockOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TimeLockOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TimeLockOrder;

                /**
                 * Creates a plain object from a TimeLockOrder message. Also converts values to other types if specified.
                 * @param message TimeLockOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TimeLockOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TimeLockOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TimeRelockOrder. */
            interface ITimeRelockOrder {

                /** TimeRelockOrder fromAddress */
                fromAddress?: (Uint8Array|null);

                /** TimeRelockOrder id */
                id?: (Long|null);

                /** TimeRelockOrder description */
                description?: (string|null);

                /** TimeRelockOrder amount */
                amount?: (TW.Binance.Proto.SendOrder.IToken[]|null);

                /** TimeRelockOrder lockTime */
                lockTime?: (Long|null);
            }

            /** Represents a TimeRelockOrder. */
            class TimeRelockOrder implements ITimeRelockOrder {

                /**
                 * Constructs a new TimeRelockOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITimeRelockOrder);

                /** TimeRelockOrder fromAddress. */
                public fromAddress: Uint8Array;

                /** TimeRelockOrder id. */
                public id: Long;

                /** TimeRelockOrder description. */
                public description: string;

                /** TimeRelockOrder amount. */
                public amount: TW.Binance.Proto.SendOrder.IToken[];

                /** TimeRelockOrder lockTime. */
                public lockTime: Long;

                /**
                 * Creates a new TimeRelockOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TimeRelockOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITimeRelockOrder): TW.Binance.Proto.TimeRelockOrder;

                /**
                 * Encodes the specified TimeRelockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeRelockOrder.verify|verify} messages.
                 * @param message TimeRelockOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITimeRelockOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TimeRelockOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TimeRelockOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TimeRelockOrder;

                /**
                 * Verifies a TimeRelockOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TimeRelockOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TimeRelockOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TimeRelockOrder;

                /**
                 * Creates a plain object from a TimeRelockOrder message. Also converts values to other types if specified.
                 * @param message TimeRelockOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TimeRelockOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TimeRelockOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TimeUnlockOrder. */
            interface ITimeUnlockOrder {

                /** TimeUnlockOrder fromAddress */
                fromAddress?: (Uint8Array|null);

                /** TimeUnlockOrder id */
                id?: (Long|null);
            }

            /** Represents a TimeUnlockOrder. */
            class TimeUnlockOrder implements ITimeUnlockOrder {

                /**
                 * Constructs a new TimeUnlockOrder.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ITimeUnlockOrder);

                /** TimeUnlockOrder fromAddress. */
                public fromAddress: Uint8Array;

                /** TimeUnlockOrder id. */
                public id: Long;

                /**
                 * Creates a new TimeUnlockOrder instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TimeUnlockOrder instance
                 */
                public static create(properties?: TW.Binance.Proto.ITimeUnlockOrder): TW.Binance.Proto.TimeUnlockOrder;

                /**
                 * Encodes the specified TimeUnlockOrder message. Does not implicitly {@link TW.Binance.Proto.TimeUnlockOrder.verify|verify} messages.
                 * @param message TimeUnlockOrder message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ITimeUnlockOrder, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TimeUnlockOrder message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TimeUnlockOrder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.TimeUnlockOrder;

                /**
                 * Verifies a TimeUnlockOrder message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TimeUnlockOrder message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TimeUnlockOrder
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.TimeUnlockOrder;

                /**
                 * Creates a plain object from a TimeUnlockOrder message. Also converts values to other types if specified.
                 * @param message TimeUnlockOrder
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.TimeUnlockOrder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TimeUnlockOrder to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput chainId */
                chainId?: (string|null);

                /** SigningInput accountNumber */
                accountNumber?: (Long|null);

                /** SigningInput sequence */
                sequence?: (Long|null);

                /** SigningInput source */
                source?: (Long|null);

                /** SigningInput memo */
                memo?: (string|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput tradeOrder */
                tradeOrder?: (TW.Binance.Proto.ITradeOrder|null);

                /** SigningInput cancelTradeOrder */
                cancelTradeOrder?: (TW.Binance.Proto.ICancelTradeOrder|null);

                /** SigningInput sendOrder */
                sendOrder?: (TW.Binance.Proto.ISendOrder|null);

                /** SigningInput freezeOrder */
                freezeOrder?: (TW.Binance.Proto.ITokenFreezeOrder|null);

                /** SigningInput unfreezeOrder */
                unfreezeOrder?: (TW.Binance.Proto.ITokenUnfreezeOrder|null);

                /** SigningInput htltOrder */
                htltOrder?: (TW.Binance.Proto.IHTLTOrder|null);

                /** SigningInput depositHTLTOrder */
                depositHTLTOrder?: (TW.Binance.Proto.IDepositHTLTOrder|null);

                /** SigningInput claimHTLTOrder */
                claimHTLTOrder?: (TW.Binance.Proto.IClaimHTLOrder|null);

                /** SigningInput refundHTLTOrder */
                refundHTLTOrder?: (TW.Binance.Proto.IRefundHTLTOrder|null);

                /** SigningInput issueOrder */
                issueOrder?: (TW.Binance.Proto.ITokenIssueOrder|null);

                /** SigningInput mintOrder */
                mintOrder?: (TW.Binance.Proto.ITokenMintOrder|null);

                /** SigningInput burnOrder */
                burnOrder?: (TW.Binance.Proto.ITokenBurnOrder|null);

                /** SigningInput transferOutOrder */
                transferOutOrder?: (TW.Binance.Proto.ITransferOut|null);

                /** SigningInput sideDelegateOrder */
                sideDelegateOrder?: (TW.Binance.Proto.ISideChainDelegate|null);

                /** SigningInput sideRedelegateOrder */
                sideRedelegateOrder?: (TW.Binance.Proto.ISideChainRedelegate|null);

                /** SigningInput sideUndelegateOrder */
                sideUndelegateOrder?: (TW.Binance.Proto.ISideChainUndelegate|null);

                /** SigningInput timeLockOrder */
                timeLockOrder?: (TW.Binance.Proto.ITimeLockOrder|null);

                /** SigningInput timeRelockOrder */
                timeRelockOrder?: (TW.Binance.Proto.ITimeRelockOrder|null);

                /** SigningInput timeUnlockOrder */
                timeUnlockOrder?: (TW.Binance.Proto.ITimeUnlockOrder|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISigningInput);

                /** SigningInput chainId. */
                public chainId: string;

                /** SigningInput accountNumber. */
                public accountNumber: Long;

                /** SigningInput sequence. */
                public sequence: Long;

                /** SigningInput source. */
                public source: Long;

                /** SigningInput memo. */
                public memo: string;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput tradeOrder. */
                public tradeOrder?: (TW.Binance.Proto.ITradeOrder|null);

                /** SigningInput cancelTradeOrder. */
                public cancelTradeOrder?: (TW.Binance.Proto.ICancelTradeOrder|null);

                /** SigningInput sendOrder. */
                public sendOrder?: (TW.Binance.Proto.ISendOrder|null);

                /** SigningInput freezeOrder. */
                public freezeOrder?: (TW.Binance.Proto.ITokenFreezeOrder|null);

                /** SigningInput unfreezeOrder. */
                public unfreezeOrder?: (TW.Binance.Proto.ITokenUnfreezeOrder|null);

                /** SigningInput htltOrder. */
                public htltOrder?: (TW.Binance.Proto.IHTLTOrder|null);

                /** SigningInput depositHTLTOrder. */
                public depositHTLTOrder?: (TW.Binance.Proto.IDepositHTLTOrder|null);

                /** SigningInput claimHTLTOrder. */
                public claimHTLTOrder?: (TW.Binance.Proto.IClaimHTLOrder|null);

                /** SigningInput refundHTLTOrder. */
                public refundHTLTOrder?: (TW.Binance.Proto.IRefundHTLTOrder|null);

                /** SigningInput issueOrder. */
                public issueOrder?: (TW.Binance.Proto.ITokenIssueOrder|null);

                /** SigningInput mintOrder. */
                public mintOrder?: (TW.Binance.Proto.ITokenMintOrder|null);

                /** SigningInput burnOrder. */
                public burnOrder?: (TW.Binance.Proto.ITokenBurnOrder|null);

                /** SigningInput transferOutOrder. */
                public transferOutOrder?: (TW.Binance.Proto.ITransferOut|null);

                /** SigningInput sideDelegateOrder. */
                public sideDelegateOrder?: (TW.Binance.Proto.ISideChainDelegate|null);

                /** SigningInput sideRedelegateOrder. */
                public sideRedelegateOrder?: (TW.Binance.Proto.ISideChainRedelegate|null);

                /** SigningInput sideUndelegateOrder. */
                public sideUndelegateOrder?: (TW.Binance.Proto.ISideChainUndelegate|null);

                /** SigningInput timeLockOrder. */
                public timeLockOrder?: (TW.Binance.Proto.ITimeLockOrder|null);

                /** SigningInput timeRelockOrder. */
                public timeRelockOrder?: (TW.Binance.Proto.ITimeRelockOrder|null);

                /** SigningInput timeUnlockOrder. */
                public timeUnlockOrder?: (TW.Binance.Proto.ITimeUnlockOrder|null);

                /** SigningInput orderOneof. */
                public orderOneof?: ("tradeOrder"|"cancelTradeOrder"|"sendOrder"|"freezeOrder"|"unfreezeOrder"|"htltOrder"|"depositHTLTOrder"|"claimHTLTOrder"|"refundHTLTOrder"|"issueOrder"|"mintOrder"|"burnOrder"|"transferOutOrder"|"sideDelegateOrder"|"sideRedelegateOrder"|"sideUndelegateOrder"|"timeLockOrder"|"timeRelockOrder"|"timeUnlockOrder");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Binance.Proto.ISigningInput): TW.Binance.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Binance.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Binance.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Binance.Proto.ISigningOutput): TW.Binance.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Binance.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Binance.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Binance.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Binance.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Binance.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Bitcoin. */
    namespace Bitcoin {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction version */
                version?: (number|null);

                /** Transaction lockTime */
                lockTime?: (number|null);

                /** Transaction inputs */
                inputs?: (TW.Bitcoin.Proto.ITransactionInput[]|null);

                /** Transaction outputs */
                outputs?: (TW.Bitcoin.Proto.ITransactionOutput[]|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ITransaction);

                /** Transaction version. */
                public version: number;

                /** Transaction lockTime. */
                public lockTime: number;

                /** Transaction inputs. */
                public inputs: TW.Bitcoin.Proto.ITransactionInput[];

                /** Transaction outputs. */
                public outputs: TW.Bitcoin.Proto.ITransactionOutput[];

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ITransaction): TW.Bitcoin.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Bitcoin.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionInput. */
            interface ITransactionInput {

                /** TransactionInput previousOutput */
                previousOutput?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** TransactionInput sequence */
                sequence?: (number|null);

                /** TransactionInput script */
                script?: (Uint8Array|null);
            }

            /** Represents a TransactionInput. */
            class TransactionInput implements ITransactionInput {

                /**
                 * Constructs a new TransactionInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ITransactionInput);

                /** TransactionInput previousOutput. */
                public previousOutput?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** TransactionInput sequence. */
                public sequence: number;

                /** TransactionInput script. */
                public script: Uint8Array;

                /**
                 * Creates a new TransactionInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionInput instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ITransactionInput): TW.Bitcoin.Proto.TransactionInput;

                /**
                 * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionInput.verify|verify} messages.
                 * @param message TransactionInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ITransactionInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.TransactionInput;

                /**
                 * Verifies a TransactionInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.TransactionInput;

                /**
                 * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                 * @param message TransactionInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.TransactionInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OutPoint. */
            interface IOutPoint {

                /** OutPoint hash */
                hash?: (Uint8Array|null);

                /** OutPoint index */
                index?: (number|null);

                /** OutPoint sequence */
                sequence?: (number|null);

                /** OutPoint tree */
                tree?: (number|null);
            }

            /** Represents an OutPoint. */
            class OutPoint implements IOutPoint {

                /**
                 * Constructs a new OutPoint.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.IOutPoint);

                /** OutPoint hash. */
                public hash: Uint8Array;

                /** OutPoint index. */
                public index: number;

                /** OutPoint sequence. */
                public sequence: number;

                /** OutPoint tree. */
                public tree: number;

                /**
                 * Creates a new OutPoint instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OutPoint instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.IOutPoint): TW.Bitcoin.Proto.OutPoint;

                /**
                 * Encodes the specified OutPoint message. Does not implicitly {@link TW.Bitcoin.Proto.OutPoint.verify|verify} messages.
                 * @param message OutPoint message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.IOutPoint, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OutPoint message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OutPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.OutPoint;

                /**
                 * Verifies an OutPoint message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OutPoint
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.OutPoint;

                /**
                 * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                 * @param message OutPoint
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.OutPoint, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OutPoint to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOutput. */
            interface ITransactionOutput {

                /** TransactionOutput value */
                value?: (Long|null);

                /** TransactionOutput script */
                script?: (Uint8Array|null);

                /** TransactionOutput spendingScript */
                spendingScript?: (Uint8Array|null);
            }

            /** Represents a TransactionOutput. */
            class TransactionOutput implements ITransactionOutput {

                /**
                 * Constructs a new TransactionOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ITransactionOutput);

                /** TransactionOutput value. */
                public value: Long;

                /** TransactionOutput script. */
                public script: Uint8Array;

                /** TransactionOutput spendingScript. */
                public spendingScript: Uint8Array;

                /**
                 * Creates a new TransactionOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOutput instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ITransactionOutput): TW.Bitcoin.Proto.TransactionOutput;

                /**
                 * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionOutput.verify|verify} messages.
                 * @param message TransactionOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ITransactionOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.TransactionOutput;

                /**
                 * Verifies a TransactionOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.TransactionOutput;

                /**
                 * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                 * @param message TransactionOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.TransactionOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an UnspentTransaction. */
            interface IUnspentTransaction {

                /** UnspentTransaction outPoint */
                outPoint?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** UnspentTransaction script */
                script?: (Uint8Array|null);

                /** UnspentTransaction amount */
                amount?: (Long|null);

                /** UnspentTransaction variant */
                variant?: (TW.Bitcoin.Proto.TransactionVariant|null);

                /** UnspentTransaction spendingScript */
                spendingScript?: (Uint8Array|null);
            }

            /** Represents an UnspentTransaction. */
            class UnspentTransaction implements IUnspentTransaction {

                /**
                 * Constructs a new UnspentTransaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.IUnspentTransaction);

                /** UnspentTransaction outPoint. */
                public outPoint?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** UnspentTransaction script. */
                public script: Uint8Array;

                /** UnspentTransaction amount. */
                public amount: Long;

                /** UnspentTransaction variant. */
                public variant: TW.Bitcoin.Proto.TransactionVariant;

                /** UnspentTransaction spendingScript. */
                public spendingScript: Uint8Array;

                /**
                 * Creates a new UnspentTransaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnspentTransaction instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.IUnspentTransaction): TW.Bitcoin.Proto.UnspentTransaction;

                /**
                 * Encodes the specified UnspentTransaction message. Does not implicitly {@link TW.Bitcoin.Proto.UnspentTransaction.verify|verify} messages.
                 * @param message UnspentTransaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.IUnspentTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnspentTransaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnspentTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.UnspentTransaction;

                /**
                 * Verifies an UnspentTransaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnspentTransaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnspentTransaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.UnspentTransaction;

                /**
                 * Creates a plain object from an UnspentTransaction message. Also converts values to other types if specified.
                 * @param message UnspentTransaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.UnspentTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnspentTransaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** TransactionVariant enum. */
            enum TransactionVariant {
                P2PKH = 0,
                P2WPKH = 1,
                P2TRKEYPATH = 2,
                BRC20TRANSFER = 3,
                NFTINSCRIPTION = 4
            }

            /** Properties of an OutputAddress. */
            interface IOutputAddress {

                /** OutputAddress toAddress */
                toAddress?: (string|null);

                /** OutputAddress amount */
                amount?: (Long|null);
            }

            /** Represents an OutputAddress. */
            class OutputAddress implements IOutputAddress {

                /**
                 * Constructs a new OutputAddress.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.IOutputAddress);

                /** OutputAddress toAddress. */
                public toAddress: string;

                /** OutputAddress amount. */
                public amount: Long;

                /**
                 * Creates a new OutputAddress instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OutputAddress instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.IOutputAddress): TW.Bitcoin.Proto.OutputAddress;

                /**
                 * Encodes the specified OutputAddress message. Does not implicitly {@link TW.Bitcoin.Proto.OutputAddress.verify|verify} messages.
                 * @param message OutputAddress message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.IOutputAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OutputAddress message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OutputAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.OutputAddress;

                /**
                 * Verifies an OutputAddress message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OutputAddress message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OutputAddress
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.OutputAddress;

                /**
                 * Creates a plain object from an OutputAddress message. Also converts values to other types if specified.
                 * @param message OutputAddress
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.OutputAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OutputAddress to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput hashType */
                hashType?: (number|null);

                /** SigningInput amount */
                amount?: (Long|null);

                /** SigningInput byteFee */
                byteFee?: (Long|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput changeAddress */
                changeAddress?: (string|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array[]|null);

                /** SigningInput scripts */
                scripts?: ({ [k: string]: Uint8Array }|null);

                /** SigningInput utxo */
                utxo?: (TW.Bitcoin.Proto.IUnspentTransaction[]|null);

                /** SigningInput useMaxAmount */
                useMaxAmount?: (boolean|null);

                /** SigningInput coinType */
                coinType?: (number|null);

                /** SigningInput plan */
                plan?: (TW.Bitcoin.Proto.ITransactionPlan|null);

                /** SigningInput lockTime */
                lockTime?: (number|null);

                /** SigningInput outputOpReturn */
                outputOpReturn?: (Uint8Array|null);

                /** SigningInput extraOutputs */
                extraOutputs?: (TW.Bitcoin.Proto.IOutputAddress[]|null);

                /** SigningInput useMaxUtxo */
                useMaxUtxo?: (boolean|null);

                /** SigningInput disableDustFilter */
                disableDustFilter?: (boolean|null);

                /** SigningInput time */
                time?: (number|null);

                /** SigningInput isItBrcOperation */
                isItBrcOperation?: (boolean|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ISigningInput);

                /** SigningInput hashType. */
                public hashType: number;

                /** SigningInput amount. */
                public amount: Long;

                /** SigningInput byteFee. */
                public byteFee: Long;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput changeAddress. */
                public changeAddress: string;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array[];

                /** SigningInput scripts. */
                public scripts: { [k: string]: Uint8Array };

                /** SigningInput utxo. */
                public utxo: TW.Bitcoin.Proto.IUnspentTransaction[];

                /** SigningInput useMaxAmount. */
                public useMaxAmount: boolean;

                /** SigningInput coinType. */
                public coinType: number;

                /** SigningInput plan. */
                public plan?: (TW.Bitcoin.Proto.ITransactionPlan|null);

                /** SigningInput lockTime. */
                public lockTime: number;

                /** SigningInput outputOpReturn. */
                public outputOpReturn: Uint8Array;

                /** SigningInput extraOutputs. */
                public extraOutputs: TW.Bitcoin.Proto.IOutputAddress[];

                /** SigningInput useMaxUtxo. */
                public useMaxUtxo: boolean;

                /** SigningInput disableDustFilter. */
                public disableDustFilter: boolean;

                /** SigningInput time. */
                public time: number;

                /** SigningInput isItBrcOperation. */
                public isItBrcOperation: boolean;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ISigningInput): TW.Bitcoin.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionPlan. */
            interface ITransactionPlan {

                /** TransactionPlan amount */
                amount?: (Long|null);

                /** TransactionPlan availableAmount */
                availableAmount?: (Long|null);

                /** TransactionPlan fee */
                fee?: (Long|null);

                /** TransactionPlan change */
                change?: (Long|null);

                /** TransactionPlan utxos */
                utxos?: (TW.Bitcoin.Proto.IUnspentTransaction[]|null);

                /** TransactionPlan branchId */
                branchId?: (Uint8Array|null);

                /** TransactionPlan error */
                error?: (TW.Common.Proto.SigningError|null);

                /** TransactionPlan outputOpReturn */
                outputOpReturn?: (Uint8Array|null);

                /** TransactionPlan preblockhash */
                preblockhash?: (Uint8Array|null);

                /** TransactionPlan preblockheight */
                preblockheight?: (Long|null);
            }

            /** Represents a TransactionPlan. */
            class TransactionPlan implements ITransactionPlan {

                /**
                 * Constructs a new TransactionPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ITransactionPlan);

                /** TransactionPlan amount. */
                public amount: Long;

                /** TransactionPlan availableAmount. */
                public availableAmount: Long;

                /** TransactionPlan fee. */
                public fee: Long;

                /** TransactionPlan change. */
                public change: Long;

                /** TransactionPlan utxos. */
                public utxos: TW.Bitcoin.Proto.IUnspentTransaction[];

                /** TransactionPlan branchId. */
                public branchId: Uint8Array;

                /** TransactionPlan error. */
                public error: TW.Common.Proto.SigningError;

                /** TransactionPlan outputOpReturn. */
                public outputOpReturn: Uint8Array;

                /** TransactionPlan preblockhash. */
                public preblockhash: Uint8Array;

                /** TransactionPlan preblockheight. */
                public preblockheight: Long;

                /**
                 * Creates a new TransactionPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionPlan instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ITransactionPlan): TW.Bitcoin.Proto.TransactionPlan;

                /**
                 * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionPlan.verify|verify} messages.
                 * @param message TransactionPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ITransactionPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.TransactionPlan;

                /**
                 * Verifies a TransactionPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.TransactionPlan;

                /**
                 * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                 * @param message TransactionPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.TransactionPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput transaction */
                transaction?: (TW.Bitcoin.Proto.ITransaction|null);

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput transactionId */
                transactionId?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.ISigningOutput);

                /** SigningOutput transaction. */
                public transaction?: (TW.Bitcoin.Proto.ITransaction|null);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput transactionId. */
                public transactionId: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.ISigningOutput): TW.Bitcoin.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a HashPublicKey. */
            interface IHashPublicKey {

                /** Pre-image data hash that will be used for signing */
                dataHash?: (Uint8Array|null);

                /** public key hash used for signing */
                publicKeyHash?: (Uint8Array|null);
            }

            /** Pre-image hash to be used for signing */
            class HashPublicKey implements IHashPublicKey {

                /**
                 * Constructs a new HashPublicKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.IHashPublicKey);

                /** Pre-image data hash that will be used for signing */
                public dataHash: Uint8Array;

                /** public key hash used for signing */
                public publicKeyHash: Uint8Array;

                /**
                 * Creates a new HashPublicKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns HashPublicKey instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.IHashPublicKey): TW.Bitcoin.Proto.HashPublicKey;

                /**
                 * Encodes the specified HashPublicKey message. Does not implicitly {@link TW.Bitcoin.Proto.HashPublicKey.verify|verify} messages.
                 * @param message HashPublicKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.IHashPublicKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HashPublicKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns HashPublicKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.HashPublicKey;

                /**
                 * Verifies a HashPublicKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a HashPublicKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns HashPublicKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.HashPublicKey;

                /**
                 * Creates a plain object from a HashPublicKey message. Also converts values to other types if specified.
                 * @param message HashPublicKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.HashPublicKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this HashPublicKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a PreSigningOutput. */
            interface IPreSigningOutput {

                /** hash, public key list */
                hashPublicKeys?: (TW.Bitcoin.Proto.IHashPublicKey[]|null);

                /** error code, 0 is ok, other codes will be treated as errors */
                error?: (TW.Common.Proto.SigningError|null);

                /** error description */
                errorMessage?: (string|null);
            }

            /** Transaction pre-signing output */
            class PreSigningOutput implements IPreSigningOutput {

                /**
                 * Constructs a new PreSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Bitcoin.Proto.IPreSigningOutput);

                /** hash, public key list */
                public hashPublicKeys: TW.Bitcoin.Proto.IHashPublicKey[];

                /** error code, 0 is ok, other codes will be treated as errors */
                public error: TW.Common.Proto.SigningError;

                /** error description */
                public errorMessage: string;

                /**
                 * Creates a new PreSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSigningOutput instance
                 */
                public static create(properties?: TW.Bitcoin.Proto.IPreSigningOutput): TW.Bitcoin.Proto.PreSigningOutput;

                /**
                 * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.Bitcoin.Proto.PreSigningOutput.verify|verify} messages.
                 * @param message PreSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Bitcoin.Proto.IPreSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Bitcoin.Proto.PreSigningOutput;

                /**
                 * Verifies a PreSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Bitcoin.Proto.PreSigningOutput;

                /**
                 * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                 * @param message PreSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Bitcoin.Proto.PreSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace BitcoinV2. */
    namespace BitcoinV2 {

        /** Namespace Proto. */
        namespace Proto {

            /** Error enum. */
            enum Error {
                OK = 0,
                Error_utxo_invalid_leaf_hash = 2,
                Error_utxo_invalid_sighash_type = 3,
                Error_utxo_invalid_lock_time = 4,
                Error_utxo_invalid_txid = 5,
                Error_utxo_sighash_failed = 6,
                Error_utxo_missing_sighash_method = 7,
                Error_utxo_failed_encoding = 8,
                Error_utxo_insufficient_inputs = 9,
                Error_utxo_missing_change_script_pubkey = 10,
                Error_zero_sequence_not_enabled = 11,
                Error_unmatched_input_signature_count = 12,
                Error_missing_input_builder = 13,
                Error_missing_output_builder = 14,
                Error_missing_recipient = 15,
                Error_missing_inscription = 41,
                Error_missing_tagged_output = 42,
                Error_legacy_p2tr_invalid_variant = 16,
                Error_legacy_no_spending_script_provided = 17,
                Error_legacy_expected_redeem_script = 18,
                Error_legacy_outpoint_not_set = 19,
                Error_legacy_no_private_key = 36,
                Error_legacy_no_plan_provided = 37,
                Error_invalid_private_key = 20,
                Error_invalid_public_key = 21,
                Error_invalid_sighash = 22,
                Error_invalid_witness_pubkey_hash = 23,
                Error_invalid_brc20_ticker = 24,
                Error_invalid_ecdsa_signature = 25,
                Error_invalid_schnorr_signature = 26,
                Error_invalid_control_block = 27,
                Error_invalid_pubkey_hash = 28,
                Error_invalid_taproot_root = 29,
                Error_invalid_redeem_script = 30,
                Error_invalid_wpkh_script_code = 1,
                Error_invalid_witness_redeem_script_hash = 31,
                Error_invalid_witness_encoding = 39,
                Error_invalid_taproot_tweaked_pubkey = 32,
                Error_invalid_change_output = 33,
                Error_unsupported_address_recipient = 34,
                Error_bad_address_recipient = 35,
                Error_ordinal_mime_type_too_large = 38,
                Error_ordinal_payload_too_large = 40
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput version */
                version?: (number|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput lockTime */
                lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** SigningInput inputs */
                inputs?: (TW.BitcoinV2.Proto.IInput[]|null);

                /** SigningInput outputs */
                outputs?: (TW.BitcoinV2.Proto.IOutput[]|null);

                /** SigningInput inputSelector */
                inputSelector?: (TW.Utxo.Proto.InputSelector|null);

                /** SigningInput feePerVb */
                feePerVb?: (Long|null);

                /** SigningInput changeOutput */
                changeOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                /** SigningInput disableChangeOutput */
                disableChangeOutput?: (boolean|null);

                /** SigningInput dangerousUseFixedSchnorrRng */
                dangerousUseFixedSchnorrRng?: (boolean|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ISigningInput);

                /** SigningInput version. */
                public version: number;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput lockTime. */
                public lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** SigningInput inputs. */
                public inputs: TW.BitcoinV2.Proto.IInput[];

                /** SigningInput outputs. */
                public outputs: TW.BitcoinV2.Proto.IOutput[];

                /** SigningInput inputSelector. */
                public inputSelector: TW.Utxo.Proto.InputSelector;

                /** SigningInput feePerVb. */
                public feePerVb: Long;

                /** SigningInput changeOutput. */
                public changeOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                /** SigningInput disableChangeOutput. */
                public disableChangeOutput: boolean;

                /** SigningInput dangerousUseFixedSchnorrRng. */
                public dangerousUseFixedSchnorrRng: boolean;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ISigningInput): TW.BitcoinV2.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.BitcoinV2.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Input. */
            interface IInput {

                /** Input privateKey */
                privateKey?: (Uint8Array|null);

                /** Input txid */
                txid?: (Uint8Array|null);

                /** Input vout */
                vout?: (number|null);

                /** Input sequence */
                sequence?: (number|null);

                /** Input sequenceEnableZero */
                sequenceEnableZero?: (boolean|null);

                /** Input value */
                value?: (Long|null);

                /** Input sighashType */
                sighashType?: (TW.Utxo.Proto.SighashType|null);

                /** Input builder */
                builder?: (TW.BitcoinV2.Proto.Input.IInputBuilder|null);

                /** Input customScript */
                customScript?: (TW.BitcoinV2.Proto.Input.IInputScriptWitness|null);
            }

            /** Represents an Input. */
            class Input implements IInput {

                /**
                 * Constructs a new Input.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.IInput);

                /** Input privateKey. */
                public privateKey: Uint8Array;

                /** Input txid. */
                public txid: Uint8Array;

                /** Input vout. */
                public vout: number;

                /** Input sequence. */
                public sequence: number;

                /** Input sequenceEnableZero. */
                public sequenceEnableZero: boolean;

                /** Input value. */
                public value: Long;

                /** Input sighashType. */
                public sighashType: TW.Utxo.Proto.SighashType;

                /** Input builder. */
                public builder?: (TW.BitcoinV2.Proto.Input.IInputBuilder|null);

                /** Input customScript. */
                public customScript?: (TW.BitcoinV2.Proto.Input.IInputScriptWitness|null);

                /** Input toRecipient. */
                public toRecipient?: ("builder"|"customScript");

                /**
                 * Creates a new Input instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Input instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.IInput): TW.BitcoinV2.Proto.Input;

                /**
                 * Encodes the specified Input message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.verify|verify} messages.
                 * @param message Input message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.IInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Input message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Input
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input;

                /**
                 * Verifies an Input message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Input message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Input
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input;

                /**
                 * Creates a plain object from an Input message. Also converts values to other types if specified.
                 * @param message Input
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.Input, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Input to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Input {

                /** Properties of an InputBuilder. */
                interface IInputBuilder {

                    /** InputBuilder p2sh */
                    p2sh?: (Uint8Array|null);

                    /** InputBuilder p2pkh */
                    p2pkh?: (Uint8Array|null);

                    /** InputBuilder p2wsh */
                    p2wsh?: (Uint8Array|null);

                    /** InputBuilder p2wpkh */
                    p2wpkh?: (Uint8Array|null);

                    /** InputBuilder p2trKeyPath */
                    p2trKeyPath?: (TW.BitcoinV2.Proto.Input.IInputTaprootKeyPath|null);

                    /** InputBuilder p2trScriptPath */
                    p2trScriptPath?: (TW.BitcoinV2.Proto.Input.IInputTaprootScriptPath|null);

                    /** InputBuilder brc20Inscribe */
                    brc20Inscribe?: (TW.BitcoinV2.Proto.Input.IInputBrc20Inscription|null);

                    /** InputBuilder ordinalInscribe */
                    ordinalInscribe?: (TW.BitcoinV2.Proto.Input.IInputOrdinalInscription|null);
                }

                /** Represents an InputBuilder. */
                class InputBuilder implements IInputBuilder {

                    /**
                     * Constructs a new InputBuilder.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputBuilder);

                    /** InputBuilder p2sh. */
                    public p2sh?: (Uint8Array|null);

                    /** InputBuilder p2pkh. */
                    public p2pkh?: (Uint8Array|null);

                    /** InputBuilder p2wsh. */
                    public p2wsh?: (Uint8Array|null);

                    /** InputBuilder p2wpkh. */
                    public p2wpkh?: (Uint8Array|null);

                    /** InputBuilder p2trKeyPath. */
                    public p2trKeyPath?: (TW.BitcoinV2.Proto.Input.IInputTaprootKeyPath|null);

                    /** InputBuilder p2trScriptPath. */
                    public p2trScriptPath?: (TW.BitcoinV2.Proto.Input.IInputTaprootScriptPath|null);

                    /** InputBuilder brc20Inscribe. */
                    public brc20Inscribe?: (TW.BitcoinV2.Proto.Input.IInputBrc20Inscription|null);

                    /** InputBuilder ordinalInscribe. */
                    public ordinalInscribe?: (TW.BitcoinV2.Proto.Input.IInputOrdinalInscription|null);

                    /** InputBuilder variant. */
                    public variant?: ("p2sh"|"p2pkh"|"p2wsh"|"p2wpkh"|"p2trKeyPath"|"p2trScriptPath"|"brc20Inscribe"|"ordinalInscribe");

                    /**
                     * Creates a new InputBuilder instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputBuilder instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputBuilder): TW.BitcoinV2.Proto.Input.InputBuilder;

                    /**
                     * Encodes the specified InputBuilder message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputBuilder.verify|verify} messages.
                     * @param message InputBuilder message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputBuilder, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputBuilder message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputBuilder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputBuilder;

                    /**
                     * Verifies an InputBuilder message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputBuilder message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputBuilder
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputBuilder;

                    /**
                     * Creates a plain object from an InputBuilder message. Also converts values to other types if specified.
                     * @param message InputBuilder
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputBuilder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputBuilder to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InputScriptWitness. */
                interface IInputScriptWitness {

                    /** InputScriptWitness scriptPubkey */
                    scriptPubkey?: (Uint8Array|null);

                    /** InputScriptWitness scriptSig */
                    scriptSig?: (Uint8Array|null);

                    /** InputScriptWitness witnessItems */
                    witnessItems?: (Uint8Array[]|null);

                    /** InputScriptWitness signingMethod */
                    signingMethod?: (TW.Utxo.Proto.SigningMethod|null);
                }

                /** Represents an InputScriptWitness. */
                class InputScriptWitness implements IInputScriptWitness {

                    /**
                     * Constructs a new InputScriptWitness.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputScriptWitness);

                    /** InputScriptWitness scriptPubkey. */
                    public scriptPubkey: Uint8Array;

                    /** InputScriptWitness scriptSig. */
                    public scriptSig: Uint8Array;

                    /** InputScriptWitness witnessItems. */
                    public witnessItems: Uint8Array[];

                    /** InputScriptWitness signingMethod. */
                    public signingMethod: TW.Utxo.Proto.SigningMethod;

                    /**
                     * Creates a new InputScriptWitness instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputScriptWitness instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputScriptWitness): TW.BitcoinV2.Proto.Input.InputScriptWitness;

                    /**
                     * Encodes the specified InputScriptWitness message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputScriptWitness.verify|verify} messages.
                     * @param message InputScriptWitness message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputScriptWitness, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputScriptWitness message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputScriptWitness
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputScriptWitness;

                    /**
                     * Verifies an InputScriptWitness message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputScriptWitness message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputScriptWitness
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputScriptWitness;

                    /**
                     * Creates a plain object from an InputScriptWitness message. Also converts values to other types if specified.
                     * @param message InputScriptWitness
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputScriptWitness, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputScriptWitness to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InputTaprootKeyPath. */
                interface IInputTaprootKeyPath {

                    /** InputTaprootKeyPath onePrevout */
                    onePrevout?: (boolean|null);

                    /** InputTaprootKeyPath publicKey */
                    publicKey?: (Uint8Array|null);
                }

                /** Represents an InputTaprootKeyPath. */
                class InputTaprootKeyPath implements IInputTaprootKeyPath {

                    /**
                     * Constructs a new InputTaprootKeyPath.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputTaprootKeyPath);

                    /** InputTaprootKeyPath onePrevout. */
                    public onePrevout: boolean;

                    /** InputTaprootKeyPath publicKey. */
                    public publicKey: Uint8Array;

                    /**
                     * Creates a new InputTaprootKeyPath instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputTaprootKeyPath instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputTaprootKeyPath): TW.BitcoinV2.Proto.Input.InputTaprootKeyPath;

                    /**
                     * Encodes the specified InputTaprootKeyPath message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputTaprootKeyPath.verify|verify} messages.
                     * @param message InputTaprootKeyPath message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputTaprootKeyPath, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputTaprootKeyPath message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputTaprootKeyPath
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputTaprootKeyPath;

                    /**
                     * Verifies an InputTaprootKeyPath message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputTaprootKeyPath message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputTaprootKeyPath
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputTaprootKeyPath;

                    /**
                     * Creates a plain object from an InputTaprootKeyPath message. Also converts values to other types if specified.
                     * @param message InputTaprootKeyPath
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputTaprootKeyPath, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputTaprootKeyPath to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InputTaprootScriptPath. */
                interface IInputTaprootScriptPath {

                    /** InputTaprootScriptPath onePrevout */
                    onePrevout?: (boolean|null);

                    /** InputTaprootScriptPath payload */
                    payload?: (Uint8Array|null);

                    /** InputTaprootScriptPath controlBlock */
                    controlBlock?: (Uint8Array|null);
                }

                /** Represents an InputTaprootScriptPath. */
                class InputTaprootScriptPath implements IInputTaprootScriptPath {

                    /**
                     * Constructs a new InputTaprootScriptPath.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputTaprootScriptPath);

                    /** InputTaprootScriptPath onePrevout. */
                    public onePrevout: boolean;

                    /** InputTaprootScriptPath payload. */
                    public payload: Uint8Array;

                    /** InputTaprootScriptPath controlBlock. */
                    public controlBlock: Uint8Array;

                    /**
                     * Creates a new InputTaprootScriptPath instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputTaprootScriptPath instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputTaprootScriptPath): TW.BitcoinV2.Proto.Input.InputTaprootScriptPath;

                    /**
                     * Encodes the specified InputTaprootScriptPath message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputTaprootScriptPath.verify|verify} messages.
                     * @param message InputTaprootScriptPath message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputTaprootScriptPath, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputTaprootScriptPath message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputTaprootScriptPath
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputTaprootScriptPath;

                    /**
                     * Verifies an InputTaprootScriptPath message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputTaprootScriptPath message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputTaprootScriptPath
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputTaprootScriptPath;

                    /**
                     * Creates a plain object from an InputTaprootScriptPath message. Also converts values to other types if specified.
                     * @param message InputTaprootScriptPath
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputTaprootScriptPath, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputTaprootScriptPath to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InputOrdinalInscription. */
                interface IInputOrdinalInscription {

                    /** InputOrdinalInscription onePrevout */
                    onePrevout?: (boolean|null);

                    /** InputOrdinalInscription inscribeTo */
                    inscribeTo?: (Uint8Array|null);

                    /** InputOrdinalInscription mimeType */
                    mimeType?: (string|null);

                    /** InputOrdinalInscription payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents an InputOrdinalInscription. */
                class InputOrdinalInscription implements IInputOrdinalInscription {

                    /**
                     * Constructs a new InputOrdinalInscription.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputOrdinalInscription);

                    /** InputOrdinalInscription onePrevout. */
                    public onePrevout: boolean;

                    /** InputOrdinalInscription inscribeTo. */
                    public inscribeTo: Uint8Array;

                    /** InputOrdinalInscription mimeType. */
                    public mimeType: string;

                    /** InputOrdinalInscription payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new InputOrdinalInscription instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputOrdinalInscription instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputOrdinalInscription): TW.BitcoinV2.Proto.Input.InputOrdinalInscription;

                    /**
                     * Encodes the specified InputOrdinalInscription message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputOrdinalInscription.verify|verify} messages.
                     * @param message InputOrdinalInscription message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputOrdinalInscription, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputOrdinalInscription message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputOrdinalInscription
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputOrdinalInscription;

                    /**
                     * Verifies an InputOrdinalInscription message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputOrdinalInscription message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputOrdinalInscription
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputOrdinalInscription;

                    /**
                     * Creates a plain object from an InputOrdinalInscription message. Also converts values to other types if specified.
                     * @param message InputOrdinalInscription
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputOrdinalInscription, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputOrdinalInscription to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InputBrc20Inscription. */
                interface IInputBrc20Inscription {

                    /** InputBrc20Inscription onePrevout */
                    onePrevout?: (boolean|null);

                    /** InputBrc20Inscription inscribeTo */
                    inscribeTo?: (Uint8Array|null);

                    /** InputBrc20Inscription ticker */
                    ticker?: (string|null);

                    /** InputBrc20Inscription transferAmount */
                    transferAmount?: (Long|null);
                }

                /** Represents an InputBrc20Inscription. */
                class InputBrc20Inscription implements IInputBrc20Inscription {

                    /**
                     * Constructs a new InputBrc20Inscription.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Input.IInputBrc20Inscription);

                    /** InputBrc20Inscription onePrevout. */
                    public onePrevout: boolean;

                    /** InputBrc20Inscription inscribeTo. */
                    public inscribeTo: Uint8Array;

                    /** InputBrc20Inscription ticker. */
                    public ticker: string;

                    /** InputBrc20Inscription transferAmount. */
                    public transferAmount: Long;

                    /**
                     * Creates a new InputBrc20Inscription instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InputBrc20Inscription instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Input.IInputBrc20Inscription): TW.BitcoinV2.Proto.Input.InputBrc20Inscription;

                    /**
                     * Encodes the specified InputBrc20Inscription message. Does not implicitly {@link TW.BitcoinV2.Proto.Input.InputBrc20Inscription.verify|verify} messages.
                     * @param message InputBrc20Inscription message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Input.IInputBrc20Inscription, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InputBrc20Inscription message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InputBrc20Inscription
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Input.InputBrc20Inscription;

                    /**
                     * Verifies an InputBrc20Inscription message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InputBrc20Inscription message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InputBrc20Inscription
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Input.InputBrc20Inscription;

                    /**
                     * Creates a plain object from an InputBrc20Inscription message. Also converts values to other types if specified.
                     * @param message InputBrc20Inscription
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Input.InputBrc20Inscription, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InputBrc20Inscription to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of an Output. */
            interface IOutput {

                /** Output value */
                value?: (Long|null);

                /** Output builder */
                builder?: (TW.BitcoinV2.Proto.Output.IOutputBuilder|null);

                /** Output customScriptPubkey */
                customScriptPubkey?: (Uint8Array|null);

                /** Output fromAddress */
                fromAddress?: (string|null);
            }

            /** Represents an Output. */
            class Output implements IOutput {

                /**
                 * Constructs a new Output.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.IOutput);

                /** Output value. */
                public value: Long;

                /** Output builder. */
                public builder?: (TW.BitcoinV2.Proto.Output.IOutputBuilder|null);

                /** Output customScriptPubkey. */
                public customScriptPubkey?: (Uint8Array|null);

                /** Output fromAddress. */
                public fromAddress?: (string|null);

                /** Output toRecipient. */
                public toRecipient?: ("builder"|"customScriptPubkey"|"fromAddress");

                /**
                 * Creates a new Output instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Output instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.IOutput): TW.BitcoinV2.Proto.Output;

                /**
                 * Encodes the specified Output message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.verify|verify} messages.
                 * @param message Output message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.IOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Output message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Output
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output;

                /**
                 * Verifies an Output message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Output message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Output
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output;

                /**
                 * Creates a plain object from an Output message. Also converts values to other types if specified.
                 * @param message Output
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.Output, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Output to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Output {

                /** Properties of an OutputBuilder. */
                interface IOutputBuilder {

                    /** OutputBuilder p2sh */
                    p2sh?: (TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash|null);

                    /** OutputBuilder p2pkh */
                    p2pkh?: (TW.BitcoinV2.Proto.IToPublicKeyOrHash|null);

                    /** OutputBuilder p2wsh */
                    p2wsh?: (TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash|null);

                    /** OutputBuilder p2wpkh */
                    p2wpkh?: (TW.BitcoinV2.Proto.IToPublicKeyOrHash|null);

                    /** OutputBuilder p2trKeyPath */
                    p2trKeyPath?: (Uint8Array|null);

                    /** OutputBuilder p2trScriptPath */
                    p2trScriptPath?: (TW.BitcoinV2.Proto.Output.IOutputTaprootScriptPath|null);

                    /** OutputBuilder p2trDangerousAssumeTweaked */
                    p2trDangerousAssumeTweaked?: (Uint8Array|null);

                    /** OutputBuilder brc20Inscribe */
                    brc20Inscribe?: (TW.BitcoinV2.Proto.Output.IOutputBrc20Inscription|null);

                    /** OutputBuilder ordinalInscribe */
                    ordinalInscribe?: (TW.BitcoinV2.Proto.Output.IOutputOrdinalInscription|null);
                }

                /** Represents an OutputBuilder. */
                class OutputBuilder implements IOutputBuilder {

                    /**
                     * Constructs a new OutputBuilder.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Output.IOutputBuilder);

                    /** OutputBuilder p2sh. */
                    public p2sh?: (TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash|null);

                    /** OutputBuilder p2pkh. */
                    public p2pkh?: (TW.BitcoinV2.Proto.IToPublicKeyOrHash|null);

                    /** OutputBuilder p2wsh. */
                    public p2wsh?: (TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash|null);

                    /** OutputBuilder p2wpkh. */
                    public p2wpkh?: (TW.BitcoinV2.Proto.IToPublicKeyOrHash|null);

                    /** OutputBuilder p2trKeyPath. */
                    public p2trKeyPath?: (Uint8Array|null);

                    /** OutputBuilder p2trScriptPath. */
                    public p2trScriptPath?: (TW.BitcoinV2.Proto.Output.IOutputTaprootScriptPath|null);

                    /** OutputBuilder p2trDangerousAssumeTweaked. */
                    public p2trDangerousAssumeTweaked?: (Uint8Array|null);

                    /** OutputBuilder brc20Inscribe. */
                    public brc20Inscribe?: (TW.BitcoinV2.Proto.Output.IOutputBrc20Inscription|null);

                    /** OutputBuilder ordinalInscribe. */
                    public ordinalInscribe?: (TW.BitcoinV2.Proto.Output.IOutputOrdinalInscription|null);

                    /** OutputBuilder variant. */
                    public variant?: ("p2sh"|"p2pkh"|"p2wsh"|"p2wpkh"|"p2trKeyPath"|"p2trScriptPath"|"p2trDangerousAssumeTweaked"|"brc20Inscribe"|"ordinalInscribe");

                    /**
                     * Creates a new OutputBuilder instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns OutputBuilder instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Output.IOutputBuilder): TW.BitcoinV2.Proto.Output.OutputBuilder;

                    /**
                     * Encodes the specified OutputBuilder message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.OutputBuilder.verify|verify} messages.
                     * @param message OutputBuilder message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Output.IOutputBuilder, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an OutputBuilder message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns OutputBuilder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output.OutputBuilder;

                    /**
                     * Verifies an OutputBuilder message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an OutputBuilder message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns OutputBuilder
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output.OutputBuilder;

                    /**
                     * Creates a plain object from an OutputBuilder message. Also converts values to other types if specified.
                     * @param message OutputBuilder
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Output.OutputBuilder, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this OutputBuilder to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an OutputRedeemScriptOrHash. */
                interface IOutputRedeemScriptOrHash {

                    /** OutputRedeemScriptOrHash redeemScript */
                    redeemScript?: (Uint8Array|null);

                    /** OutputRedeemScriptOrHash hash */
                    hash?: (Uint8Array|null);
                }

                /** Represents an OutputRedeemScriptOrHash. */
                class OutputRedeemScriptOrHash implements IOutputRedeemScriptOrHash {

                    /**
                     * Constructs a new OutputRedeemScriptOrHash.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash);

                    /** OutputRedeemScriptOrHash redeemScript. */
                    public redeemScript?: (Uint8Array|null);

                    /** OutputRedeemScriptOrHash hash. */
                    public hash?: (Uint8Array|null);

                    /** OutputRedeemScriptOrHash variant. */
                    public variant?: ("redeemScript"|"hash");

                    /**
                     * Creates a new OutputRedeemScriptOrHash instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns OutputRedeemScriptOrHash instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash): TW.BitcoinV2.Proto.Output.OutputRedeemScriptOrHash;

                    /**
                     * Encodes the specified OutputRedeemScriptOrHash message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.OutputRedeemScriptOrHash.verify|verify} messages.
                     * @param message OutputRedeemScriptOrHash message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Output.IOutputRedeemScriptOrHash, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an OutputRedeemScriptOrHash message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns OutputRedeemScriptOrHash
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output.OutputRedeemScriptOrHash;

                    /**
                     * Verifies an OutputRedeemScriptOrHash message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an OutputRedeemScriptOrHash message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns OutputRedeemScriptOrHash
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output.OutputRedeemScriptOrHash;

                    /**
                     * Creates a plain object from an OutputRedeemScriptOrHash message. Also converts values to other types if specified.
                     * @param message OutputRedeemScriptOrHash
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Output.OutputRedeemScriptOrHash, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this OutputRedeemScriptOrHash to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an OutputTaprootScriptPath. */
                interface IOutputTaprootScriptPath {

                    /** OutputTaprootScriptPath internalKey */
                    internalKey?: (Uint8Array|null);

                    /** OutputTaprootScriptPath merkleRoot */
                    merkleRoot?: (Uint8Array|null);
                }

                /** Represents an OutputTaprootScriptPath. */
                class OutputTaprootScriptPath implements IOutputTaprootScriptPath {

                    /**
                     * Constructs a new OutputTaprootScriptPath.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Output.IOutputTaprootScriptPath);

                    /** OutputTaprootScriptPath internalKey. */
                    public internalKey: Uint8Array;

                    /** OutputTaprootScriptPath merkleRoot. */
                    public merkleRoot: Uint8Array;

                    /**
                     * Creates a new OutputTaprootScriptPath instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns OutputTaprootScriptPath instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Output.IOutputTaprootScriptPath): TW.BitcoinV2.Proto.Output.OutputTaprootScriptPath;

                    /**
                     * Encodes the specified OutputTaprootScriptPath message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.OutputTaprootScriptPath.verify|verify} messages.
                     * @param message OutputTaprootScriptPath message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Output.IOutputTaprootScriptPath, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an OutputTaprootScriptPath message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns OutputTaprootScriptPath
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output.OutputTaprootScriptPath;

                    /**
                     * Verifies an OutputTaprootScriptPath message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an OutputTaprootScriptPath message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns OutputTaprootScriptPath
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output.OutputTaprootScriptPath;

                    /**
                     * Creates a plain object from an OutputTaprootScriptPath message. Also converts values to other types if specified.
                     * @param message OutputTaprootScriptPath
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Output.OutputTaprootScriptPath, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this OutputTaprootScriptPath to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an OutputOrdinalInscription. */
                interface IOutputOrdinalInscription {

                    /** OutputOrdinalInscription inscribeTo */
                    inscribeTo?: (Uint8Array|null);

                    /** OutputOrdinalInscription mimeType */
                    mimeType?: (string|null);

                    /** OutputOrdinalInscription payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents an OutputOrdinalInscription. */
                class OutputOrdinalInscription implements IOutputOrdinalInscription {

                    /**
                     * Constructs a new OutputOrdinalInscription.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Output.IOutputOrdinalInscription);

                    /** OutputOrdinalInscription inscribeTo. */
                    public inscribeTo: Uint8Array;

                    /** OutputOrdinalInscription mimeType. */
                    public mimeType: string;

                    /** OutputOrdinalInscription payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new OutputOrdinalInscription instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns OutputOrdinalInscription instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Output.IOutputOrdinalInscription): TW.BitcoinV2.Proto.Output.OutputOrdinalInscription;

                    /**
                     * Encodes the specified OutputOrdinalInscription message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.OutputOrdinalInscription.verify|verify} messages.
                     * @param message OutputOrdinalInscription message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Output.IOutputOrdinalInscription, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an OutputOrdinalInscription message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns OutputOrdinalInscription
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output.OutputOrdinalInscription;

                    /**
                     * Verifies an OutputOrdinalInscription message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an OutputOrdinalInscription message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns OutputOrdinalInscription
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output.OutputOrdinalInscription;

                    /**
                     * Creates a plain object from an OutputOrdinalInscription message. Also converts values to other types if specified.
                     * @param message OutputOrdinalInscription
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Output.OutputOrdinalInscription, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this OutputOrdinalInscription to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an OutputBrc20Inscription. */
                interface IOutputBrc20Inscription {

                    /** OutputBrc20Inscription inscribeTo */
                    inscribeTo?: (Uint8Array|null);

                    /** OutputBrc20Inscription ticker */
                    ticker?: (string|null);

                    /** OutputBrc20Inscription transferAmount */
                    transferAmount?: (Long|null);
                }

                /** Represents an OutputBrc20Inscription. */
                class OutputBrc20Inscription implements IOutputBrc20Inscription {

                    /**
                     * Constructs a new OutputBrc20Inscription.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.Output.IOutputBrc20Inscription);

                    /** OutputBrc20Inscription inscribeTo. */
                    public inscribeTo: Uint8Array;

                    /** OutputBrc20Inscription ticker. */
                    public ticker: string;

                    /** OutputBrc20Inscription transferAmount. */
                    public transferAmount: Long;

                    /**
                     * Creates a new OutputBrc20Inscription instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns OutputBrc20Inscription instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.Output.IOutputBrc20Inscription): TW.BitcoinV2.Proto.Output.OutputBrc20Inscription;

                    /**
                     * Encodes the specified OutputBrc20Inscription message. Does not implicitly {@link TW.BitcoinV2.Proto.Output.OutputBrc20Inscription.verify|verify} messages.
                     * @param message OutputBrc20Inscription message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.Output.IOutputBrc20Inscription, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an OutputBrc20Inscription message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns OutputBrc20Inscription
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Output.OutputBrc20Inscription;

                    /**
                     * Verifies an OutputBrc20Inscription message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an OutputBrc20Inscription message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns OutputBrc20Inscription
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Output.OutputBrc20Inscription;

                    /**
                     * Creates a plain object from an OutputBrc20Inscription message. Also converts values to other types if specified.
                     * @param message OutputBrc20Inscription
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.Output.OutputBrc20Inscription, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this OutputBrc20Inscription to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a ToPublicKeyOrHash. */
            interface IToPublicKeyOrHash {

                /** ToPublicKeyOrHash pubkey */
                pubkey?: (Uint8Array|null);

                /** ToPublicKeyOrHash hash */
                hash?: (Uint8Array|null);
            }

            /** Represents a ToPublicKeyOrHash. */
            class ToPublicKeyOrHash implements IToPublicKeyOrHash {

                /**
                 * Constructs a new ToPublicKeyOrHash.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.IToPublicKeyOrHash);

                /** ToPublicKeyOrHash pubkey. */
                public pubkey?: (Uint8Array|null);

                /** ToPublicKeyOrHash hash. */
                public hash?: (Uint8Array|null);

                /** ToPublicKeyOrHash toAddress. */
                public toAddress?: ("pubkey"|"hash");

                /**
                 * Creates a new ToPublicKeyOrHash instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ToPublicKeyOrHash instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.IToPublicKeyOrHash): TW.BitcoinV2.Proto.ToPublicKeyOrHash;

                /**
                 * Encodes the specified ToPublicKeyOrHash message. Does not implicitly {@link TW.BitcoinV2.Proto.ToPublicKeyOrHash.verify|verify} messages.
                 * @param message ToPublicKeyOrHash message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.IToPublicKeyOrHash, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ToPublicKeyOrHash message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ToPublicKeyOrHash
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.ToPublicKeyOrHash;

                /**
                 * Verifies a ToPublicKeyOrHash message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ToPublicKeyOrHash message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ToPublicKeyOrHash
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.ToPublicKeyOrHash;

                /**
                 * Creates a plain object from a ToPublicKeyOrHash message. Also converts values to other types if specified.
                 * @param message ToPublicKeyOrHash
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.ToPublicKeyOrHash, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ToPublicKeyOrHash to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a PreSigningOutput. */
            interface IPreSigningOutput {

                /** PreSigningOutput error */
                error?: (TW.BitcoinV2.Proto.Error|null);

                /** PreSigningOutput errorMessage */
                errorMessage?: (string|null);

                /** PreSigningOutput txid */
                txid?: (Uint8Array|null);

                /** The sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot. */
                sighashes?: (TW.Utxo.Proto.ISighash[]|null);

                /** PreSigningOutput utxoInputs */
                utxoInputs?: (TW.Utxo.Proto.ITxIn[]|null);

                /** PreSigningOutput utxoOutputs */
                utxoOutputs?: (TW.BitcoinV2.Proto.PreSigningOutput.ITxOut[]|null);

                /** PreSigningOutput weightEstimate */
                weightEstimate?: (Long|null);

                /** PreSigningOutput feeEstimate */
                feeEstimate?: (Long|null);
            }

            /** Represents a PreSigningOutput. */
            class PreSigningOutput implements IPreSigningOutput {

                /**
                 * Constructs a new PreSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.IPreSigningOutput);

                /** PreSigningOutput error. */
                public error: TW.BitcoinV2.Proto.Error;

                /** PreSigningOutput errorMessage. */
                public errorMessage: string;

                /** PreSigningOutput txid. */
                public txid: Uint8Array;

                /** The sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot. */
                public sighashes: TW.Utxo.Proto.ISighash[];

                /** PreSigningOutput utxoInputs. */
                public utxoInputs: TW.Utxo.Proto.ITxIn[];

                /** PreSigningOutput utxoOutputs. */
                public utxoOutputs: TW.BitcoinV2.Proto.PreSigningOutput.ITxOut[];

                /** PreSigningOutput weightEstimate. */
                public weightEstimate: Long;

                /** PreSigningOutput feeEstimate. */
                public feeEstimate: Long;

                /**
                 * Creates a new PreSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSigningOutput instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.IPreSigningOutput): TW.BitcoinV2.Proto.PreSigningOutput;

                /**
                 * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.BitcoinV2.Proto.PreSigningOutput.verify|verify} messages.
                 * @param message PreSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.IPreSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.PreSigningOutput;

                /**
                 * Verifies a PreSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.PreSigningOutput;

                /**
                 * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                 * @param message PreSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.PreSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace PreSigningOutput {

                /** Properties of a TxOut. */
                interface ITxOut {

                    /** TxOut value */
                    value?: (Long|null);

                    /** TxOut scriptPubkey */
                    scriptPubkey?: (Uint8Array|null);

                    /** TxOut taprootPayload */
                    taprootPayload?: (Uint8Array|null);

                    /** TxOut controlBlock */
                    controlBlock?: (Uint8Array|null);
                }

                /** Represents a TxOut. */
                class TxOut implements ITxOut {

                    /**
                     * Constructs a new TxOut.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.PreSigningOutput.ITxOut);

                    /** TxOut value. */
                    public value: Long;

                    /** TxOut scriptPubkey. */
                    public scriptPubkey: Uint8Array;

                    /** TxOut taprootPayload. */
                    public taprootPayload: Uint8Array;

                    /** TxOut controlBlock. */
                    public controlBlock: Uint8Array;

                    /**
                     * Creates a new TxOut instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns TxOut instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.PreSigningOutput.ITxOut): TW.BitcoinV2.Proto.PreSigningOutput.TxOut;

                    /**
                     * Encodes the specified TxOut message. Does not implicitly {@link TW.BitcoinV2.Proto.PreSigningOutput.TxOut.verify|verify} messages.
                     * @param message TxOut message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.PreSigningOutput.ITxOut, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a TxOut message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns TxOut
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.PreSigningOutput.TxOut;

                    /**
                     * Verifies a TxOut message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a TxOut message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns TxOut
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.PreSigningOutput.TxOut;

                    /**
                     * Creates a plain object from a TxOut message. Also converts values to other types if specified.
                     * @param message TxOut
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.PreSigningOutput.TxOut, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this TxOut to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput error */
                error?: (TW.BitcoinV2.Proto.Error|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput transaction */
                transaction?: (TW.BitcoinV2.Proto.ITransaction|null);

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput txid */
                txid?: (Uint8Array|null);

                /** SigningOutput weight */
                weight?: (Long|null);

                /** SigningOutput fee */
                fee?: (Long|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ISigningOutput);

                /** SigningOutput error. */
                public error: TW.BitcoinV2.Proto.Error;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput transaction. */
                public transaction?: (TW.BitcoinV2.Proto.ITransaction|null);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput txid. */
                public txid: Uint8Array;

                /** SigningOutput weight. */
                public weight: Long;

                /** SigningOutput fee. */
                public fee: Long;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ISigningOutput): TW.BitcoinV2.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.BitcoinV2.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction version */
                version?: (number|null);

                /** Transaction lockTime */
                lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** Transaction inputs */
                inputs?: (TW.BitcoinV2.Proto.ITransactionInput[]|null);

                /** Transaction outputs */
                outputs?: (TW.BitcoinV2.Proto.ITransactionOutput[]|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ITransaction);

                /** Transaction version. */
                public version: number;

                /** Transaction lockTime. */
                public lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** Transaction inputs. */
                public inputs: TW.BitcoinV2.Proto.ITransactionInput[];

                /** Transaction outputs. */
                public outputs: TW.BitcoinV2.Proto.ITransactionOutput[];

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ITransaction): TW.BitcoinV2.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.BitcoinV2.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionInput. */
            interface ITransactionInput {

                /** TransactionInput txid */
                txid?: (Uint8Array|null);

                /** TransactionInput vout */
                vout?: (number|null);

                /** TransactionInput sequence */
                sequence?: (number|null);

                /** TransactionInput scriptSig */
                scriptSig?: (Uint8Array|null);

                /** TransactionInput witnessItems */
                witnessItems?: (Uint8Array[]|null);
            }

            /** Represents a TransactionInput. */
            class TransactionInput implements ITransactionInput {

                /**
                 * Constructs a new TransactionInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ITransactionInput);

                /** TransactionInput txid. */
                public txid: Uint8Array;

                /** TransactionInput vout. */
                public vout: number;

                /** TransactionInput sequence. */
                public sequence: number;

                /** TransactionInput scriptSig. */
                public scriptSig: Uint8Array;

                /** TransactionInput witnessItems. */
                public witnessItems: Uint8Array[];

                /**
                 * Creates a new TransactionInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionInput instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ITransactionInput): TW.BitcoinV2.Proto.TransactionInput;

                /**
                 * Encodes the specified TransactionInput message. Does not implicitly {@link TW.BitcoinV2.Proto.TransactionInput.verify|verify} messages.
                 * @param message TransactionInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ITransactionInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.TransactionInput;

                /**
                 * Verifies a TransactionInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.TransactionInput;

                /**
                 * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                 * @param message TransactionInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.TransactionInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOutput. */
            interface ITransactionOutput {

                /** TransactionOutput scriptPubkey */
                scriptPubkey?: (Uint8Array|null);

                /** TransactionOutput value */
                value?: (Long|null);

                /** TransactionOutput taprootPayload */
                taprootPayload?: (Uint8Array|null);

                /** TransactionOutput controlBlock */
                controlBlock?: (Uint8Array|null);
            }

            /** Represents a TransactionOutput. */
            class TransactionOutput implements ITransactionOutput {

                /**
                 * Constructs a new TransactionOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ITransactionOutput);

                /** TransactionOutput scriptPubkey. */
                public scriptPubkey: Uint8Array;

                /** TransactionOutput value. */
                public value: Long;

                /** TransactionOutput taprootPayload. */
                public taprootPayload: Uint8Array;

                /** TransactionOutput controlBlock. */
                public controlBlock: Uint8Array;

                /**
                 * Creates a new TransactionOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOutput instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ITransactionOutput): TW.BitcoinV2.Proto.TransactionOutput;

                /**
                 * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.BitcoinV2.Proto.TransactionOutput.verify|verify} messages.
                 * @param message TransactionOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ITransactionOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.TransactionOutput;

                /**
                 * Verifies a TransactionOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.TransactionOutput;

                /**
                 * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                 * @param message TransactionOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.TransactionOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ComposePlan. */
            interface IComposePlan {

                /** ComposePlan brc20 */
                brc20?: (TW.BitcoinV2.Proto.ComposePlan.IComposeBrc20Plan|null);
            }

            /** Represents a ComposePlan. */
            class ComposePlan implements IComposePlan {

                /**
                 * Constructs a new ComposePlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.IComposePlan);

                /** ComposePlan brc20. */
                public brc20?: (TW.BitcoinV2.Proto.ComposePlan.IComposeBrc20Plan|null);

                /** ComposePlan compose. */
                public compose?: "brc20";

                /**
                 * Creates a new ComposePlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ComposePlan instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.IComposePlan): TW.BitcoinV2.Proto.ComposePlan;

                /**
                 * Encodes the specified ComposePlan message. Does not implicitly {@link TW.BitcoinV2.Proto.ComposePlan.verify|verify} messages.
                 * @param message ComposePlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.IComposePlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ComposePlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ComposePlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.ComposePlan;

                /**
                 * Verifies a ComposePlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ComposePlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ComposePlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.ComposePlan;

                /**
                 * Creates a plain object from a ComposePlan message. Also converts values to other types if specified.
                 * @param message ComposePlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.ComposePlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ComposePlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace ComposePlan {

                /** Properties of a ComposeBrc20Plan. */
                interface IComposeBrc20Plan {

                    /** ComposeBrc20Plan privateKey */
                    privateKey?: (Uint8Array|null);

                    /** ComposeBrc20Plan inputs */
                    inputs?: (TW.BitcoinV2.Proto.IInput[]|null);

                    /** ComposeBrc20Plan inputSelector */
                    inputSelector?: (TW.Utxo.Proto.InputSelector|null);

                    /** ComposeBrc20Plan taggedOutput */
                    taggedOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                    /** ComposeBrc20Plan inscription */
                    inscription?: (TW.BitcoinV2.Proto.Input.IInputBrc20Inscription|null);

                    /** ComposeBrc20Plan feePerVb */
                    feePerVb?: (Long|null);

                    /** ComposeBrc20Plan changeOutput */
                    changeOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                    /** ComposeBrc20Plan disableChangeOutput */
                    disableChangeOutput?: (boolean|null);
                }

                /** Represents a ComposeBrc20Plan. */
                class ComposeBrc20Plan implements IComposeBrc20Plan {

                    /**
                     * Constructs a new ComposeBrc20Plan.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.ComposePlan.IComposeBrc20Plan);

                    /** ComposeBrc20Plan privateKey. */
                    public privateKey: Uint8Array;

                    /** ComposeBrc20Plan inputs. */
                    public inputs: TW.BitcoinV2.Proto.IInput[];

                    /** ComposeBrc20Plan inputSelector. */
                    public inputSelector: TW.Utxo.Proto.InputSelector;

                    /** ComposeBrc20Plan taggedOutput. */
                    public taggedOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                    /** ComposeBrc20Plan inscription. */
                    public inscription?: (TW.BitcoinV2.Proto.Input.IInputBrc20Inscription|null);

                    /** ComposeBrc20Plan feePerVb. */
                    public feePerVb: Long;

                    /** ComposeBrc20Plan changeOutput. */
                    public changeOutput?: (TW.BitcoinV2.Proto.IOutput|null);

                    /** ComposeBrc20Plan disableChangeOutput. */
                    public disableChangeOutput: boolean;

                    /**
                     * Creates a new ComposeBrc20Plan instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ComposeBrc20Plan instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.ComposePlan.IComposeBrc20Plan): TW.BitcoinV2.Proto.ComposePlan.ComposeBrc20Plan;

                    /**
                     * Encodes the specified ComposeBrc20Plan message. Does not implicitly {@link TW.BitcoinV2.Proto.ComposePlan.ComposeBrc20Plan.verify|verify} messages.
                     * @param message ComposeBrc20Plan message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.ComposePlan.IComposeBrc20Plan, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ComposeBrc20Plan message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ComposeBrc20Plan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.ComposePlan.ComposeBrc20Plan;

                    /**
                     * Verifies a ComposeBrc20Plan message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ComposeBrc20Plan message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ComposeBrc20Plan
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.ComposePlan.ComposeBrc20Plan;

                    /**
                     * Creates a plain object from a ComposeBrc20Plan message. Also converts values to other types if specified.
                     * @param message ComposeBrc20Plan
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.ComposePlan.ComposeBrc20Plan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ComposeBrc20Plan to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a TransactionPlan. */
            interface ITransactionPlan {

                /** TransactionPlan error */
                error?: (TW.BitcoinV2.Proto.Error|null);

                /** TransactionPlan errorMessage */
                errorMessage?: (string|null);

                /** TransactionPlan brc20 */
                brc20?: (TW.BitcoinV2.Proto.TransactionPlan.IBrc20Plan|null);
            }

            /** Represents a TransactionPlan. */
            class TransactionPlan implements ITransactionPlan {

                /**
                 * Constructs a new TransactionPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.BitcoinV2.Proto.ITransactionPlan);

                /** TransactionPlan error. */
                public error: TW.BitcoinV2.Proto.Error;

                /** TransactionPlan errorMessage. */
                public errorMessage: string;

                /** TransactionPlan brc20. */
                public brc20?: (TW.BitcoinV2.Proto.TransactionPlan.IBrc20Plan|null);

                /** TransactionPlan plan. */
                public plan?: "brc20";

                /**
                 * Creates a new TransactionPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionPlan instance
                 */
                public static create(properties?: TW.BitcoinV2.Proto.ITransactionPlan): TW.BitcoinV2.Proto.TransactionPlan;

                /**
                 * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.BitcoinV2.Proto.TransactionPlan.verify|verify} messages.
                 * @param message TransactionPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.BitcoinV2.Proto.ITransactionPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.TransactionPlan;

                /**
                 * Verifies a TransactionPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.TransactionPlan;

                /**
                 * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                 * @param message TransactionPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.BitcoinV2.Proto.TransactionPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace TransactionPlan {

                /** Properties of a Brc20Plan. */
                interface IBrc20Plan {

                    /** Brc20Plan commit */
                    commit?: (TW.BitcoinV2.Proto.ISigningInput|null);

                    /** Brc20Plan reveal */
                    reveal?: (TW.BitcoinV2.Proto.ISigningInput|null);
                }

                /** Represents a Brc20Plan. */
                class Brc20Plan implements IBrc20Plan {

                    /**
                     * Constructs a new Brc20Plan.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.BitcoinV2.Proto.TransactionPlan.IBrc20Plan);

                    /** Brc20Plan commit. */
                    public commit?: (TW.BitcoinV2.Proto.ISigningInput|null);

                    /** Brc20Plan reveal. */
                    public reveal?: (TW.BitcoinV2.Proto.ISigningInput|null);

                    /**
                     * Creates a new Brc20Plan instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Brc20Plan instance
                     */
                    public static create(properties?: TW.BitcoinV2.Proto.TransactionPlan.IBrc20Plan): TW.BitcoinV2.Proto.TransactionPlan.Brc20Plan;

                    /**
                     * Encodes the specified Brc20Plan message. Does not implicitly {@link TW.BitcoinV2.Proto.TransactionPlan.Brc20Plan.verify|verify} messages.
                     * @param message Brc20Plan message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.BitcoinV2.Proto.TransactionPlan.IBrc20Plan, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Brc20Plan message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Brc20Plan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.BitcoinV2.Proto.TransactionPlan.Brc20Plan;

                    /**
                     * Verifies a Brc20Plan message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Brc20Plan message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Brc20Plan
                     */
                    public static fromObject(object: { [k: string]: any }): TW.BitcoinV2.Proto.TransactionPlan.Brc20Plan;

                    /**
                     * Creates a plain object from a Brc20Plan message. Also converts values to other types if specified.
                     * @param message Brc20Plan
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.BitcoinV2.Proto.TransactionPlan.Brc20Plan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Brc20Plan to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }
        }
    }

    /** Namespace Utxo. */
    namespace Utxo {

        /** Namespace Proto. */
        namespace Proto {

            /** Error enum. */
            enum Error {
                OK = 0,
                Error_invalid_leaf_hash = 1,
                Error_invalid_sighash_type = 2,
                Error_invalid_lock_time = 3,
                Error_invalid_txid = 4,
                Error_sighash_failed = 5,
                Error_missing_sighash_method = 6,
                Error_failed_encoding = 7,
                Error_insufficient_inputs = 8,
                Error_missing_change_script_pubkey = 9
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput version */
                version?: (number|null);

                /** SigningInput lockTime */
                lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** SigningInput inputs */
                inputs?: (TW.Utxo.Proto.ITxIn[]|null);

                /** SigningInput outputs */
                outputs?: (TW.Utxo.Proto.ITxOut[]|null);

                /** SigningInput inputSelector */
                inputSelector?: (TW.Utxo.Proto.InputSelector|null);

                /** SigningInput weightBase */
                weightBase?: (Long|null);

                /** SigningInput changeScriptPubkey */
                changeScriptPubkey?: (Uint8Array|null);

                /** SigningInput disableChangeOutput */
                disableChangeOutput?: (boolean|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ISigningInput);

                /** SigningInput version. */
                public version: number;

                /** SigningInput lockTime. */
                public lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** SigningInput inputs. */
                public inputs: TW.Utxo.Proto.ITxIn[];

                /** SigningInput outputs. */
                public outputs: TW.Utxo.Proto.ITxOut[];

                /** SigningInput inputSelector. */
                public inputSelector: TW.Utxo.Proto.InputSelector;

                /** SigningInput weightBase. */
                public weightBase: Long;

                /** SigningInput changeScriptPubkey. */
                public changeScriptPubkey: Uint8Array;

                /** SigningInput disableChangeOutput. */
                public disableChangeOutput: boolean;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Utxo.Proto.ISigningInput): TW.Utxo.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Utxo.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** InputSelector enum. */
            enum InputSelector {
                UseAll = 0,
                SelectInOrder = 1,
                SelectAscending = 2
            }

            /** Properties of a LockTime. */
            interface ILockTime {

                /** LockTime blocks */
                blocks?: (number|null);

                /** LockTime seconds */
                seconds?: (number|null);
            }

            /** Represents a LockTime. */
            class LockTime implements ILockTime {

                /**
                 * Constructs a new LockTime.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ILockTime);

                /** LockTime blocks. */
                public blocks?: (number|null);

                /** LockTime seconds. */
                public seconds?: (number|null);

                /** LockTime variant. */
                public variant?: ("blocks"|"seconds");

                /**
                 * Creates a new LockTime instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns LockTime instance
                 */
                public static create(properties?: TW.Utxo.Proto.ILockTime): TW.Utxo.Proto.LockTime;

                /**
                 * Encodes the specified LockTime message. Does not implicitly {@link TW.Utxo.Proto.LockTime.verify|verify} messages.
                 * @param message LockTime message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ILockTime, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LockTime message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns LockTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.LockTime;

                /**
                 * Verifies a LockTime message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a LockTime message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns LockTime
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.LockTime;

                /**
                 * Creates a plain object from a LockTime message. Also converts values to other types if specified.
                 * @param message LockTime
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.LockTime, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this LockTime to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TxIn. */
            interface ITxIn {

                /** TxIn txid */
                txid?: (Uint8Array|null);

                /** TxIn vout */
                vout?: (number|null);

                /** TxIn value */
                value?: (Long|null);

                /** TxIn sequence */
                sequence?: (number|null);

                /** TxIn scriptPubkey */
                scriptPubkey?: (Uint8Array|null);

                /** TxIn sighashType */
                sighashType?: (TW.Utxo.Proto.SighashType|null);

                /** TxIn signingMethod */
                signingMethod?: (TW.Utxo.Proto.SigningMethod|null);

                /** TxIn weightEstimate */
                weightEstimate?: (Long|null);

                /** TxIn leafHash */
                leafHash?: (Uint8Array|null);
            }

            /** Represents a TxIn. */
            class TxIn implements ITxIn {

                /**
                 * Constructs a new TxIn.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ITxIn);

                /** TxIn txid. */
                public txid: Uint8Array;

                /** TxIn vout. */
                public vout: number;

                /** TxIn value. */
                public value: Long;

                /** TxIn sequence. */
                public sequence: number;

                /** TxIn scriptPubkey. */
                public scriptPubkey: Uint8Array;

                /** TxIn sighashType. */
                public sighashType: TW.Utxo.Proto.SighashType;

                /** TxIn signingMethod. */
                public signingMethod: TW.Utxo.Proto.SigningMethod;

                /** TxIn weightEstimate. */
                public weightEstimate: Long;

                /** TxIn leafHash. */
                public leafHash: Uint8Array;

                /**
                 * Creates a new TxIn instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxIn instance
                 */
                public static create(properties?: TW.Utxo.Proto.ITxIn): TW.Utxo.Proto.TxIn;

                /**
                 * Encodes the specified TxIn message. Does not implicitly {@link TW.Utxo.Proto.TxIn.verify|verify} messages.
                 * @param message TxIn message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ITxIn, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxIn message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxIn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.TxIn;

                /**
                 * Verifies a TxIn message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxIn message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxIn
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.TxIn;

                /**
                 * Creates a plain object from a TxIn message. Also converts values to other types if specified.
                 * @param message TxIn
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.TxIn, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxIn to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** SigningMethod enum. */
            enum SigningMethod {
                Legacy = 0,
                Segwit = 1,
                TaprootAll = 2,
                TaprootOnePrevout = 3
            }

            /** SighashType enum. */
            enum SighashType {
                UseDefault = 0,
                All = 1,
                None = 2,
                Single = 3,
                AllPlusAnyoneCanPay = 129,
                NonePlusAnyoneCanPay = 130,
                SinglePlusAnyoneCanPay = 131
            }

            /** Properties of a TxOut. */
            interface ITxOut {

                /** TxOut value */
                value?: (Long|null);

                /** TxOut scriptPubkey */
                scriptPubkey?: (Uint8Array|null);
            }

            /** Represents a TxOut. */
            class TxOut implements ITxOut {

                /**
                 * Constructs a new TxOut.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ITxOut);

                /** TxOut value. */
                public value: Long;

                /** TxOut scriptPubkey. */
                public scriptPubkey: Uint8Array;

                /**
                 * Creates a new TxOut instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxOut instance
                 */
                public static create(properties?: TW.Utxo.Proto.ITxOut): TW.Utxo.Proto.TxOut;

                /**
                 * Encodes the specified TxOut message. Does not implicitly {@link TW.Utxo.Proto.TxOut.verify|verify} messages.
                 * @param message TxOut message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ITxOut, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxOut message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.TxOut;

                /**
                 * Verifies a TxOut message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxOut message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxOut
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.TxOut;

                /**
                 * Creates a plain object from a TxOut message. Also converts values to other types if specified.
                 * @param message TxOut
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.TxOut, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxOut to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a PreSigningOutput. */
            interface IPreSigningOutput {

                /** PreSigningOutput error */
                error?: (TW.Utxo.Proto.Error|null);

                /** PreSigningOutput txid */
                txid?: (Uint8Array|null);

                /** Sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot. */
                sighashes?: (TW.Utxo.Proto.ISighash[]|null);

                /** PreSigningOutput inputs */
                inputs?: (TW.Utxo.Proto.ITxIn[]|null);

                /** PreSigningOutput outputs */
                outputs?: (TW.Utxo.Proto.ITxOut[]|null);

                /** PreSigningOutput weightEstimate */
                weightEstimate?: (Long|null);

                /** PreSigningOutput feeEstimate */
                feeEstimate?: (Long|null);
            }

            /** Represents a PreSigningOutput. */
            class PreSigningOutput implements IPreSigningOutput {

                /**
                 * Constructs a new PreSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.IPreSigningOutput);

                /** PreSigningOutput error. */
                public error: TW.Utxo.Proto.Error;

                /** PreSigningOutput txid. */
                public txid: Uint8Array;

                /** Sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot. */
                public sighashes: TW.Utxo.Proto.ISighash[];

                /** PreSigningOutput inputs. */
                public inputs: TW.Utxo.Proto.ITxIn[];

                /** PreSigningOutput outputs. */
                public outputs: TW.Utxo.Proto.ITxOut[];

                /** PreSigningOutput weightEstimate. */
                public weightEstimate: Long;

                /** PreSigningOutput feeEstimate. */
                public feeEstimate: Long;

                /**
                 * Creates a new PreSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSigningOutput instance
                 */
                public static create(properties?: TW.Utxo.Proto.IPreSigningOutput): TW.Utxo.Proto.PreSigningOutput;

                /**
                 * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.Utxo.Proto.PreSigningOutput.verify|verify} messages.
                 * @param message PreSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.IPreSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.PreSigningOutput;

                /**
                 * Verifies a PreSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.PreSigningOutput;

                /**
                 * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                 * @param message PreSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.PreSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Sighash. */
            interface ISighash {

                /** Sighash sighash */
                sighash?: (Uint8Array|null);

                /** Sighash signingMethod */
                signingMethod?: (TW.Utxo.Proto.SigningMethod|null);

                /** Sighash sighashType */
                sighashType?: (TW.Utxo.Proto.SighashType|null);
            }

            /** Represents a Sighash. */
            class Sighash implements ISighash {

                /**
                 * Constructs a new Sighash.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ISighash);

                /** Sighash sighash. */
                public sighash: Uint8Array;

                /** Sighash signingMethod. */
                public signingMethod: TW.Utxo.Proto.SigningMethod;

                /** Sighash sighashType. */
                public sighashType: TW.Utxo.Proto.SighashType;

                /**
                 * Creates a new Sighash instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Sighash instance
                 */
                public static create(properties?: TW.Utxo.Proto.ISighash): TW.Utxo.Proto.Sighash;

                /**
                 * Encodes the specified Sighash message. Does not implicitly {@link TW.Utxo.Proto.Sighash.verify|verify} messages.
                 * @param message Sighash message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ISighash, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Sighash message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Sighash
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.Sighash;

                /**
                 * Verifies a Sighash message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Sighash message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Sighash
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.Sighash;

                /**
                 * Creates a plain object from a Sighash message. Also converts values to other types if specified.
                 * @param message Sighash
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.Sighash, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Sighash to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a PreSerialization. */
            interface IPreSerialization {

                /** PreSerialization version */
                version?: (number|null);

                /** PreSerialization lockTime */
                lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** PreSerialization inputs */
                inputs?: (TW.Utxo.Proto.ITxInClaim[]|null);

                /** PreSerialization outputs */
                outputs?: (TW.Utxo.Proto.ITxOut[]|null);

                /** PreSerialization weightBase */
                weightBase?: (Long|null);
            }

            /** Represents a PreSerialization. */
            class PreSerialization implements IPreSerialization {

                /**
                 * Constructs a new PreSerialization.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.IPreSerialization);

                /** PreSerialization version. */
                public version: number;

                /** PreSerialization lockTime. */
                public lockTime?: (TW.Utxo.Proto.ILockTime|null);

                /** PreSerialization inputs. */
                public inputs: TW.Utxo.Proto.ITxInClaim[];

                /** PreSerialization outputs. */
                public outputs: TW.Utxo.Proto.ITxOut[];

                /** PreSerialization weightBase. */
                public weightBase: Long;

                /**
                 * Creates a new PreSerialization instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSerialization instance
                 */
                public static create(properties?: TW.Utxo.Proto.IPreSerialization): TW.Utxo.Proto.PreSerialization;

                /**
                 * Encodes the specified PreSerialization message. Does not implicitly {@link TW.Utxo.Proto.PreSerialization.verify|verify} messages.
                 * @param message PreSerialization message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.IPreSerialization, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSerialization message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSerialization
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.PreSerialization;

                /**
                 * Verifies a PreSerialization message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSerialization message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSerialization
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.PreSerialization;

                /**
                 * Creates a plain object from a PreSerialization message. Also converts values to other types if specified.
                 * @param message PreSerialization
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.PreSerialization, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSerialization to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TxInClaim. */
            interface ITxInClaim {

                /** TxInClaim txid */
                txid?: (Uint8Array|null);

                /** TxInClaim vout */
                vout?: (number|null);

                /** TxInClaim sequence */
                sequence?: (number|null);

                /** TxInClaim scriptSig */
                scriptSig?: (Uint8Array|null);

                /** TxInClaim witnessItems */
                witnessItems?: (Uint8Array[]|null);
            }

            /** Represents a TxInClaim. */
            class TxInClaim implements ITxInClaim {

                /**
                 * Constructs a new TxInClaim.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ITxInClaim);

                /** TxInClaim txid. */
                public txid: Uint8Array;

                /** TxInClaim vout. */
                public vout: number;

                /** TxInClaim sequence. */
                public sequence: number;

                /** TxInClaim scriptSig. */
                public scriptSig: Uint8Array;

                /** TxInClaim witnessItems. */
                public witnessItems: Uint8Array[];

                /**
                 * Creates a new TxInClaim instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxInClaim instance
                 */
                public static create(properties?: TW.Utxo.Proto.ITxInClaim): TW.Utxo.Proto.TxInClaim;

                /**
                 * Encodes the specified TxInClaim message. Does not implicitly {@link TW.Utxo.Proto.TxInClaim.verify|verify} messages.
                 * @param message TxInClaim message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ITxInClaim, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxInClaim message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxInClaim
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.TxInClaim;

                /**
                 * Verifies a TxInClaim message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxInClaim message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxInClaim
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.TxInClaim;

                /**
                 * Creates a plain object from a TxInClaim message. Also converts values to other types if specified.
                 * @param message TxInClaim
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.TxInClaim, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxInClaim to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SerializedTransaction. */
            interface ISerializedTransaction {

                /** SerializedTransaction error */
                error?: (TW.Utxo.Proto.Error|null);

                /** SerializedTransaction encoded */
                encoded?: (Uint8Array|null);

                /** SerializedTransaction txid */
                txid?: (Uint8Array|null);

                /** SerializedTransaction weight */
                weight?: (Long|null);

                /** SerializedTransaction fee */
                fee?: (Long|null);
            }

            /** Represents a SerializedTransaction. */
            class SerializedTransaction implements ISerializedTransaction {

                /**
                 * Constructs a new SerializedTransaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Utxo.Proto.ISerializedTransaction);

                /** SerializedTransaction error. */
                public error: TW.Utxo.Proto.Error;

                /** SerializedTransaction encoded. */
                public encoded: Uint8Array;

                /** SerializedTransaction txid. */
                public txid: Uint8Array;

                /** SerializedTransaction weight. */
                public weight: Long;

                /** SerializedTransaction fee. */
                public fee: Long;

                /**
                 * Creates a new SerializedTransaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SerializedTransaction instance
                 */
                public static create(properties?: TW.Utxo.Proto.ISerializedTransaction): TW.Utxo.Proto.SerializedTransaction;

                /**
                 * Encodes the specified SerializedTransaction message. Does not implicitly {@link TW.Utxo.Proto.SerializedTransaction.verify|verify} messages.
                 * @param message SerializedTransaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Utxo.Proto.ISerializedTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SerializedTransaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SerializedTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Utxo.Proto.SerializedTransaction;

                /**
                 * Verifies a SerializedTransaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SerializedTransaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SerializedTransaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Utxo.Proto.SerializedTransaction;

                /**
                 * Creates a plain object from a SerializedTransaction message. Also converts values to other types if specified.
                 * @param message SerializedTransaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Utxo.Proto.SerializedTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SerializedTransaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Cardano. */
    namespace Cardano {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of an OutPoint. */
            interface IOutPoint {

                /** OutPoint txHash */
                txHash?: (Uint8Array|null);

                /** OutPoint outputIndex */
                outputIndex?: (Long|null);
            }

            /** Represents an OutPoint. */
            class OutPoint implements IOutPoint {

                /**
                 * Constructs a new OutPoint.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.IOutPoint);

                /** OutPoint txHash. */
                public txHash: Uint8Array;

                /** OutPoint outputIndex. */
                public outputIndex: Long;

                /**
                 * Creates a new OutPoint instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OutPoint instance
                 */
                public static create(properties?: TW.Cardano.Proto.IOutPoint): TW.Cardano.Proto.OutPoint;

                /**
                 * Encodes the specified OutPoint message. Does not implicitly {@link TW.Cardano.Proto.OutPoint.verify|verify} messages.
                 * @param message OutPoint message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.IOutPoint, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OutPoint message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OutPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.OutPoint;

                /**
                 * Verifies an OutPoint message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OutPoint
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.OutPoint;

                /**
                 * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                 * @param message OutPoint
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.OutPoint, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OutPoint to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenAmount. */
            interface ITokenAmount {

                /** TokenAmount policyId */
                policyId?: (string|null);

                /** TokenAmount assetName */
                assetName?: (string|null);

                /** TokenAmount amount */
                amount?: (Uint8Array|null);

                /** TokenAmount assetNameHex */
                assetNameHex?: (string|null);
            }

            /** Represents a TokenAmount. */
            class TokenAmount implements ITokenAmount {

                /**
                 * Constructs a new TokenAmount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITokenAmount);

                /** TokenAmount policyId. */
                public policyId: string;

                /** TokenAmount assetName. */
                public assetName: string;

                /** TokenAmount amount. */
                public amount: Uint8Array;

                /** TokenAmount assetNameHex. */
                public assetNameHex: string;

                /**
                 * Creates a new TokenAmount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenAmount instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITokenAmount): TW.Cardano.Proto.TokenAmount;

                /**
                 * Encodes the specified TokenAmount message. Does not implicitly {@link TW.Cardano.Proto.TokenAmount.verify|verify} messages.
                 * @param message TokenAmount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITokenAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenAmount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.TokenAmount;

                /**
                 * Verifies a TokenAmount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenAmount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenAmount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.TokenAmount;

                /**
                 * Creates a plain object from a TokenAmount message. Also converts values to other types if specified.
                 * @param message TokenAmount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.TokenAmount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenAmount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TxInput. */
            interface ITxInput {

                /** TxInput outPoint */
                outPoint?: (TW.Cardano.Proto.IOutPoint|null);

                /** TxInput address */
                address?: (string|null);

                /** TxInput amount */
                amount?: (Long|null);

                /** TxInput tokenAmount */
                tokenAmount?: (TW.Cardano.Proto.ITokenAmount[]|null);
            }

            /** Represents a TxInput. */
            class TxInput implements ITxInput {

                /**
                 * Constructs a new TxInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITxInput);

                /** TxInput outPoint. */
                public outPoint?: (TW.Cardano.Proto.IOutPoint|null);

                /** TxInput address. */
                public address: string;

                /** TxInput amount. */
                public amount: Long;

                /** TxInput tokenAmount. */
                public tokenAmount: TW.Cardano.Proto.ITokenAmount[];

                /**
                 * Creates a new TxInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxInput instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITxInput): TW.Cardano.Proto.TxInput;

                /**
                 * Encodes the specified TxInput message. Does not implicitly {@link TW.Cardano.Proto.TxInput.verify|verify} messages.
                 * @param message TxInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITxInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.TxInput;

                /**
                 * Verifies a TxInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.TxInput;

                /**
                 * Creates a plain object from a TxInput message. Also converts values to other types if specified.
                 * @param message TxInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.TxInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TxOutput. */
            interface ITxOutput {

                /** TxOutput address */
                address?: (string|null);

                /** TxOutput amount */
                amount?: (Long|null);

                /** TxOutput tokenAmount */
                tokenAmount?: (TW.Cardano.Proto.ITokenAmount[]|null);
            }

            /** Represents a TxOutput. */
            class TxOutput implements ITxOutput {

                /**
                 * Constructs a new TxOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITxOutput);

                /** TxOutput address. */
                public address: string;

                /** TxOutput amount. */
                public amount: Long;

                /** TxOutput tokenAmount. */
                public tokenAmount: TW.Cardano.Proto.ITokenAmount[];

                /**
                 * Creates a new TxOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxOutput instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITxOutput): TW.Cardano.Proto.TxOutput;

                /**
                 * Encodes the specified TxOutput message. Does not implicitly {@link TW.Cardano.Proto.TxOutput.verify|verify} messages.
                 * @param message TxOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITxOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.TxOutput;

                /**
                 * Verifies a TxOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.TxOutput;

                /**
                 * Creates a plain object from a TxOutput message. Also converts values to other types if specified.
                 * @param message TxOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.TxOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenBundle. */
            interface ITokenBundle {

                /** TokenBundle token */
                token?: (TW.Cardano.Proto.ITokenAmount[]|null);
            }

            /** Represents a TokenBundle. */
            class TokenBundle implements ITokenBundle {

                /**
                 * Constructs a new TokenBundle.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITokenBundle);

                /** TokenBundle token. */
                public token: TW.Cardano.Proto.ITokenAmount[];

                /**
                 * Creates a new TokenBundle instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenBundle instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITokenBundle): TW.Cardano.Proto.TokenBundle;

                /**
                 * Encodes the specified TokenBundle message. Does not implicitly {@link TW.Cardano.Proto.TokenBundle.verify|verify} messages.
                 * @param message TokenBundle message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITokenBundle, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenBundle message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenBundle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.TokenBundle;

                /**
                 * Verifies a TokenBundle message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenBundle message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenBundle
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.TokenBundle;

                /**
                 * Creates a plain object from a TokenBundle message. Also converts values to other types if specified.
                 * @param message TokenBundle
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.TokenBundle, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenBundle to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer toAddress */
                toAddress?: (string|null);

                /** Transfer changeAddress */
                changeAddress?: (string|null);

                /** Transfer amount */
                amount?: (Long|null);

                /** Transfer tokenAmount */
                tokenAmount?: (TW.Cardano.Proto.ITokenBundle|null);

                /** Transfer useMaxAmount */
                useMaxAmount?: (boolean|null);

                /** Transfer forceFee */
                forceFee?: (Long|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITransfer);

                /** Transfer toAddress. */
                public toAddress: string;

                /** Transfer changeAddress. */
                public changeAddress: string;

                /** Transfer amount. */
                public amount: Long;

                /** Transfer tokenAmount. */
                public tokenAmount?: (TW.Cardano.Proto.ITokenBundle|null);

                /** Transfer useMaxAmount. */
                public useMaxAmount: boolean;

                /** Transfer forceFee. */
                public forceFee: Long;

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITransfer): TW.Cardano.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.Cardano.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a RegisterStakingKey. */
            interface IRegisterStakingKey {

                /** RegisterStakingKey stakingAddress */
                stakingAddress?: (string|null);

                /** RegisterStakingKey depositAmount */
                depositAmount?: (Long|null);
            }

            /** Represents a RegisterStakingKey. */
            class RegisterStakingKey implements IRegisterStakingKey {

                /**
                 * Constructs a new RegisterStakingKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.IRegisterStakingKey);

                /** RegisterStakingKey stakingAddress. */
                public stakingAddress: string;

                /** RegisterStakingKey depositAmount. */
                public depositAmount: Long;

                /**
                 * Creates a new RegisterStakingKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RegisterStakingKey instance
                 */
                public static create(properties?: TW.Cardano.Proto.IRegisterStakingKey): TW.Cardano.Proto.RegisterStakingKey;

                /**
                 * Encodes the specified RegisterStakingKey message. Does not implicitly {@link TW.Cardano.Proto.RegisterStakingKey.verify|verify} messages.
                 * @param message RegisterStakingKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.IRegisterStakingKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RegisterStakingKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RegisterStakingKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.RegisterStakingKey;

                /**
                 * Verifies a RegisterStakingKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RegisterStakingKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RegisterStakingKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.RegisterStakingKey;

                /**
                 * Creates a plain object from a RegisterStakingKey message. Also converts values to other types if specified.
                 * @param message RegisterStakingKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.RegisterStakingKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RegisterStakingKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeregisterStakingKey. */
            interface IDeregisterStakingKey {

                /** DeregisterStakingKey stakingAddress */
                stakingAddress?: (string|null);

                /** DeregisterStakingKey undepositAmount */
                undepositAmount?: (Long|null);
            }

            /** Represents a DeregisterStakingKey. */
            class DeregisterStakingKey implements IDeregisterStakingKey {

                /**
                 * Constructs a new DeregisterStakingKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.IDeregisterStakingKey);

                /** DeregisterStakingKey stakingAddress. */
                public stakingAddress: string;

                /** DeregisterStakingKey undepositAmount. */
                public undepositAmount: Long;

                /**
                 * Creates a new DeregisterStakingKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeregisterStakingKey instance
                 */
                public static create(properties?: TW.Cardano.Proto.IDeregisterStakingKey): TW.Cardano.Proto.DeregisterStakingKey;

                /**
                 * Encodes the specified DeregisterStakingKey message. Does not implicitly {@link TW.Cardano.Proto.DeregisterStakingKey.verify|verify} messages.
                 * @param message DeregisterStakingKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.IDeregisterStakingKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeregisterStakingKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeregisterStakingKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.DeregisterStakingKey;

                /**
                 * Verifies a DeregisterStakingKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeregisterStakingKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeregisterStakingKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.DeregisterStakingKey;

                /**
                 * Creates a plain object from a DeregisterStakingKey message. Also converts values to other types if specified.
                 * @param message DeregisterStakingKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.DeregisterStakingKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeregisterStakingKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Delegate. */
            interface IDelegate {

                /** Delegate stakingAddress */
                stakingAddress?: (string|null);

                /** Delegate poolId */
                poolId?: (Uint8Array|null);

                /** Delegate depositAmount */
                depositAmount?: (Long|null);
            }

            /** Represents a Delegate. */
            class Delegate implements IDelegate {

                /**
                 * Constructs a new Delegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.IDelegate);

                /** Delegate stakingAddress. */
                public stakingAddress: string;

                /** Delegate poolId. */
                public poolId: Uint8Array;

                /** Delegate depositAmount. */
                public depositAmount: Long;

                /**
                 * Creates a new Delegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Delegate instance
                 */
                public static create(properties?: TW.Cardano.Proto.IDelegate): TW.Cardano.Proto.Delegate;

                /**
                 * Encodes the specified Delegate message. Does not implicitly {@link TW.Cardano.Proto.Delegate.verify|verify} messages.
                 * @param message Delegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.IDelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Delegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Delegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.Delegate;

                /**
                 * Verifies a Delegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Delegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Delegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.Delegate;

                /**
                 * Creates a plain object from a Delegate message. Also converts values to other types if specified.
                 * @param message Delegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.Delegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Delegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Withdraw. */
            interface IWithdraw {

                /** Withdraw stakingAddress */
                stakingAddress?: (string|null);

                /** Withdraw withdrawAmount */
                withdrawAmount?: (Long|null);
            }

            /** Represents a Withdraw. */
            class Withdraw implements IWithdraw {

                /**
                 * Constructs a new Withdraw.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.IWithdraw);

                /** Withdraw stakingAddress. */
                public stakingAddress: string;

                /** Withdraw withdrawAmount. */
                public withdrawAmount: Long;

                /**
                 * Creates a new Withdraw instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Withdraw instance
                 */
                public static create(properties?: TW.Cardano.Proto.IWithdraw): TW.Cardano.Proto.Withdraw;

                /**
                 * Encodes the specified Withdraw message. Does not implicitly {@link TW.Cardano.Proto.Withdraw.verify|verify} messages.
                 * @param message Withdraw message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.IWithdraw, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Withdraw message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Withdraw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.Withdraw;

                /**
                 * Verifies a Withdraw message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Withdraw message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Withdraw
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.Withdraw;

                /**
                 * Creates a plain object from a Withdraw message. Also converts values to other types if specified.
                 * @param message Withdraw
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.Withdraw, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Withdraw to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionPlan. */
            interface ITransactionPlan {

                /** TransactionPlan availableAmount */
                availableAmount?: (Long|null);

                /** TransactionPlan amount */
                amount?: (Long|null);

                /** TransactionPlan fee */
                fee?: (Long|null);

                /** TransactionPlan change */
                change?: (Long|null);

                /** TransactionPlan deposit */
                deposit?: (Long|null);

                /** TransactionPlan undeposit */
                undeposit?: (Long|null);

                /** TransactionPlan availableTokens */
                availableTokens?: (TW.Cardano.Proto.ITokenAmount[]|null);

                /** TransactionPlan outputTokens */
                outputTokens?: (TW.Cardano.Proto.ITokenAmount[]|null);

                /** TransactionPlan changeTokens */
                changeTokens?: (TW.Cardano.Proto.ITokenAmount[]|null);

                /** TransactionPlan utxos */
                utxos?: (TW.Cardano.Proto.ITxInput[]|null);

                /** TransactionPlan error */
                error?: (TW.Common.Proto.SigningError|null);

                /** TransactionPlan extraOutputs */
                extraOutputs?: (TW.Cardano.Proto.ITxOutput[]|null);
            }

            /** Represents a TransactionPlan. */
            class TransactionPlan implements ITransactionPlan {

                /**
                 * Constructs a new TransactionPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ITransactionPlan);

                /** TransactionPlan availableAmount. */
                public availableAmount: Long;

                /** TransactionPlan amount. */
                public amount: Long;

                /** TransactionPlan fee. */
                public fee: Long;

                /** TransactionPlan change. */
                public change: Long;

                /** TransactionPlan deposit. */
                public deposit: Long;

                /** TransactionPlan undeposit. */
                public undeposit: Long;

                /** TransactionPlan availableTokens. */
                public availableTokens: TW.Cardano.Proto.ITokenAmount[];

                /** TransactionPlan outputTokens. */
                public outputTokens: TW.Cardano.Proto.ITokenAmount[];

                /** TransactionPlan changeTokens. */
                public changeTokens: TW.Cardano.Proto.ITokenAmount[];

                /** TransactionPlan utxos. */
                public utxos: TW.Cardano.Proto.ITxInput[];

                /** TransactionPlan error. */
                public error: TW.Common.Proto.SigningError;

                /** TransactionPlan extraOutputs. */
                public extraOutputs: TW.Cardano.Proto.ITxOutput[];

                /**
                 * Creates a new TransactionPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionPlan instance
                 */
                public static create(properties?: TW.Cardano.Proto.ITransactionPlan): TW.Cardano.Proto.TransactionPlan;

                /**
                 * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Cardano.Proto.TransactionPlan.verify|verify} messages.
                 * @param message TransactionPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ITransactionPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.TransactionPlan;

                /**
                 * Verifies a TransactionPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.TransactionPlan;

                /**
                 * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                 * @param message TransactionPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.TransactionPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput utxos */
                utxos?: (TW.Cardano.Proto.ITxInput[]|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array[]|null);

                /** SigningInput transferMessage */
                transferMessage?: (TW.Cardano.Proto.ITransfer|null);

                /** SigningInput registerStakingKey */
                registerStakingKey?: (TW.Cardano.Proto.IRegisterStakingKey|null);

                /** SigningInput delegate */
                delegate?: (TW.Cardano.Proto.IDelegate|null);

                /** SigningInput withdraw */
                withdraw?: (TW.Cardano.Proto.IWithdraw|null);

                /** SigningInput deregisterStakingKey */
                deregisterStakingKey?: (TW.Cardano.Proto.IDeregisterStakingKey|null);

                /** SigningInput ttl */
                ttl?: (Long|null);

                /** SigningInput plan */
                plan?: (TW.Cardano.Proto.ITransactionPlan|null);

                /** SigningInput extraOutputs */
                extraOutputs?: (TW.Cardano.Proto.ITxOutput[]|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ISigningInput);

                /** SigningInput utxos. */
                public utxos: TW.Cardano.Proto.ITxInput[];

                /** SigningInput privateKey. */
                public privateKey: Uint8Array[];

                /** SigningInput transferMessage. */
                public transferMessage?: (TW.Cardano.Proto.ITransfer|null);

                /** SigningInput registerStakingKey. */
                public registerStakingKey?: (TW.Cardano.Proto.IRegisterStakingKey|null);

                /** SigningInput delegate. */
                public delegate?: (TW.Cardano.Proto.IDelegate|null);

                /** SigningInput withdraw. */
                public withdraw?: (TW.Cardano.Proto.IWithdraw|null);

                /** SigningInput deregisterStakingKey. */
                public deregisterStakingKey?: (TW.Cardano.Proto.IDeregisterStakingKey|null);

                /** SigningInput ttl. */
                public ttl: Long;

                /** SigningInput plan. */
                public plan?: (TW.Cardano.Proto.ITransactionPlan|null);

                /** SigningInput extraOutputs. */
                public extraOutputs: TW.Cardano.Proto.ITxOutput[];

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Cardano.Proto.ISigningInput): TW.Cardano.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Cardano.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput txId */
                txId?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cardano.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput txId. */
                public txId: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Cardano.Proto.ISigningOutput): TW.Cardano.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Cardano.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cardano.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cardano.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cardano.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cardano.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Cosmos. */
    namespace Cosmos {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of an Amount. */
            interface IAmount {

                /** Amount denom */
                denom?: (string|null);

                /** Amount amount */
                amount?: (string|null);
            }

            /** Represents an Amount. */
            class Amount implements IAmount {

                /**
                 * Constructs a new Amount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.IAmount);

                /** Amount denom. */
                public denom: string;

                /** Amount amount. */
                public amount: string;

                /**
                 * Creates a new Amount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Amount instance
                 */
                public static create(properties?: TW.Cosmos.Proto.IAmount): TW.Cosmos.Proto.Amount;

                /**
                 * Encodes the specified Amount message. Does not implicitly {@link TW.Cosmos.Proto.Amount.verify|verify} messages.
                 * @param message Amount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.IAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Amount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Amount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Amount;

                /**
                 * Verifies an Amount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Amount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Amount;

                /**
                 * Creates a plain object from an Amount message. Also converts values to other types if specified.
                 * @param message Amount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.Amount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Amount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Fee. */
            interface IFee {

                /** Fee amounts */
                amounts?: (TW.Cosmos.Proto.IAmount[]|null);

                /** Fee gas */
                gas?: (Long|null);
            }

            /** Represents a Fee. */
            class Fee implements IFee {

                /**
                 * Constructs a new Fee.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.IFee);

                /** Fee amounts. */
                public amounts: TW.Cosmos.Proto.IAmount[];

                /** Fee gas. */
                public gas: Long;

                /**
                 * Creates a new Fee instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Fee instance
                 */
                public static create(properties?: TW.Cosmos.Proto.IFee): TW.Cosmos.Proto.Fee;

                /**
                 * Encodes the specified Fee message. Does not implicitly {@link TW.Cosmos.Proto.Fee.verify|verify} messages.
                 * @param message Fee message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.IFee, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Fee message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Fee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Fee;

                /**
                 * Verifies a Fee message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Fee
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Fee;

                /**
                 * Creates a plain object from a Fee message. Also converts values to other types if specified.
                 * @param message Fee
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.Fee, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Fee to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Height. */
            interface IHeight {

                /** Height revisionNumber */
                revisionNumber?: (Long|null);

                /** Height revisionHeight */
                revisionHeight?: (Long|null);
            }

            /** Represents an Height. */
            class Height implements IHeight {

                /**
                 * Constructs a new Height.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.IHeight);

                /** Height revisionNumber. */
                public revisionNumber: Long;

                /** Height revisionHeight. */
                public revisionHeight: Long;

                /**
                 * Creates a new Height instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Height instance
                 */
                public static create(properties?: TW.Cosmos.Proto.IHeight): TW.Cosmos.Proto.Height;

                /**
                 * Encodes the specified Height message. Does not implicitly {@link TW.Cosmos.Proto.Height.verify|verify} messages.
                 * @param message Height message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.IHeight, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Height message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Height
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Height;

                /**
                 * Verifies an Height message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Height message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Height
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Height;

                /**
                 * Creates a plain object from an Height message. Also converts values to other types if specified.
                 * @param message Height
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.Height, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Height to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** BroadcastMode enum. */
            enum BroadcastMode {
                BLOCK = 0,
                SYNC = 1,
                ASYNC = 2
            }

            /** Properties of a THORChainAsset. */
            interface ITHORChainAsset {

                /** THORChainAsset chain */
                chain?: (string|null);

                /** THORChainAsset symbol */
                symbol?: (string|null);

                /** THORChainAsset ticker */
                ticker?: (string|null);

                /** THORChainAsset synth */
                synth?: (boolean|null);
            }

            /** Represents a THORChainAsset. */
            class THORChainAsset implements ITHORChainAsset {

                /**
                 * Constructs a new THORChainAsset.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.ITHORChainAsset);

                /** THORChainAsset chain. */
                public chain: string;

                /** THORChainAsset symbol. */
                public symbol: string;

                /** THORChainAsset ticker. */
                public ticker: string;

                /** THORChainAsset synth. */
                public synth: boolean;

                /**
                 * Creates a new THORChainAsset instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns THORChainAsset instance
                 */
                public static create(properties?: TW.Cosmos.Proto.ITHORChainAsset): TW.Cosmos.Proto.THORChainAsset;

                /**
                 * Encodes the specified THORChainAsset message. Does not implicitly {@link TW.Cosmos.Proto.THORChainAsset.verify|verify} messages.
                 * @param message THORChainAsset message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.ITHORChainAsset, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a THORChainAsset message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns THORChainAsset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.THORChainAsset;

                /**
                 * Verifies a THORChainAsset message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a THORChainAsset message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns THORChainAsset
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.THORChainAsset;

                /**
                 * Creates a plain object from a THORChainAsset message. Also converts values to other types if specified.
                 * @param message THORChainAsset
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.THORChainAsset, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this THORChainAsset to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a THORChainCoin. */
            interface ITHORChainCoin {

                /** THORChainCoin asset */
                asset?: (TW.Cosmos.Proto.ITHORChainAsset|null);

                /** THORChainCoin amount */
                amount?: (string|null);

                /** THORChainCoin decimals */
                decimals?: (Long|null);
            }

            /** Represents a THORChainCoin. */
            class THORChainCoin implements ITHORChainCoin {

                /**
                 * Constructs a new THORChainCoin.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.ITHORChainCoin);

                /** THORChainCoin asset. */
                public asset?: (TW.Cosmos.Proto.ITHORChainAsset|null);

                /** THORChainCoin amount. */
                public amount: string;

                /** THORChainCoin decimals. */
                public decimals: Long;

                /**
                 * Creates a new THORChainCoin instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns THORChainCoin instance
                 */
                public static create(properties?: TW.Cosmos.Proto.ITHORChainCoin): TW.Cosmos.Proto.THORChainCoin;

                /**
                 * Encodes the specified THORChainCoin message. Does not implicitly {@link TW.Cosmos.Proto.THORChainCoin.verify|verify} messages.
                 * @param message THORChainCoin message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.ITHORChainCoin, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a THORChainCoin message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns THORChainCoin
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.THORChainCoin;

                /**
                 * Verifies a THORChainCoin message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a THORChainCoin message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns THORChainCoin
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.THORChainCoin;

                /**
                 * Creates a plain object from a THORChainCoin message. Also converts values to other types if specified.
                 * @param message THORChainCoin
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.THORChainCoin, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this THORChainCoin to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Message. */
            interface IMessage {

                /** Message sendCoinsMessage */
                sendCoinsMessage?: (TW.Cosmos.Proto.Message.ISend|null);

                /** Message transferTokensMessage */
                transferTokensMessage?: (TW.Cosmos.Proto.Message.ITransfer|null);

                /** Message stakeMessage */
                stakeMessage?: (TW.Cosmos.Proto.Message.IDelegate|null);

                /** Message unstakeMessage */
                unstakeMessage?: (TW.Cosmos.Proto.Message.IUndelegate|null);

                /** Message restakeMessage */
                restakeMessage?: (TW.Cosmos.Proto.Message.IBeginRedelegate|null);

                /** Message withdrawStakeRewardMessage */
                withdrawStakeRewardMessage?: (TW.Cosmos.Proto.Message.IWithdrawDelegationReward|null);

                /** Message rawJsonMessage */
                rawJsonMessage?: (TW.Cosmos.Proto.Message.IRawJSON|null);

                /** Message wasmTerraExecuteContractTransferMessage */
                wasmTerraExecuteContractTransferMessage?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer|null);

                /** Message wasmTerraExecuteContractSendMessage */
                wasmTerraExecuteContractSendMessage?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend|null);

                /** Message thorchainSendMessage */
                thorchainSendMessage?: (TW.Cosmos.Proto.Message.ITHORChainSend|null);

                /** Message executeContractMessage */
                executeContractMessage?: (TW.Cosmos.Proto.Message.IExecuteContract|null);

                /** Message wasmTerraExecuteContractGeneric */
                wasmTerraExecuteContractGeneric?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric|null);

                /** Message wasmExecuteContractTransferMessage */
                wasmExecuteContractTransferMessage?: (TW.Cosmos.Proto.Message.IWasmExecuteContractTransfer|null);

                /** Message wasmExecuteContractSendMessage */
                wasmExecuteContractSendMessage?: (TW.Cosmos.Proto.Message.IWasmExecuteContractSend|null);

                /** Message wasmExecuteContractGeneric */
                wasmExecuteContractGeneric?: (TW.Cosmos.Proto.Message.IWasmExecuteContractGeneric|null);

                /** Message signDirectMessage */
                signDirectMessage?: (TW.Cosmos.Proto.Message.ISignDirect|null);

                /** Message authGrant */
                authGrant?: (TW.Cosmos.Proto.Message.IAuthGrant|null);

                /** Message authRevoke */
                authRevoke?: (TW.Cosmos.Proto.Message.IAuthRevoke|null);

                /** Message setWithdrawAddressMessage */
                setWithdrawAddressMessage?: (TW.Cosmos.Proto.Message.ISetWithdrawAddress|null);

                /** Message msgVote */
                msgVote?: (TW.Cosmos.Proto.Message.IMsgVote|null);

                /** Message msgStrideLiquidStakingStake */
                msgStrideLiquidStakingStake?: (TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingStake|null);

                /** Message msgStrideLiquidStakingRedeem */
                msgStrideLiquidStakingRedeem?: (TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingRedeem|null);

                /** Message thorchainDepositMessage */
                thorchainDepositMessage?: (TW.Cosmos.Proto.Message.ITHORChainDeposit|null);
            }

            /** Represents a Message. */
            class Message implements IMessage {

                /**
                 * Constructs a new Message.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.IMessage);

                /** Message sendCoinsMessage. */
                public sendCoinsMessage?: (TW.Cosmos.Proto.Message.ISend|null);

                /** Message transferTokensMessage. */
                public transferTokensMessage?: (TW.Cosmos.Proto.Message.ITransfer|null);

                /** Message stakeMessage. */
                public stakeMessage?: (TW.Cosmos.Proto.Message.IDelegate|null);

                /** Message unstakeMessage. */
                public unstakeMessage?: (TW.Cosmos.Proto.Message.IUndelegate|null);

                /** Message restakeMessage. */
                public restakeMessage?: (TW.Cosmos.Proto.Message.IBeginRedelegate|null);

                /** Message withdrawStakeRewardMessage. */
                public withdrawStakeRewardMessage?: (TW.Cosmos.Proto.Message.IWithdrawDelegationReward|null);

                /** Message rawJsonMessage. */
                public rawJsonMessage?: (TW.Cosmos.Proto.Message.IRawJSON|null);

                /** Message wasmTerraExecuteContractTransferMessage. */
                public wasmTerraExecuteContractTransferMessage?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer|null);

                /** Message wasmTerraExecuteContractSendMessage. */
                public wasmTerraExecuteContractSendMessage?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend|null);

                /** Message thorchainSendMessage. */
                public thorchainSendMessage?: (TW.Cosmos.Proto.Message.ITHORChainSend|null);

                /** Message executeContractMessage. */
                public executeContractMessage?: (TW.Cosmos.Proto.Message.IExecuteContract|null);

                /** Message wasmTerraExecuteContractGeneric. */
                public wasmTerraExecuteContractGeneric?: (TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric|null);

                /** Message wasmExecuteContractTransferMessage. */
                public wasmExecuteContractTransferMessage?: (TW.Cosmos.Proto.Message.IWasmExecuteContractTransfer|null);

                /** Message wasmExecuteContractSendMessage. */
                public wasmExecuteContractSendMessage?: (TW.Cosmos.Proto.Message.IWasmExecuteContractSend|null);

                /** Message wasmExecuteContractGeneric. */
                public wasmExecuteContractGeneric?: (TW.Cosmos.Proto.Message.IWasmExecuteContractGeneric|null);

                /** Message signDirectMessage. */
                public signDirectMessage?: (TW.Cosmos.Proto.Message.ISignDirect|null);

                /** Message authGrant. */
                public authGrant?: (TW.Cosmos.Proto.Message.IAuthGrant|null);

                /** Message authRevoke. */
                public authRevoke?: (TW.Cosmos.Proto.Message.IAuthRevoke|null);

                /** Message setWithdrawAddressMessage. */
                public setWithdrawAddressMessage?: (TW.Cosmos.Proto.Message.ISetWithdrawAddress|null);

                /** Message msgVote. */
                public msgVote?: (TW.Cosmos.Proto.Message.IMsgVote|null);

                /** Message msgStrideLiquidStakingStake. */
                public msgStrideLiquidStakingStake?: (TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingStake|null);

                /** Message msgStrideLiquidStakingRedeem. */
                public msgStrideLiquidStakingRedeem?: (TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingRedeem|null);

                /** Message thorchainDepositMessage. */
                public thorchainDepositMessage?: (TW.Cosmos.Proto.Message.ITHORChainDeposit|null);

                /** Message messageOneof. */
                public messageOneof?: ("sendCoinsMessage"|"transferTokensMessage"|"stakeMessage"|"unstakeMessage"|"restakeMessage"|"withdrawStakeRewardMessage"|"rawJsonMessage"|"wasmTerraExecuteContractTransferMessage"|"wasmTerraExecuteContractSendMessage"|"thorchainSendMessage"|"executeContractMessage"|"wasmTerraExecuteContractGeneric"|"wasmExecuteContractTransferMessage"|"wasmExecuteContractSendMessage"|"wasmExecuteContractGeneric"|"signDirectMessage"|"authGrant"|"authRevoke"|"setWithdrawAddressMessage"|"msgVote"|"msgStrideLiquidStakingStake"|"msgStrideLiquidStakingRedeem"|"thorchainDepositMessage");

                /**
                 * Creates a new Message instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Message instance
                 */
                public static create(properties?: TW.Cosmos.Proto.IMessage): TW.Cosmos.Proto.Message;

                /**
                 * Encodes the specified Message message. Does not implicitly {@link TW.Cosmos.Proto.Message.verify|verify} messages.
                 * @param message Message message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message;

                /**
                 * Verifies a Message message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Message
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message;

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @param message Message
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.Message, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Message to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Message {

                /** Properties of a Send. */
                interface ISend {

                    /** Send fromAddress */
                    fromAddress?: (string|null);

                    /** Send toAddress */
                    toAddress?: (string|null);

                    /** Send amounts */
                    amounts?: (TW.Cosmos.Proto.IAmount[]|null);

                    /** Send typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a Send. */
                class Send implements ISend {

                    /**
                     * Constructs a new Send.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ISend);

                    /** Send fromAddress. */
                    public fromAddress: string;

                    /** Send toAddress. */
                    public toAddress: string;

                    /** Send amounts. */
                    public amounts: TW.Cosmos.Proto.IAmount[];

                    /** Send typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new Send instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Send instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ISend): TW.Cosmos.Proto.Message.Send;

                    /**
                     * Encodes the specified Send message. Does not implicitly {@link TW.Cosmos.Proto.Message.Send.verify|verify} messages.
                     * @param message Send message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ISend, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Send message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Send
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.Send;

                    /**
                     * Verifies a Send message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Send message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Send
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.Send;

                    /**
                     * Creates a plain object from a Send message. Also converts values to other types if specified.
                     * @param message Send
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.Send, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Send to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer sourcePort */
                    sourcePort?: (string|null);

                    /** Transfer sourceChannel */
                    sourceChannel?: (string|null);

                    /** Transfer token */
                    token?: (TW.Cosmos.Proto.IAmount|null);

                    /** Transfer sender */
                    sender?: (string|null);

                    /** Transfer receiver */
                    receiver?: (string|null);

                    /** Transfer timeoutHeight */
                    timeoutHeight?: (TW.Cosmos.Proto.IHeight|null);

                    /** Transfer timeoutTimestamp */
                    timeoutTimestamp?: (Long|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ITransfer);

                    /** Transfer sourcePort. */
                    public sourcePort: string;

                    /** Transfer sourceChannel. */
                    public sourceChannel: string;

                    /** Transfer token. */
                    public token?: (TW.Cosmos.Proto.IAmount|null);

                    /** Transfer sender. */
                    public sender: string;

                    /** Transfer receiver. */
                    public receiver: string;

                    /** Transfer timeoutHeight. */
                    public timeoutHeight?: (TW.Cosmos.Proto.IHeight|null);

                    /** Transfer timeoutTimestamp. */
                    public timeoutTimestamp: Long;

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ITransfer): TW.Cosmos.Proto.Message.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Cosmos.Proto.Message.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Delegate. */
                interface IDelegate {

                    /** Delegate delegatorAddress */
                    delegatorAddress?: (string|null);

                    /** Delegate validatorAddress */
                    validatorAddress?: (string|null);

                    /** Delegate amount */
                    amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** Delegate typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a Delegate. */
                class Delegate implements IDelegate {

                    /**
                     * Constructs a new Delegate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IDelegate);

                    /** Delegate delegatorAddress. */
                    public delegatorAddress: string;

                    /** Delegate validatorAddress. */
                    public validatorAddress: string;

                    /** Delegate amount. */
                    public amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** Delegate typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new Delegate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Delegate instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IDelegate): TW.Cosmos.Proto.Message.Delegate;

                    /**
                     * Encodes the specified Delegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.Delegate.verify|verify} messages.
                     * @param message Delegate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IDelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Delegate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Delegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.Delegate;

                    /**
                     * Verifies a Delegate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Delegate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Delegate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.Delegate;

                    /**
                     * Creates a plain object from a Delegate message. Also converts values to other types if specified.
                     * @param message Delegate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.Delegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Delegate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an Undelegate. */
                interface IUndelegate {

                    /** Undelegate delegatorAddress */
                    delegatorAddress?: (string|null);

                    /** Undelegate validatorAddress */
                    validatorAddress?: (string|null);

                    /** Undelegate amount */
                    amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** Undelegate typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents an Undelegate. */
                class Undelegate implements IUndelegate {

                    /**
                     * Constructs a new Undelegate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IUndelegate);

                    /** Undelegate delegatorAddress. */
                    public delegatorAddress: string;

                    /** Undelegate validatorAddress. */
                    public validatorAddress: string;

                    /** Undelegate amount. */
                    public amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** Undelegate typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new Undelegate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Undelegate instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IUndelegate): TW.Cosmos.Proto.Message.Undelegate;

                    /**
                     * Encodes the specified Undelegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.Undelegate.verify|verify} messages.
                     * @param message Undelegate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IUndelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an Undelegate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Undelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.Undelegate;

                    /**
                     * Verifies an Undelegate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an Undelegate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Undelegate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.Undelegate;

                    /**
                     * Creates a plain object from an Undelegate message. Also converts values to other types if specified.
                     * @param message Undelegate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.Undelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Undelegate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BeginRedelegate. */
                interface IBeginRedelegate {

                    /** BeginRedelegate delegatorAddress */
                    delegatorAddress?: (string|null);

                    /** BeginRedelegate validatorSrcAddress */
                    validatorSrcAddress?: (string|null);

                    /** BeginRedelegate validatorDstAddress */
                    validatorDstAddress?: (string|null);

                    /** BeginRedelegate amount */
                    amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** BeginRedelegate typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a BeginRedelegate. */
                class BeginRedelegate implements IBeginRedelegate {

                    /**
                     * Constructs a new BeginRedelegate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IBeginRedelegate);

                    /** BeginRedelegate delegatorAddress. */
                    public delegatorAddress: string;

                    /** BeginRedelegate validatorSrcAddress. */
                    public validatorSrcAddress: string;

                    /** BeginRedelegate validatorDstAddress. */
                    public validatorDstAddress: string;

                    /** BeginRedelegate amount. */
                    public amount?: (TW.Cosmos.Proto.IAmount|null);

                    /** BeginRedelegate typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new BeginRedelegate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BeginRedelegate instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IBeginRedelegate): TW.Cosmos.Proto.Message.BeginRedelegate;

                    /**
                     * Encodes the specified BeginRedelegate message. Does not implicitly {@link TW.Cosmos.Proto.Message.BeginRedelegate.verify|verify} messages.
                     * @param message BeginRedelegate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IBeginRedelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BeginRedelegate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BeginRedelegate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.BeginRedelegate;

                    /**
                     * Verifies a BeginRedelegate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BeginRedelegate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BeginRedelegate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.BeginRedelegate;

                    /**
                     * Creates a plain object from a BeginRedelegate message. Also converts values to other types if specified.
                     * @param message BeginRedelegate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.BeginRedelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BeginRedelegate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a SetWithdrawAddress. */
                interface ISetWithdrawAddress {

                    /** SetWithdrawAddress delegatorAddress */
                    delegatorAddress?: (string|null);

                    /** SetWithdrawAddress withdrawAddress */
                    withdrawAddress?: (string|null);

                    /** SetWithdrawAddress typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a SetWithdrawAddress. */
                class SetWithdrawAddress implements ISetWithdrawAddress {

                    /**
                     * Constructs a new SetWithdrawAddress.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ISetWithdrawAddress);

                    /** SetWithdrawAddress delegatorAddress. */
                    public delegatorAddress: string;

                    /** SetWithdrawAddress withdrawAddress. */
                    public withdrawAddress: string;

                    /** SetWithdrawAddress typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new SetWithdrawAddress instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns SetWithdrawAddress instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ISetWithdrawAddress): TW.Cosmos.Proto.Message.SetWithdrawAddress;

                    /**
                     * Encodes the specified SetWithdrawAddress message. Does not implicitly {@link TW.Cosmos.Proto.Message.SetWithdrawAddress.verify|verify} messages.
                     * @param message SetWithdrawAddress message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ISetWithdrawAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a SetWithdrawAddress message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns SetWithdrawAddress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.SetWithdrawAddress;

                    /**
                     * Verifies a SetWithdrawAddress message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a SetWithdrawAddress message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns SetWithdrawAddress
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.SetWithdrawAddress;

                    /**
                     * Creates a plain object from a SetWithdrawAddress message. Also converts values to other types if specified.
                     * @param message SetWithdrawAddress
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.SetWithdrawAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this SetWithdrawAddress to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WithdrawDelegationReward. */
                interface IWithdrawDelegationReward {

                    /** WithdrawDelegationReward delegatorAddress */
                    delegatorAddress?: (string|null);

                    /** WithdrawDelegationReward validatorAddress */
                    validatorAddress?: (string|null);

                    /** WithdrawDelegationReward typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a WithdrawDelegationReward. */
                class WithdrawDelegationReward implements IWithdrawDelegationReward {

                    /**
                     * Constructs a new WithdrawDelegationReward.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWithdrawDelegationReward);

                    /** WithdrawDelegationReward delegatorAddress. */
                    public delegatorAddress: string;

                    /** WithdrawDelegationReward validatorAddress. */
                    public validatorAddress: string;

                    /** WithdrawDelegationReward typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new WithdrawDelegationReward instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WithdrawDelegationReward instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWithdrawDelegationReward): TW.Cosmos.Proto.Message.WithdrawDelegationReward;

                    /**
                     * Encodes the specified WithdrawDelegationReward message. Does not implicitly {@link TW.Cosmos.Proto.Message.WithdrawDelegationReward.verify|verify} messages.
                     * @param message WithdrawDelegationReward message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWithdrawDelegationReward, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WithdrawDelegationReward message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WithdrawDelegationReward
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WithdrawDelegationReward;

                    /**
                     * Verifies a WithdrawDelegationReward message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WithdrawDelegationReward message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WithdrawDelegationReward
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WithdrawDelegationReward;

                    /**
                     * Creates a plain object from a WithdrawDelegationReward message. Also converts values to other types if specified.
                     * @param message WithdrawDelegationReward
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WithdrawDelegationReward, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WithdrawDelegationReward to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an ExecuteContract. */
                interface IExecuteContract {

                    /** ExecuteContract sender */
                    sender?: (string|null);

                    /** ExecuteContract contract */
                    contract?: (string|null);

                    /** ExecuteContract executeMsg */
                    executeMsg?: (string|null);

                    /** ExecuteContract coins */
                    coins?: (TW.Cosmos.Proto.IAmount[]|null);

                    /** ExecuteContract typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents an ExecuteContract. */
                class ExecuteContract implements IExecuteContract {

                    /**
                     * Constructs a new ExecuteContract.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IExecuteContract);

                    /** ExecuteContract sender. */
                    public sender: string;

                    /** ExecuteContract contract. */
                    public contract: string;

                    /** ExecuteContract executeMsg. */
                    public executeMsg: string;

                    /** ExecuteContract coins. */
                    public coins: TW.Cosmos.Proto.IAmount[];

                    /** ExecuteContract typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new ExecuteContract instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ExecuteContract instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IExecuteContract): TW.Cosmos.Proto.Message.ExecuteContract;

                    /**
                     * Encodes the specified ExecuteContract message. Does not implicitly {@link TW.Cosmos.Proto.Message.ExecuteContract.verify|verify} messages.
                     * @param message ExecuteContract message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IExecuteContract, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an ExecuteContract message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ExecuteContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.ExecuteContract;

                    /**
                     * Verifies an ExecuteContract message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an ExecuteContract message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ExecuteContract
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.ExecuteContract;

                    /**
                     * Creates a plain object from an ExecuteContract message. Also converts values to other types if specified.
                     * @param message ExecuteContract
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.ExecuteContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ExecuteContract to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmTerraExecuteContractTransfer. */
                interface IWasmTerraExecuteContractTransfer {

                    /** WasmTerraExecuteContractTransfer senderAddress */
                    senderAddress?: (string|null);

                    /** WasmTerraExecuteContractTransfer contractAddress */
                    contractAddress?: (string|null);

                    /** WasmTerraExecuteContractTransfer amount */
                    amount?: (Uint8Array|null);

                    /** WasmTerraExecuteContractTransfer recipientAddress */
                    recipientAddress?: (string|null);
                }

                /** Represents a WasmTerraExecuteContractTransfer. */
                class WasmTerraExecuteContractTransfer implements IWasmTerraExecuteContractTransfer {

                    /**
                     * Constructs a new WasmTerraExecuteContractTransfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer);

                    /** WasmTerraExecuteContractTransfer senderAddress. */
                    public senderAddress: string;

                    /** WasmTerraExecuteContractTransfer contractAddress. */
                    public contractAddress: string;

                    /** WasmTerraExecuteContractTransfer amount. */
                    public amount: Uint8Array;

                    /** WasmTerraExecuteContractTransfer recipientAddress. */
                    public recipientAddress: string;

                    /**
                     * Creates a new WasmTerraExecuteContractTransfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmTerraExecuteContractTransfer instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer): TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer;

                    /**
                     * Encodes the specified WasmTerraExecuteContractTransfer message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer.verify|verify} messages.
                     * @param message WasmTerraExecuteContractTransfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmTerraExecuteContractTransfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmTerraExecuteContractTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer;

                    /**
                     * Verifies a WasmTerraExecuteContractTransfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmTerraExecuteContractTransfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmTerraExecuteContractTransfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer;

                    /**
                     * Creates a plain object from a WasmTerraExecuteContractTransfer message. Also converts values to other types if specified.
                     * @param message WasmTerraExecuteContractTransfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmTerraExecuteContractTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmTerraExecuteContractTransfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmTerraExecuteContractSend. */
                interface IWasmTerraExecuteContractSend {

                    /** WasmTerraExecuteContractSend senderAddress */
                    senderAddress?: (string|null);

                    /** WasmTerraExecuteContractSend contractAddress */
                    contractAddress?: (string|null);

                    /** WasmTerraExecuteContractSend amount */
                    amount?: (Uint8Array|null);

                    /** WasmTerraExecuteContractSend recipientContractAddress */
                    recipientContractAddress?: (string|null);

                    /** WasmTerraExecuteContractSend msg */
                    msg?: (string|null);

                    /** WasmTerraExecuteContractSend coin */
                    coin?: (string[]|null);
                }

                /** Represents a WasmTerraExecuteContractSend. */
                class WasmTerraExecuteContractSend implements IWasmTerraExecuteContractSend {

                    /**
                     * Constructs a new WasmTerraExecuteContractSend.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend);

                    /** WasmTerraExecuteContractSend senderAddress. */
                    public senderAddress: string;

                    /** WasmTerraExecuteContractSend contractAddress. */
                    public contractAddress: string;

                    /** WasmTerraExecuteContractSend amount. */
                    public amount: Uint8Array;

                    /** WasmTerraExecuteContractSend recipientContractAddress. */
                    public recipientContractAddress: string;

                    /** WasmTerraExecuteContractSend msg. */
                    public msg: string;

                    /** WasmTerraExecuteContractSend coin. */
                    public coin: string[];

                    /**
                     * Creates a new WasmTerraExecuteContractSend instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmTerraExecuteContractSend instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend): TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend;

                    /**
                     * Encodes the specified WasmTerraExecuteContractSend message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend.verify|verify} messages.
                     * @param message WasmTerraExecuteContractSend message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractSend, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmTerraExecuteContractSend message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmTerraExecuteContractSend
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend;

                    /**
                     * Verifies a WasmTerraExecuteContractSend message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmTerraExecuteContractSend message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmTerraExecuteContractSend
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend;

                    /**
                     * Creates a plain object from a WasmTerraExecuteContractSend message. Also converts values to other types if specified.
                     * @param message WasmTerraExecuteContractSend
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmTerraExecuteContractSend, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmTerraExecuteContractSend to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a THORChainSend. */
                interface ITHORChainSend {

                    /** THORChainSend fromAddress */
                    fromAddress?: (Uint8Array|null);

                    /** THORChainSend toAddress */
                    toAddress?: (Uint8Array|null);

                    /** THORChainSend amounts */
                    amounts?: (TW.Cosmos.Proto.IAmount[]|null);
                }

                /** Represents a THORChainSend. */
                class THORChainSend implements ITHORChainSend {

                    /**
                     * Constructs a new THORChainSend.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ITHORChainSend);

                    /** THORChainSend fromAddress. */
                    public fromAddress: Uint8Array;

                    /** THORChainSend toAddress. */
                    public toAddress: Uint8Array;

                    /** THORChainSend amounts. */
                    public amounts: TW.Cosmos.Proto.IAmount[];

                    /**
                     * Creates a new THORChainSend instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns THORChainSend instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ITHORChainSend): TW.Cosmos.Proto.Message.THORChainSend;

                    /**
                     * Encodes the specified THORChainSend message. Does not implicitly {@link TW.Cosmos.Proto.Message.THORChainSend.verify|verify} messages.
                     * @param message THORChainSend message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ITHORChainSend, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a THORChainSend message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns THORChainSend
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.THORChainSend;

                    /**
                     * Verifies a THORChainSend message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a THORChainSend message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns THORChainSend
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.THORChainSend;

                    /**
                     * Creates a plain object from a THORChainSend message. Also converts values to other types if specified.
                     * @param message THORChainSend
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.THORChainSend, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this THORChainSend to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a THORChainDeposit. */
                interface ITHORChainDeposit {

                    /** THORChainDeposit coins */
                    coins?: (TW.Cosmos.Proto.ITHORChainCoin[]|null);

                    /** THORChainDeposit memo */
                    memo?: (string|null);

                    /** THORChainDeposit signer */
                    signer?: (Uint8Array|null);
                }

                /** Represents a THORChainDeposit. */
                class THORChainDeposit implements ITHORChainDeposit {

                    /**
                     * Constructs a new THORChainDeposit.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ITHORChainDeposit);

                    /** THORChainDeposit coins. */
                    public coins: TW.Cosmos.Proto.ITHORChainCoin[];

                    /** THORChainDeposit memo. */
                    public memo: string;

                    /** THORChainDeposit signer. */
                    public signer: Uint8Array;

                    /**
                     * Creates a new THORChainDeposit instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns THORChainDeposit instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ITHORChainDeposit): TW.Cosmos.Proto.Message.THORChainDeposit;

                    /**
                     * Encodes the specified THORChainDeposit message. Does not implicitly {@link TW.Cosmos.Proto.Message.THORChainDeposit.verify|verify} messages.
                     * @param message THORChainDeposit message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ITHORChainDeposit, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a THORChainDeposit message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns THORChainDeposit
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.THORChainDeposit;

                    /**
                     * Verifies a THORChainDeposit message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a THORChainDeposit message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns THORChainDeposit
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.THORChainDeposit;

                    /**
                     * Creates a plain object from a THORChainDeposit message. Also converts values to other types if specified.
                     * @param message THORChainDeposit
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.THORChainDeposit, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this THORChainDeposit to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmTerraExecuteContractGeneric. */
                interface IWasmTerraExecuteContractGeneric {

                    /** WasmTerraExecuteContractGeneric senderAddress */
                    senderAddress?: (string|null);

                    /** WasmTerraExecuteContractGeneric contractAddress */
                    contractAddress?: (string|null);

                    /** WasmTerraExecuteContractGeneric executeMsg */
                    executeMsg?: (string|null);

                    /** WasmTerraExecuteContractGeneric coins */
                    coins?: (TW.Cosmos.Proto.IAmount[]|null);
                }

                /** Represents a WasmTerraExecuteContractGeneric. */
                class WasmTerraExecuteContractGeneric implements IWasmTerraExecuteContractGeneric {

                    /**
                     * Constructs a new WasmTerraExecuteContractGeneric.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric);

                    /** WasmTerraExecuteContractGeneric senderAddress. */
                    public senderAddress: string;

                    /** WasmTerraExecuteContractGeneric contractAddress. */
                    public contractAddress: string;

                    /** WasmTerraExecuteContractGeneric executeMsg. */
                    public executeMsg: string;

                    /** WasmTerraExecuteContractGeneric coins. */
                    public coins: TW.Cosmos.Proto.IAmount[];

                    /**
                     * Creates a new WasmTerraExecuteContractGeneric instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmTerraExecuteContractGeneric instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric): TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric;

                    /**
                     * Encodes the specified WasmTerraExecuteContractGeneric message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric.verify|verify} messages.
                     * @param message WasmTerraExecuteContractGeneric message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmTerraExecuteContractGeneric, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmTerraExecuteContractGeneric message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmTerraExecuteContractGeneric
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric;

                    /**
                     * Verifies a WasmTerraExecuteContractGeneric message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmTerraExecuteContractGeneric message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmTerraExecuteContractGeneric
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric;

                    /**
                     * Creates a plain object from a WasmTerraExecuteContractGeneric message. Also converts values to other types if specified.
                     * @param message WasmTerraExecuteContractGeneric
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmTerraExecuteContractGeneric, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmTerraExecuteContractGeneric to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmExecuteContractTransfer. */
                interface IWasmExecuteContractTransfer {

                    /** WasmExecuteContractTransfer senderAddress */
                    senderAddress?: (string|null);

                    /** WasmExecuteContractTransfer contractAddress */
                    contractAddress?: (string|null);

                    /** WasmExecuteContractTransfer amount */
                    amount?: (Uint8Array|null);

                    /** WasmExecuteContractTransfer recipientAddress */
                    recipientAddress?: (string|null);
                }

                /** Represents a WasmExecuteContractTransfer. */
                class WasmExecuteContractTransfer implements IWasmExecuteContractTransfer {

                    /**
                     * Constructs a new WasmExecuteContractTransfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractTransfer);

                    /** WasmExecuteContractTransfer senderAddress. */
                    public senderAddress: string;

                    /** WasmExecuteContractTransfer contractAddress. */
                    public contractAddress: string;

                    /** WasmExecuteContractTransfer amount. */
                    public amount: Uint8Array;

                    /** WasmExecuteContractTransfer recipientAddress. */
                    public recipientAddress: string;

                    /**
                     * Creates a new WasmExecuteContractTransfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmExecuteContractTransfer instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractTransfer): TW.Cosmos.Proto.Message.WasmExecuteContractTransfer;

                    /**
                     * Encodes the specified WasmExecuteContractTransfer message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmExecuteContractTransfer.verify|verify} messages.
                     * @param message WasmExecuteContractTransfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmExecuteContractTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmExecuteContractTransfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmExecuteContractTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmExecuteContractTransfer;

                    /**
                     * Verifies a WasmExecuteContractTransfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmExecuteContractTransfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmExecuteContractTransfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmExecuteContractTransfer;

                    /**
                     * Creates a plain object from a WasmExecuteContractTransfer message. Also converts values to other types if specified.
                     * @param message WasmExecuteContractTransfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmExecuteContractTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmExecuteContractTransfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmExecuteContractSend. */
                interface IWasmExecuteContractSend {

                    /** WasmExecuteContractSend senderAddress */
                    senderAddress?: (string|null);

                    /** WasmExecuteContractSend contractAddress */
                    contractAddress?: (string|null);

                    /** WasmExecuteContractSend amount */
                    amount?: (Uint8Array|null);

                    /** WasmExecuteContractSend recipientContractAddress */
                    recipientContractAddress?: (string|null);

                    /** WasmExecuteContractSend msg */
                    msg?: (string|null);

                    /** WasmExecuteContractSend coin */
                    coin?: (string[]|null);
                }

                /** Represents a WasmExecuteContractSend. */
                class WasmExecuteContractSend implements IWasmExecuteContractSend {

                    /**
                     * Constructs a new WasmExecuteContractSend.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractSend);

                    /** WasmExecuteContractSend senderAddress. */
                    public senderAddress: string;

                    /** WasmExecuteContractSend contractAddress. */
                    public contractAddress: string;

                    /** WasmExecuteContractSend amount. */
                    public amount: Uint8Array;

                    /** WasmExecuteContractSend recipientContractAddress. */
                    public recipientContractAddress: string;

                    /** WasmExecuteContractSend msg. */
                    public msg: string;

                    /** WasmExecuteContractSend coin. */
                    public coin: string[];

                    /**
                     * Creates a new WasmExecuteContractSend instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmExecuteContractSend instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractSend): TW.Cosmos.Proto.Message.WasmExecuteContractSend;

                    /**
                     * Encodes the specified WasmExecuteContractSend message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmExecuteContractSend.verify|verify} messages.
                     * @param message WasmExecuteContractSend message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmExecuteContractSend, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmExecuteContractSend message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmExecuteContractSend
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmExecuteContractSend;

                    /**
                     * Verifies a WasmExecuteContractSend message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmExecuteContractSend message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmExecuteContractSend
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmExecuteContractSend;

                    /**
                     * Creates a plain object from a WasmExecuteContractSend message. Also converts values to other types if specified.
                     * @param message WasmExecuteContractSend
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmExecuteContractSend, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmExecuteContractSend to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WasmExecuteContractGeneric. */
                interface IWasmExecuteContractGeneric {

                    /** WasmExecuteContractGeneric senderAddress */
                    senderAddress?: (string|null);

                    /** WasmExecuteContractGeneric contractAddress */
                    contractAddress?: (string|null);

                    /** WasmExecuteContractGeneric executeMsg */
                    executeMsg?: (string|null);

                    /** WasmExecuteContractGeneric coins */
                    coins?: (TW.Cosmos.Proto.IAmount[]|null);
                }

                /** Represents a WasmExecuteContractGeneric. */
                class WasmExecuteContractGeneric implements IWasmExecuteContractGeneric {

                    /**
                     * Constructs a new WasmExecuteContractGeneric.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractGeneric);

                    /** WasmExecuteContractGeneric senderAddress. */
                    public senderAddress: string;

                    /** WasmExecuteContractGeneric contractAddress. */
                    public contractAddress: string;

                    /** WasmExecuteContractGeneric executeMsg. */
                    public executeMsg: string;

                    /** WasmExecuteContractGeneric coins. */
                    public coins: TW.Cosmos.Proto.IAmount[];

                    /**
                     * Creates a new WasmExecuteContractGeneric instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WasmExecuteContractGeneric instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IWasmExecuteContractGeneric): TW.Cosmos.Proto.Message.WasmExecuteContractGeneric;

                    /**
                     * Encodes the specified WasmExecuteContractGeneric message. Does not implicitly {@link TW.Cosmos.Proto.Message.WasmExecuteContractGeneric.verify|verify} messages.
                     * @param message WasmExecuteContractGeneric message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IWasmExecuteContractGeneric, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WasmExecuteContractGeneric message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WasmExecuteContractGeneric
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.WasmExecuteContractGeneric;

                    /**
                     * Verifies a WasmExecuteContractGeneric message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WasmExecuteContractGeneric message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WasmExecuteContractGeneric
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.WasmExecuteContractGeneric;

                    /**
                     * Creates a plain object from a WasmExecuteContractGeneric message. Also converts values to other types if specified.
                     * @param message WasmExecuteContractGeneric
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.WasmExecuteContractGeneric, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WasmExecuteContractGeneric to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a RawJSON. */
                interface IRawJSON {

                    /** RawJSON type */
                    type?: (string|null);

                    /** RawJSON value */
                    value?: (string|null);
                }

                /** Represents a RawJSON. */
                class RawJSON implements IRawJSON {

                    /**
                     * Constructs a new RawJSON.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IRawJSON);

                    /** RawJSON type. */
                    public type: string;

                    /** RawJSON value. */
                    public value: string;

                    /**
                     * Creates a new RawJSON instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns RawJSON instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IRawJSON): TW.Cosmos.Proto.Message.RawJSON;

                    /**
                     * Encodes the specified RawJSON message. Does not implicitly {@link TW.Cosmos.Proto.Message.RawJSON.verify|verify} messages.
                     * @param message RawJSON message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IRawJSON, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a RawJSON message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns RawJSON
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.RawJSON;

                    /**
                     * Verifies a RawJSON message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a RawJSON message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns RawJSON
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.RawJSON;

                    /**
                     * Creates a plain object from a RawJSON message. Also converts values to other types if specified.
                     * @param message RawJSON
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.RawJSON, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this RawJSON to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a SignDirect. */
                interface ISignDirect {

                    /** SignDirect bodyBytes */
                    bodyBytes?: (Uint8Array|null);

                    /** SignDirect authInfoBytes */
                    authInfoBytes?: (Uint8Array|null);
                }

                /** Represents a SignDirect. */
                class SignDirect implements ISignDirect {

                    /**
                     * Constructs a new SignDirect.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.ISignDirect);

                    /** SignDirect bodyBytes. */
                    public bodyBytes: Uint8Array;

                    /** SignDirect authInfoBytes. */
                    public authInfoBytes: Uint8Array;

                    /**
                     * Creates a new SignDirect instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns SignDirect instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.ISignDirect): TW.Cosmos.Proto.Message.SignDirect;

                    /**
                     * Encodes the specified SignDirect message. Does not implicitly {@link TW.Cosmos.Proto.Message.SignDirect.verify|verify} messages.
                     * @param message SignDirect message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.ISignDirect, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a SignDirect message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns SignDirect
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.SignDirect;

                    /**
                     * Verifies a SignDirect message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a SignDirect message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns SignDirect
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.SignDirect;

                    /**
                     * Creates a plain object from a SignDirect message. Also converts values to other types if specified.
                     * @param message SignDirect
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.SignDirect, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this SignDirect to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a StakeAuthorization. */
                interface IStakeAuthorization {

                    /** StakeAuthorization maxTokens */
                    maxTokens?: (TW.Cosmos.Proto.IAmount|null);

                    /** StakeAuthorization allowList */
                    allowList?: (TW.Cosmos.Proto.Message.StakeAuthorization.IValidators|null);

                    /** StakeAuthorization denyList */
                    denyList?: (TW.Cosmos.Proto.Message.StakeAuthorization.IValidators|null);

                    /** StakeAuthorization authorizationType */
                    authorizationType?: (TW.Cosmos.Proto.Message.AuthorizationType|null);
                }

                /** Represents a StakeAuthorization. */
                class StakeAuthorization implements IStakeAuthorization {

                    /**
                     * Constructs a new StakeAuthorization.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IStakeAuthorization);

                    /** StakeAuthorization maxTokens. */
                    public maxTokens?: (TW.Cosmos.Proto.IAmount|null);

                    /** StakeAuthorization allowList. */
                    public allowList?: (TW.Cosmos.Proto.Message.StakeAuthorization.IValidators|null);

                    /** StakeAuthorization denyList. */
                    public denyList?: (TW.Cosmos.Proto.Message.StakeAuthorization.IValidators|null);

                    /** StakeAuthorization authorizationType. */
                    public authorizationType: TW.Cosmos.Proto.Message.AuthorizationType;

                    /** StakeAuthorization validators. */
                    public validators?: ("allowList"|"denyList");

                    /**
                     * Creates a new StakeAuthorization instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns StakeAuthorization instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IStakeAuthorization): TW.Cosmos.Proto.Message.StakeAuthorization;

                    /**
                     * Encodes the specified StakeAuthorization message. Does not implicitly {@link TW.Cosmos.Proto.Message.StakeAuthorization.verify|verify} messages.
                     * @param message StakeAuthorization message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IStakeAuthorization, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a StakeAuthorization message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns StakeAuthorization
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.StakeAuthorization;

                    /**
                     * Verifies a StakeAuthorization message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a StakeAuthorization message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns StakeAuthorization
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.StakeAuthorization;

                    /**
                     * Creates a plain object from a StakeAuthorization message. Also converts values to other types if specified.
                     * @param message StakeAuthorization
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.StakeAuthorization, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this StakeAuthorization to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                namespace StakeAuthorization {

                    /** Properties of a Validators. */
                    interface IValidators {

                        /** Validators address */
                        address?: (string[]|null);
                    }

                    /** Represents a Validators. */
                    class Validators implements IValidators {

                        /**
                         * Constructs a new Validators.
                         * @param [properties] Properties to set
                         */
                        constructor(properties?: TW.Cosmos.Proto.Message.StakeAuthorization.IValidators);

                        /** Validators address. */
                        public address: string[];

                        /**
                         * Creates a new Validators instance using the specified properties.
                         * @param [properties] Properties to set
                         * @returns Validators instance
                         */
                        public static create(properties?: TW.Cosmos.Proto.Message.StakeAuthorization.IValidators): TW.Cosmos.Proto.Message.StakeAuthorization.Validators;

                        /**
                         * Encodes the specified Validators message. Does not implicitly {@link TW.Cosmos.Proto.Message.StakeAuthorization.Validators.verify|verify} messages.
                         * @param message Validators message or plain object to encode
                         * @param [writer] Writer to encode to
                         * @returns Writer
                         */
                        public static encode(message: TW.Cosmos.Proto.Message.StakeAuthorization.IValidators, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes a Validators message from the specified reader or buffer.
                         * @param reader Reader or buffer to decode from
                         * @param [length] Message length if known beforehand
                         * @returns Validators
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.StakeAuthorization.Validators;

                        /**
                         * Verifies a Validators message.
                         * @param message Plain object to verify
                         * @returns `null` if valid, otherwise the reason why it is not
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates a Validators message from a plain object. Also converts values to their respective internal types.
                         * @param object Plain object
                         * @returns Validators
                         */
                        public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.StakeAuthorization.Validators;

                        /**
                         * Creates a plain object from a Validators message. Also converts values to other types if specified.
                         * @param message Validators
                         * @param [options] Conversion options
                         * @returns Plain object
                         */
                        public static toObject(message: TW.Cosmos.Proto.Message.StakeAuthorization.Validators, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Converts this Validators to JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }
                }

                /** AuthorizationType enum. */
                enum AuthorizationType {
                    UNSPECIFIED = 0,
                    DELEGATE = 1,
                    UNDELEGATE = 2,
                    REDELEGATE = 3
                }

                /** Properties of an AuthGrant. */
                interface IAuthGrant {

                    /** AuthGrant granter */
                    granter?: (string|null);

                    /** AuthGrant grantee */
                    grantee?: (string|null);

                    /** AuthGrant grantStake */
                    grantStake?: (TW.Cosmos.Proto.Message.IStakeAuthorization|null);

                    /** AuthGrant expiration */
                    expiration?: (Long|null);
                }

                /** Represents an AuthGrant. */
                class AuthGrant implements IAuthGrant {

                    /**
                     * Constructs a new AuthGrant.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IAuthGrant);

                    /** AuthGrant granter. */
                    public granter: string;

                    /** AuthGrant grantee. */
                    public grantee: string;

                    /** AuthGrant grantStake. */
                    public grantStake?: (TW.Cosmos.Proto.Message.IStakeAuthorization|null);

                    /** AuthGrant expiration. */
                    public expiration: Long;

                    /** AuthGrant grantType. */
                    public grantType?: "grantStake";

                    /**
                     * Creates a new AuthGrant instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AuthGrant instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IAuthGrant): TW.Cosmos.Proto.Message.AuthGrant;

                    /**
                     * Encodes the specified AuthGrant message. Does not implicitly {@link TW.Cosmos.Proto.Message.AuthGrant.verify|verify} messages.
                     * @param message AuthGrant message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IAuthGrant, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AuthGrant message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AuthGrant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.AuthGrant;

                    /**
                     * Verifies an AuthGrant message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AuthGrant message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AuthGrant
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.AuthGrant;

                    /**
                     * Creates a plain object from an AuthGrant message. Also converts values to other types if specified.
                     * @param message AuthGrant
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.AuthGrant, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AuthGrant to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an AuthRevoke. */
                interface IAuthRevoke {

                    /** AuthRevoke granter */
                    granter?: (string|null);

                    /** AuthRevoke grantee */
                    grantee?: (string|null);

                    /** AuthRevoke msgTypeUrl */
                    msgTypeUrl?: (string|null);
                }

                /** Represents an AuthRevoke. */
                class AuthRevoke implements IAuthRevoke {

                    /**
                     * Constructs a new AuthRevoke.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IAuthRevoke);

                    /** AuthRevoke granter. */
                    public granter: string;

                    /** AuthRevoke grantee. */
                    public grantee: string;

                    /** AuthRevoke msgTypeUrl. */
                    public msgTypeUrl: string;

                    /**
                     * Creates a new AuthRevoke instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AuthRevoke instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IAuthRevoke): TW.Cosmos.Proto.Message.AuthRevoke;

                    /**
                     * Encodes the specified AuthRevoke message. Does not implicitly {@link TW.Cosmos.Proto.Message.AuthRevoke.verify|verify} messages.
                     * @param message AuthRevoke message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IAuthRevoke, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AuthRevoke message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AuthRevoke
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.AuthRevoke;

                    /**
                     * Verifies an AuthRevoke message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AuthRevoke message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AuthRevoke
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.AuthRevoke;

                    /**
                     * Creates a plain object from an AuthRevoke message. Also converts values to other types if specified.
                     * @param message AuthRevoke
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.AuthRevoke, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AuthRevoke to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** VoteOption enum. */
                enum VoteOption {
                    _UNSPECIFIED = 0,
                    YES = 1,
                    ABSTAIN = 2,
                    NO = 3,
                    NO_WITH_VETO = 4
                }

                /** Properties of a MsgVote. */
                interface IMsgVote {

                    /** MsgVote proposalId */
                    proposalId?: (Long|null);

                    /** MsgVote voter */
                    voter?: (string|null);

                    /** MsgVote option */
                    option?: (TW.Cosmos.Proto.Message.VoteOption|null);
                }

                /** Represents a MsgVote. */
                class MsgVote implements IMsgVote {

                    /**
                     * Constructs a new MsgVote.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IMsgVote);

                    /** MsgVote proposalId. */
                    public proposalId: Long;

                    /** MsgVote voter. */
                    public voter: string;

                    /** MsgVote option. */
                    public option: TW.Cosmos.Proto.Message.VoteOption;

                    /**
                     * Creates a new MsgVote instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns MsgVote instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IMsgVote): TW.Cosmos.Proto.Message.MsgVote;

                    /**
                     * Encodes the specified MsgVote message. Does not implicitly {@link TW.Cosmos.Proto.Message.MsgVote.verify|verify} messages.
                     * @param message MsgVote message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IMsgVote, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a MsgVote message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns MsgVote
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.MsgVote;

                    /**
                     * Verifies a MsgVote message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a MsgVote message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns MsgVote
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.MsgVote;

                    /**
                     * Creates a plain object from a MsgVote message. Also converts values to other types if specified.
                     * @param message MsgVote
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.MsgVote, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this MsgVote to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a MsgStrideLiquidStakingStake. */
                interface IMsgStrideLiquidStakingStake {

                    /** MsgStrideLiquidStakingStake creator */
                    creator?: (string|null);

                    /** MsgStrideLiquidStakingStake amount */
                    amount?: (string|null);

                    /** MsgStrideLiquidStakingStake hostDenom */
                    hostDenom?: (string|null);
                }

                /** Represents a MsgStrideLiquidStakingStake. */
                class MsgStrideLiquidStakingStake implements IMsgStrideLiquidStakingStake {

                    /**
                     * Constructs a new MsgStrideLiquidStakingStake.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingStake);

                    /** MsgStrideLiquidStakingStake creator. */
                    public creator: string;

                    /** MsgStrideLiquidStakingStake amount. */
                    public amount: string;

                    /** MsgStrideLiquidStakingStake hostDenom. */
                    public hostDenom: string;

                    /**
                     * Creates a new MsgStrideLiquidStakingStake instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns MsgStrideLiquidStakingStake instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingStake): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingStake;

                    /**
                     * Encodes the specified MsgStrideLiquidStakingStake message. Does not implicitly {@link TW.Cosmos.Proto.Message.MsgStrideLiquidStakingStake.verify|verify} messages.
                     * @param message MsgStrideLiquidStakingStake message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingStake, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a MsgStrideLiquidStakingStake message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns MsgStrideLiquidStakingStake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingStake;

                    /**
                     * Verifies a MsgStrideLiquidStakingStake message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a MsgStrideLiquidStakingStake message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns MsgStrideLiquidStakingStake
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingStake;

                    /**
                     * Creates a plain object from a MsgStrideLiquidStakingStake message. Also converts values to other types if specified.
                     * @param message MsgStrideLiquidStakingStake
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.MsgStrideLiquidStakingStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this MsgStrideLiquidStakingStake to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a MsgStrideLiquidStakingRedeem. */
                interface IMsgStrideLiquidStakingRedeem {

                    /** MsgStrideLiquidStakingRedeem creator */
                    creator?: (string|null);

                    /** MsgStrideLiquidStakingRedeem amount */
                    amount?: (string|null);

                    /** MsgStrideLiquidStakingRedeem hostZone */
                    hostZone?: (string|null);

                    /** MsgStrideLiquidStakingRedeem receiver */
                    receiver?: (string|null);
                }

                /** Represents a MsgStrideLiquidStakingRedeem. */
                class MsgStrideLiquidStakingRedeem implements IMsgStrideLiquidStakingRedeem {

                    /**
                     * Constructs a new MsgStrideLiquidStakingRedeem.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingRedeem);

                    /** MsgStrideLiquidStakingRedeem creator. */
                    public creator: string;

                    /** MsgStrideLiquidStakingRedeem amount. */
                    public amount: string;

                    /** MsgStrideLiquidStakingRedeem hostZone. */
                    public hostZone: string;

                    /** MsgStrideLiquidStakingRedeem receiver. */
                    public receiver: string;

                    /**
                     * Creates a new MsgStrideLiquidStakingRedeem instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns MsgStrideLiquidStakingRedeem instance
                     */
                    public static create(properties?: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingRedeem): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingRedeem;

                    /**
                     * Encodes the specified MsgStrideLiquidStakingRedeem message. Does not implicitly {@link TW.Cosmos.Proto.Message.MsgStrideLiquidStakingRedeem.verify|verify} messages.
                     * @param message MsgStrideLiquidStakingRedeem message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Cosmos.Proto.Message.IMsgStrideLiquidStakingRedeem, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a MsgStrideLiquidStakingRedeem message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns MsgStrideLiquidStakingRedeem
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingRedeem;

                    /**
                     * Verifies a MsgStrideLiquidStakingRedeem message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a MsgStrideLiquidStakingRedeem message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns MsgStrideLiquidStakingRedeem
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.Message.MsgStrideLiquidStakingRedeem;

                    /**
                     * Creates a plain object from a MsgStrideLiquidStakingRedeem message. Also converts values to other types if specified.
                     * @param message MsgStrideLiquidStakingRedeem
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Cosmos.Proto.Message.MsgStrideLiquidStakingRedeem, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this MsgStrideLiquidStakingRedeem to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** SigningMode enum. */
            enum SigningMode {
                JSON = 0,
                Protobuf = 1
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput signingMode */
                signingMode?: (TW.Cosmos.Proto.SigningMode|null);

                /** SigningInput accountNumber */
                accountNumber?: (Long|null);

                /** SigningInput chainId */
                chainId?: (string|null);

                /** SigningInput fee */
                fee?: (TW.Cosmos.Proto.IFee|null);

                /** SigningInput memo */
                memo?: (string|null);

                /** SigningInput sequence */
                sequence?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput messages */
                messages?: (TW.Cosmos.Proto.IMessage[]|null);

                /** SigningInput mode */
                mode?: (TW.Cosmos.Proto.BroadcastMode|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.ISigningInput);

                /** SigningInput signingMode. */
                public signingMode: TW.Cosmos.Proto.SigningMode;

                /** SigningInput accountNumber. */
                public accountNumber: Long;

                /** SigningInput chainId. */
                public chainId: string;

                /** SigningInput fee. */
                public fee?: (TW.Cosmos.Proto.IFee|null);

                /** SigningInput memo. */
                public memo: string;

                /** SigningInput sequence. */
                public sequence: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput messages. */
                public messages: TW.Cosmos.Proto.IMessage[];

                /** SigningInput mode. */
                public mode: TW.Cosmos.Proto.BroadcastMode;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Cosmos.Proto.ISigningInput): TW.Cosmos.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Cosmos.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput serialized */
                serialized?: (string|null);

                /** SigningOutput signatureJson */
                signatureJson?: (string|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Cosmos.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput serialized. */
                public serialized: string;

                /** SigningOutput signatureJson. */
                public signatureJson: string;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Cosmos.Proto.ISigningOutput): TW.Cosmos.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Cosmos.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Cosmos.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Cosmos.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Cosmos.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Cosmos.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Decred. */
    namespace Decred {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction serializeType */
                serializeType?: (number|null);

                /** Transaction version */
                version?: (number|null);

                /** Transaction inputs */
                inputs?: (TW.Decred.Proto.ITransactionInput[]|null);

                /** Transaction outputs */
                outputs?: (TW.Decred.Proto.ITransactionOutput[]|null);

                /** Transaction lockTime */
                lockTime?: (number|null);

                /** Transaction expiry */
                expiry?: (number|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Decred.Proto.ITransaction);

                /** Transaction serializeType. */
                public serializeType: number;

                /** Transaction version. */
                public version: number;

                /** Transaction inputs. */
                public inputs: TW.Decred.Proto.ITransactionInput[];

                /** Transaction outputs. */
                public outputs: TW.Decred.Proto.ITransactionOutput[];

                /** Transaction lockTime. */
                public lockTime: number;

                /** Transaction expiry. */
                public expiry: number;

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Decred.Proto.ITransaction): TW.Decred.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Decred.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Decred.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Decred.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Decred.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Decred.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionInput. */
            interface ITransactionInput {

                /** TransactionInput previousOutput */
                previousOutput?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** TransactionInput sequence */
                sequence?: (number|null);

                /** TransactionInput valueIn */
                valueIn?: (Long|null);

                /** TransactionInput blockHeight */
                blockHeight?: (number|null);

                /** TransactionInput blockIndex */
                blockIndex?: (number|null);

                /** TransactionInput script */
                script?: (Uint8Array|null);
            }

            /** Represents a TransactionInput. */
            class TransactionInput implements ITransactionInput {

                /**
                 * Constructs a new TransactionInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Decred.Proto.ITransactionInput);

                /** TransactionInput previousOutput. */
                public previousOutput?: (TW.Bitcoin.Proto.IOutPoint|null);

                /** TransactionInput sequence. */
                public sequence: number;

                /** TransactionInput valueIn. */
                public valueIn: Long;

                /** TransactionInput blockHeight. */
                public blockHeight: number;

                /** TransactionInput blockIndex. */
                public blockIndex: number;

                /** TransactionInput script. */
                public script: Uint8Array;

                /**
                 * Creates a new TransactionInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionInput instance
                 */
                public static create(properties?: TW.Decred.Proto.ITransactionInput): TW.Decred.Proto.TransactionInput;

                /**
                 * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Decred.Proto.TransactionInput.verify|verify} messages.
                 * @param message TransactionInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Decred.Proto.ITransactionInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Decred.Proto.TransactionInput;

                /**
                 * Verifies a TransactionInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Decred.Proto.TransactionInput;

                /**
                 * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                 * @param message TransactionInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Decred.Proto.TransactionInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOutput. */
            interface ITransactionOutput {

                /** TransactionOutput value */
                value?: (Long|null);

                /** TransactionOutput version */
                version?: (number|null);

                /** TransactionOutput script */
                script?: (Uint8Array|null);
            }

            /** Represents a TransactionOutput. */
            class TransactionOutput implements ITransactionOutput {

                /**
                 * Constructs a new TransactionOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Decred.Proto.ITransactionOutput);

                /** TransactionOutput value. */
                public value: Long;

                /** TransactionOutput version. */
                public version: number;

                /** TransactionOutput script. */
                public script: Uint8Array;

                /**
                 * Creates a new TransactionOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOutput instance
                 */
                public static create(properties?: TW.Decred.Proto.ITransactionOutput): TW.Decred.Proto.TransactionOutput;

                /**
                 * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Decred.Proto.TransactionOutput.verify|verify} messages.
                 * @param message TransactionOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Decred.Proto.ITransactionOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Decred.Proto.TransactionOutput;

                /**
                 * Verifies a TransactionOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Decred.Proto.TransactionOutput;

                /**
                 * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                 * @param message TransactionOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Decred.Proto.TransactionOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput transaction */
                transaction?: (TW.Decred.Proto.ITransaction|null);

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput transactionId */
                transactionId?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Decred.Proto.ISigningOutput);

                /** SigningOutput transaction. */
                public transaction?: (TW.Decred.Proto.ITransaction|null);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput transactionId. */
                public transactionId: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Decred.Proto.ISigningOutput): TW.Decred.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Decred.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Decred.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Decred.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Decred.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Decred.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace EOS. */
    namespace EOS {

        /** Namespace Proto. */
        namespace Proto {

            /** KeyType enum. */
            enum KeyType {
                LEGACY = 0,
                MODERNK1 = 1,
                MODERNR1 = 2
            }

            /** Properties of an Asset. */
            interface IAsset {

                /** Asset amount */
                amount?: (Long|null);

                /** Asset decimals */
                decimals?: (number|null);

                /** Asset symbol */
                symbol?: (string|null);
            }

            /** Represents an Asset. */
            class Asset implements IAsset {

                /**
                 * Constructs a new Asset.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EOS.Proto.IAsset);

                /** Asset amount. */
                public amount: Long;

                /** Asset decimals. */
                public decimals: number;

                /** Asset symbol. */
                public symbol: string;

                /**
                 * Creates a new Asset instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Asset instance
                 */
                public static create(properties?: TW.EOS.Proto.IAsset): TW.EOS.Proto.Asset;

                /**
                 * Encodes the specified Asset message. Does not implicitly {@link TW.EOS.Proto.Asset.verify|verify} messages.
                 * @param message Asset message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EOS.Proto.IAsset, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Asset message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Asset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EOS.Proto.Asset;

                /**
                 * Verifies an Asset message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Asset
                 */
                public static fromObject(object: { [k: string]: any }): TW.EOS.Proto.Asset;

                /**
                 * Creates a plain object from an Asset message. Also converts values to other types if specified.
                 * @param message Asset
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EOS.Proto.Asset, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Asset to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput chainId */
                chainId?: (Uint8Array|null);

                /** SigningInput referenceBlockId */
                referenceBlockId?: (Uint8Array|null);

                /** SigningInput referenceBlockTime */
                referenceBlockTime?: (number|null);

                /** SigningInput currency */
                currency?: (string|null);

                /** SigningInput sender */
                sender?: (string|null);

                /** SigningInput recipient */
                recipient?: (string|null);

                /** SigningInput memo */
                memo?: (string|null);

                /** SigningInput asset */
                asset?: (TW.EOS.Proto.IAsset|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput privateKeyType */
                privateKeyType?: (TW.EOS.Proto.KeyType|null);

                /** SigningInput expiration */
                expiration?: (number|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EOS.Proto.ISigningInput);

                /** SigningInput chainId. */
                public chainId: Uint8Array;

                /** SigningInput referenceBlockId. */
                public referenceBlockId: Uint8Array;

                /** SigningInput referenceBlockTime. */
                public referenceBlockTime: number;

                /** SigningInput currency. */
                public currency: string;

                /** SigningInput sender. */
                public sender: string;

                /** SigningInput recipient. */
                public recipient: string;

                /** SigningInput memo. */
                public memo: string;

                /** SigningInput asset. */
                public asset?: (TW.EOS.Proto.IAsset|null);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput privateKeyType. */
                public privateKeyType: TW.EOS.Proto.KeyType;

                /** SigningInput expiration. */
                public expiration: number;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.EOS.Proto.ISigningInput): TW.EOS.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.EOS.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EOS.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EOS.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EOS.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EOS.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput jsonEncoded */
                jsonEncoded?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EOS.Proto.ISigningOutput);

                /** SigningOutput jsonEncoded. */
                public jsonEncoded: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.EOS.Proto.ISigningOutput): TW.EOS.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.EOS.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EOS.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EOS.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EOS.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EOS.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Ethereum. */
    namespace Ethereum {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction transfer */
                transfer?: (TW.Ethereum.Proto.Transaction.ITransfer|null);

                /** Transaction erc20Transfer */
                erc20Transfer?: (TW.Ethereum.Proto.Transaction.IERC20Transfer|null);

                /** Transaction erc20Approve */
                erc20Approve?: (TW.Ethereum.Proto.Transaction.IERC20Approve|null);

                /** Transaction erc721Transfer */
                erc721Transfer?: (TW.Ethereum.Proto.Transaction.IERC721Transfer|null);

                /** Transaction erc1155Transfer */
                erc1155Transfer?: (TW.Ethereum.Proto.Transaction.IERC1155Transfer|null);

                /** Transaction contractGeneric */
                contractGeneric?: (TW.Ethereum.Proto.Transaction.IContractGeneric|null);

                /** Transaction batch */
                batch?: (TW.Ethereum.Proto.Transaction.IBatch|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.ITransaction);

                /** Transaction transfer. */
                public transfer?: (TW.Ethereum.Proto.Transaction.ITransfer|null);

                /** Transaction erc20Transfer. */
                public erc20Transfer?: (TW.Ethereum.Proto.Transaction.IERC20Transfer|null);

                /** Transaction erc20Approve. */
                public erc20Approve?: (TW.Ethereum.Proto.Transaction.IERC20Approve|null);

                /** Transaction erc721Transfer. */
                public erc721Transfer?: (TW.Ethereum.Proto.Transaction.IERC721Transfer|null);

                /** Transaction erc1155Transfer. */
                public erc1155Transfer?: (TW.Ethereum.Proto.Transaction.IERC1155Transfer|null);

                /** Transaction contractGeneric. */
                public contractGeneric?: (TW.Ethereum.Proto.Transaction.IContractGeneric|null);

                /** Transaction batch. */
                public batch?: (TW.Ethereum.Proto.Transaction.IBatch|null);

                /** Transaction transactionOneof. */
                public transactionOneof?: ("transfer"|"erc20Transfer"|"erc20Approve"|"erc721Transfer"|"erc1155Transfer"|"contractGeneric"|"batch");

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Ethereum.Proto.ITransaction): TW.Ethereum.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Transaction {

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer amount */
                    amount?: (Uint8Array|null);

                    /** Transfer data */
                    data?: (Uint8Array|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.ITransfer);

                    /** Transfer amount. */
                    public amount: Uint8Array;

                    /** Transfer data. */
                    public data: Uint8Array;

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.ITransfer): TW.Ethereum.Proto.Transaction.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ERC20Transfer. */
                interface IERC20Transfer {

                    /** ERC20Transfer to */
                    to?: (string|null);

                    /** ERC20Transfer amount */
                    amount?: (Uint8Array|null);
                }

                /** Represents a ERC20Transfer. */
                class ERC20Transfer implements IERC20Transfer {

                    /**
                     * Constructs a new ERC20Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IERC20Transfer);

                    /** ERC20Transfer to. */
                    public to: string;

                    /** ERC20Transfer amount. */
                    public amount: Uint8Array;

                    /**
                     * Creates a new ERC20Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ERC20Transfer instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IERC20Transfer): TW.Ethereum.Proto.Transaction.ERC20Transfer;

                    /**
                     * Encodes the specified ERC20Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC20Transfer.verify|verify} messages.
                     * @param message ERC20Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IERC20Transfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ERC20Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ERC20Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.ERC20Transfer;

                    /**
                     * Verifies a ERC20Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ERC20Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ERC20Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.ERC20Transfer;

                    /**
                     * Creates a plain object from a ERC20Transfer message. Also converts values to other types if specified.
                     * @param message ERC20Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.ERC20Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ERC20Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ERC20Approve. */
                interface IERC20Approve {

                    /** ERC20Approve spender */
                    spender?: (string|null);

                    /** ERC20Approve amount */
                    amount?: (Uint8Array|null);
                }

                /** Represents a ERC20Approve. */
                class ERC20Approve implements IERC20Approve {

                    /**
                     * Constructs a new ERC20Approve.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IERC20Approve);

                    /** ERC20Approve spender. */
                    public spender: string;

                    /** ERC20Approve amount. */
                    public amount: Uint8Array;

                    /**
                     * Creates a new ERC20Approve instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ERC20Approve instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IERC20Approve): TW.Ethereum.Proto.Transaction.ERC20Approve;

                    /**
                     * Encodes the specified ERC20Approve message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC20Approve.verify|verify} messages.
                     * @param message ERC20Approve message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IERC20Approve, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ERC20Approve message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ERC20Approve
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.ERC20Approve;

                    /**
                     * Verifies a ERC20Approve message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ERC20Approve message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ERC20Approve
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.ERC20Approve;

                    /**
                     * Creates a plain object from a ERC20Approve message. Also converts values to other types if specified.
                     * @param message ERC20Approve
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.ERC20Approve, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ERC20Approve to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ERC721Transfer. */
                interface IERC721Transfer {

                    /** ERC721Transfer from */
                    from?: (string|null);

                    /** ERC721Transfer to */
                    to?: (string|null);

                    /** ERC721Transfer tokenId */
                    tokenId?: (Uint8Array|null);
                }

                /** Represents a ERC721Transfer. */
                class ERC721Transfer implements IERC721Transfer {

                    /**
                     * Constructs a new ERC721Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IERC721Transfer);

                    /** ERC721Transfer from. */
                    public from: string;

                    /** ERC721Transfer to. */
                    public to: string;

                    /** ERC721Transfer tokenId. */
                    public tokenId: Uint8Array;

                    /**
                     * Creates a new ERC721Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ERC721Transfer instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IERC721Transfer): TW.Ethereum.Proto.Transaction.ERC721Transfer;

                    /**
                     * Encodes the specified ERC721Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC721Transfer.verify|verify} messages.
                     * @param message ERC721Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IERC721Transfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ERC721Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ERC721Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.ERC721Transfer;

                    /**
                     * Verifies a ERC721Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ERC721Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ERC721Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.ERC721Transfer;

                    /**
                     * Creates a plain object from a ERC721Transfer message. Also converts values to other types if specified.
                     * @param message ERC721Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.ERC721Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ERC721Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ERC1155Transfer. */
                interface IERC1155Transfer {

                    /** ERC1155Transfer from */
                    from?: (string|null);

                    /** ERC1155Transfer to */
                    to?: (string|null);

                    /** ERC1155Transfer tokenId */
                    tokenId?: (Uint8Array|null);

                    /** ERC1155Transfer value */
                    value?: (Uint8Array|null);

                    /** ERC1155Transfer data */
                    data?: (Uint8Array|null);
                }

                /** Represents a ERC1155Transfer. */
                class ERC1155Transfer implements IERC1155Transfer {

                    /**
                     * Constructs a new ERC1155Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IERC1155Transfer);

                    /** ERC1155Transfer from. */
                    public from: string;

                    /** ERC1155Transfer to. */
                    public to: string;

                    /** ERC1155Transfer tokenId. */
                    public tokenId: Uint8Array;

                    /** ERC1155Transfer value. */
                    public value: Uint8Array;

                    /** ERC1155Transfer data. */
                    public data: Uint8Array;

                    /**
                     * Creates a new ERC1155Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ERC1155Transfer instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IERC1155Transfer): TW.Ethereum.Proto.Transaction.ERC1155Transfer;

                    /**
                     * Encodes the specified ERC1155Transfer message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ERC1155Transfer.verify|verify} messages.
                     * @param message ERC1155Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IERC1155Transfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ERC1155Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ERC1155Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.ERC1155Transfer;

                    /**
                     * Verifies a ERC1155Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ERC1155Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ERC1155Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.ERC1155Transfer;

                    /**
                     * Creates a plain object from a ERC1155Transfer message. Also converts values to other types if specified.
                     * @param message ERC1155Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.ERC1155Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ERC1155Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ContractGeneric. */
                interface IContractGeneric {

                    /** ContractGeneric amount */
                    amount?: (Uint8Array|null);

                    /** ContractGeneric data */
                    data?: (Uint8Array|null);
                }

                /** Represents a ContractGeneric. */
                class ContractGeneric implements IContractGeneric {

                    /**
                     * Constructs a new ContractGeneric.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IContractGeneric);

                    /** ContractGeneric amount. */
                    public amount: Uint8Array;

                    /** ContractGeneric data. */
                    public data: Uint8Array;

                    /**
                     * Creates a new ContractGeneric instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ContractGeneric instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IContractGeneric): TW.Ethereum.Proto.Transaction.ContractGeneric;

                    /**
                     * Encodes the specified ContractGeneric message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.ContractGeneric.verify|verify} messages.
                     * @param message ContractGeneric message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IContractGeneric, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ContractGeneric message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ContractGeneric
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.ContractGeneric;

                    /**
                     * Verifies a ContractGeneric message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ContractGeneric message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ContractGeneric
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.ContractGeneric;

                    /**
                     * Creates a plain object from a ContractGeneric message. Also converts values to other types if specified.
                     * @param message ContractGeneric
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.ContractGeneric, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ContractGeneric to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Batch. */
                interface IBatch {

                    /** Batch calls */
                    calls?: (TW.Ethereum.Proto.Transaction.Batch.IBatchedCall[]|null);
                }

                /** Represents a Batch. */
                class Batch implements IBatch {

                    /**
                     * Constructs a new Batch.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Ethereum.Proto.Transaction.IBatch);

                    /** Batch calls. */
                    public calls: TW.Ethereum.Proto.Transaction.Batch.IBatchedCall[];

                    /**
                     * Creates a new Batch instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Batch instance
                     */
                    public static create(properties?: TW.Ethereum.Proto.Transaction.IBatch): TW.Ethereum.Proto.Transaction.Batch;

                    /**
                     * Encodes the specified Batch message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.Batch.verify|verify} messages.
                     * @param message Batch message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Ethereum.Proto.Transaction.IBatch, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Batch message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Batch
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.Batch;

                    /**
                     * Verifies a Batch message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Batch message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Batch
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.Batch;

                    /**
                     * Creates a plain object from a Batch message. Also converts values to other types if specified.
                     * @param message Batch
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Ethereum.Proto.Transaction.Batch, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Batch to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                namespace Batch {

                    /** Properties of a BatchedCall. */
                    interface IBatchedCall {

                        /** BatchedCall address */
                        address?: (string|null);

                        /** BatchedCall amount */
                        amount?: (Uint8Array|null);

                        /** BatchedCall payload */
                        payload?: (Uint8Array|null);
                    }

                    /** Represents a BatchedCall. */
                    class BatchedCall implements IBatchedCall {

                        /**
                         * Constructs a new BatchedCall.
                         * @param [properties] Properties to set
                         */
                        constructor(properties?: TW.Ethereum.Proto.Transaction.Batch.IBatchedCall);

                        /** BatchedCall address. */
                        public address: string;

                        /** BatchedCall amount. */
                        public amount: Uint8Array;

                        /** BatchedCall payload. */
                        public payload: Uint8Array;

                        /**
                         * Creates a new BatchedCall instance using the specified properties.
                         * @param [properties] Properties to set
                         * @returns BatchedCall instance
                         */
                        public static create(properties?: TW.Ethereum.Proto.Transaction.Batch.IBatchedCall): TW.Ethereum.Proto.Transaction.Batch.BatchedCall;

                        /**
                         * Encodes the specified BatchedCall message. Does not implicitly {@link TW.Ethereum.Proto.Transaction.Batch.BatchedCall.verify|verify} messages.
                         * @param message BatchedCall message or plain object to encode
                         * @param [writer] Writer to encode to
                         * @returns Writer
                         */
                        public static encode(message: TW.Ethereum.Proto.Transaction.Batch.IBatchedCall, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes a BatchedCall message from the specified reader or buffer.
                         * @param reader Reader or buffer to decode from
                         * @param [length] Message length if known beforehand
                         * @returns BatchedCall
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.Transaction.Batch.BatchedCall;

                        /**
                         * Verifies a BatchedCall message.
                         * @param message Plain object to verify
                         * @returns `null` if valid, otherwise the reason why it is not
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates a BatchedCall message from a plain object. Also converts values to their respective internal types.
                         * @param object Plain object
                         * @returns BatchedCall
                         */
                        public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.Transaction.Batch.BatchedCall;

                        /**
                         * Creates a plain object from a BatchedCall message. Also converts values to other types if specified.
                         * @param message BatchedCall
                         * @param [options] Conversion options
                         * @returns Plain object
                         */
                        public static toObject(message: TW.Ethereum.Proto.Transaction.Batch.BatchedCall, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Converts this BatchedCall to JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }
                }
            }

            /** TransactionMode enum. */
            enum TransactionMode {
                Legacy = 0,
                Enveloped = 1,
                UserOp = 2
            }

            /** Properties of a UserOperation. */
            interface IUserOperation {

                /** UserOperation entryPoint */
                entryPoint?: (string|null);

                /** UserOperation initCode */
                initCode?: (Uint8Array|null);

                /** UserOperation sender */
                sender?: (string|null);

                /** UserOperation preVerificationGas */
                preVerificationGas?: (Uint8Array|null);

                /** UserOperation verificationGasLimit */
                verificationGasLimit?: (Uint8Array|null);

                /** UserOperation paymasterAndData */
                paymasterAndData?: (Uint8Array|null);
            }

            /** Represents a UserOperation. */
            class UserOperation implements IUserOperation {

                /**
                 * Constructs a new UserOperation.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.IUserOperation);

                /** UserOperation entryPoint. */
                public entryPoint: string;

                /** UserOperation initCode. */
                public initCode: Uint8Array;

                /** UserOperation sender. */
                public sender: string;

                /** UserOperation preVerificationGas. */
                public preVerificationGas: Uint8Array;

                /** UserOperation verificationGasLimit. */
                public verificationGasLimit: Uint8Array;

                /** UserOperation paymasterAndData. */
                public paymasterAndData: Uint8Array;

                /**
                 * Creates a new UserOperation instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UserOperation instance
                 */
                public static create(properties?: TW.Ethereum.Proto.IUserOperation): TW.Ethereum.Proto.UserOperation;

                /**
                 * Encodes the specified UserOperation message. Does not implicitly {@link TW.Ethereum.Proto.UserOperation.verify|verify} messages.
                 * @param message UserOperation message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.IUserOperation, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a UserOperation message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UserOperation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.UserOperation;

                /**
                 * Verifies a UserOperation message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a UserOperation message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UserOperation
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.UserOperation;

                /**
                 * Creates a plain object from a UserOperation message. Also converts values to other types if specified.
                 * @param message UserOperation
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.UserOperation, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UserOperation to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput chainId */
                chainId?: (Uint8Array|null);

                /** SigningInput nonce */
                nonce?: (Uint8Array|null);

                /** SigningInput txMode */
                txMode?: (TW.Ethereum.Proto.TransactionMode|null);

                /** SigningInput gasPrice */
                gasPrice?: (Uint8Array|null);

                /** SigningInput gasLimit */
                gasLimit?: (Uint8Array|null);

                /** SigningInput maxInclusionFeePerGas */
                maxInclusionFeePerGas?: (Uint8Array|null);

                /** SigningInput maxFeePerGas */
                maxFeePerGas?: (Uint8Array|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transaction */
                transaction?: (TW.Ethereum.Proto.ITransaction|null);

                /** SigningInput userOperation */
                userOperation?: (TW.Ethereum.Proto.IUserOperation|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.ISigningInput);

                /** SigningInput chainId. */
                public chainId: Uint8Array;

                /** SigningInput nonce. */
                public nonce: Uint8Array;

                /** SigningInput txMode. */
                public txMode: TW.Ethereum.Proto.TransactionMode;

                /** SigningInput gasPrice. */
                public gasPrice: Uint8Array;

                /** SigningInput gasLimit. */
                public gasLimit: Uint8Array;

                /** SigningInput maxInclusionFeePerGas. */
                public maxInclusionFeePerGas: Uint8Array;

                /** SigningInput maxFeePerGas. */
                public maxFeePerGas: Uint8Array;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transaction. */
                public transaction?: (TW.Ethereum.Proto.ITransaction|null);

                /** SigningInput userOperation. */
                public userOperation?: (TW.Ethereum.Proto.IUserOperation|null);

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Ethereum.Proto.ISigningInput): TW.Ethereum.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ethereum.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput v */
                v?: (Uint8Array|null);

                /** SigningOutput r */
                r?: (Uint8Array|null);

                /** SigningOutput s */
                s?: (Uint8Array|null);

                /** SigningOutput data */
                data?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput preHash */
                preHash?: (Uint8Array|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput v. */
                public v: Uint8Array;

                /** SigningOutput r. */
                public r: Uint8Array;

                /** SigningOutput s. */
                public s: Uint8Array;

                /** SigningOutput data. */
                public data: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput preHash. */
                public preHash: Uint8Array;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Ethereum.Proto.ISigningOutput): TW.Ethereum.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ethereum.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** MessageType enum. */
            enum MessageType {
                MessageType_legacy = 0,
                MessageType_eip155 = 1,
                MessageType_typed = 2,
                MessageType_typed_eip155 = 3,
                MessageType_immutable_x = 4
            }

            /** Properties of a MaybeChainId. */
            interface IMaybeChainId {

                /** MaybeChainId chainId */
                chainId?: (Long|null);
            }

            /** Represents a MaybeChainId. */
            class MaybeChainId implements IMaybeChainId {

                /**
                 * Constructs a new MaybeChainId.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.IMaybeChainId);

                /** MaybeChainId chainId. */
                public chainId: Long;

                /**
                 * Creates a new MaybeChainId instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MaybeChainId instance
                 */
                public static create(properties?: TW.Ethereum.Proto.IMaybeChainId): TW.Ethereum.Proto.MaybeChainId;

                /**
                 * Encodes the specified MaybeChainId message. Does not implicitly {@link TW.Ethereum.Proto.MaybeChainId.verify|verify} messages.
                 * @param message MaybeChainId message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.IMaybeChainId, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MaybeChainId message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MaybeChainId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.MaybeChainId;

                /**
                 * Verifies a MaybeChainId message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MaybeChainId message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MaybeChainId
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.MaybeChainId;

                /**
                 * Creates a plain object from a MaybeChainId message. Also converts values to other types if specified.
                 * @param message MaybeChainId
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.MaybeChainId, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MaybeChainId to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MessageSigningInput. */
            interface IMessageSigningInput {

                /** MessageSigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** MessageSigningInput message */
                message?: (string|null);

                /** MessageSigningInput chainId */
                chainId?: (TW.Ethereum.Proto.IMaybeChainId|null);

                /** MessageSigningInput messageType */
                messageType?: (TW.Ethereum.Proto.MessageType|null);
            }

            /** Represents a MessageSigningInput. */
            class MessageSigningInput implements IMessageSigningInput {

                /**
                 * Constructs a new MessageSigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.IMessageSigningInput);

                /** MessageSigningInput privateKey. */
                public privateKey: Uint8Array;

                /** MessageSigningInput message. */
                public message: string;

                /** MessageSigningInput chainId. */
                public chainId?: (TW.Ethereum.Proto.IMaybeChainId|null);

                /** MessageSigningInput messageType. */
                public messageType: TW.Ethereum.Proto.MessageType;

                /**
                 * Creates a new MessageSigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MessageSigningInput instance
                 */
                public static create(properties?: TW.Ethereum.Proto.IMessageSigningInput): TW.Ethereum.Proto.MessageSigningInput;

                /**
                 * Encodes the specified MessageSigningInput message. Does not implicitly {@link TW.Ethereum.Proto.MessageSigningInput.verify|verify} messages.
                 * @param message MessageSigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.IMessageSigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageSigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MessageSigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.MessageSigningInput;

                /**
                 * Verifies a MessageSigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageSigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MessageSigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.MessageSigningInput;

                /**
                 * Creates a plain object from a MessageSigningInput message. Also converts values to other types if specified.
                 * @param message MessageSigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.MessageSigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MessageSigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MessageSigningOutput. */
            interface IMessageSigningOutput {

                /** MessageSigningOutput signature */
                signature?: (string|null);

                /** MessageSigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** MessageSigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a MessageSigningOutput. */
            class MessageSigningOutput implements IMessageSigningOutput {

                /**
                 * Constructs a new MessageSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.IMessageSigningOutput);

                /** MessageSigningOutput signature. */
                public signature: string;

                /** MessageSigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** MessageSigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new MessageSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MessageSigningOutput instance
                 */
                public static create(properties?: TW.Ethereum.Proto.IMessageSigningOutput): TW.Ethereum.Proto.MessageSigningOutput;

                /**
                 * Encodes the specified MessageSigningOutput message. Does not implicitly {@link TW.Ethereum.Proto.MessageSigningOutput.verify|verify} messages.
                 * @param message MessageSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.IMessageSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MessageSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.MessageSigningOutput;

                /**
                 * Verifies a MessageSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MessageSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.MessageSigningOutput;

                /**
                 * Creates a plain object from a MessageSigningOutput message. Also converts values to other types if specified.
                 * @param message MessageSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.MessageSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MessageSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MessageVerifyingInput. */
            interface IMessageVerifyingInput {

                /** MessageVerifyingInput message */
                message?: (string|null);

                /** MessageVerifyingInput publicKey */
                publicKey?: (Uint8Array|null);

                /** MessageVerifyingInput signature */
                signature?: (string|null);
            }

            /** Represents a MessageVerifyingInput. */
            class MessageVerifyingInput implements IMessageVerifyingInput {

                /**
                 * Constructs a new MessageVerifyingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ethereum.Proto.IMessageVerifyingInput);

                /** MessageVerifyingInput message. */
                public message: string;

                /** MessageVerifyingInput publicKey. */
                public publicKey: Uint8Array;

                /** MessageVerifyingInput signature. */
                public signature: string;

                /**
                 * Creates a new MessageVerifyingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MessageVerifyingInput instance
                 */
                public static create(properties?: TW.Ethereum.Proto.IMessageVerifyingInput): TW.Ethereum.Proto.MessageVerifyingInput;

                /**
                 * Encodes the specified MessageVerifyingInput message. Does not implicitly {@link TW.Ethereum.Proto.MessageVerifyingInput.verify|verify} messages.
                 * @param message MessageVerifyingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ethereum.Proto.IMessageVerifyingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MessageVerifyingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MessageVerifyingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ethereum.Proto.MessageVerifyingInput;

                /**
                 * Verifies a MessageVerifyingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MessageVerifyingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MessageVerifyingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ethereum.Proto.MessageVerifyingInput;

                /**
                 * Creates a plain object from a MessageVerifyingInput message. Also converts values to other types if specified.
                 * @param message MessageVerifyingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ethereum.Proto.MessageVerifyingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MessageVerifyingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace EthereumAbi. */
    namespace EthereumAbi {

        /** Namespace Proto. */
        namespace Proto {

            /** AbiError enum. */
            enum AbiError {
                OK = 0,
                Error_internal = 1,
                Error_abi_mismatch = 2,
                Error_invalid_abi = 3,
                Error_invalid_param_type = 4,
                Error_invalid_address_value = 5,
                Error_invalid_uint_value = 6,
                Error_missing_param_type = 7,
                Error_missing_param_value = 8,
                Error_decoding_data = 9,
                Error_empty_type = 10
            }

            /** Properties of a BoolType. */
            interface IBoolType {
            }

            /** Represents a BoolType. */
            class BoolType implements IBoolType {

                /**
                 * Constructs a new BoolType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IBoolType);

                /**
                 * Creates a new BoolType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BoolType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IBoolType): TW.EthereumAbi.Proto.BoolType;

                /**
                 * Encodes the specified BoolType message. Does not implicitly {@link TW.EthereumAbi.Proto.BoolType.verify|verify} messages.
                 * @param message BoolType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IBoolType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BoolType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns BoolType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.BoolType;

                /**
                 * Verifies a BoolType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a BoolType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns BoolType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.BoolType;

                /**
                 * Creates a plain object from a BoolType message. Also converts values to other types if specified.
                 * @param message BoolType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.BoolType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this BoolType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a NumberNType. */
            interface INumberNType {

                /** NumberNType bits */
                bits?: (number|null);
            }

            /** Represents a NumberNType. */
            class NumberNType implements INumberNType {

                /**
                 * Constructs a new NumberNType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.INumberNType);

                /** NumberNType bits. */
                public bits: number;

                /**
                 * Creates a new NumberNType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NumberNType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.INumberNType): TW.EthereumAbi.Proto.NumberNType;

                /**
                 * Encodes the specified NumberNType message. Does not implicitly {@link TW.EthereumAbi.Proto.NumberNType.verify|verify} messages.
                 * @param message NumberNType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.INumberNType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NumberNType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NumberNType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.NumberNType;

                /**
                 * Verifies a NumberNType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NumberNType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NumberNType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.NumberNType;

                /**
                 * Creates a plain object from a NumberNType message. Also converts values to other types if specified.
                 * @param message NumberNType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.NumberNType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NumberNType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a StringType. */
            interface IStringType {
            }

            /** Represents a StringType. */
            class StringType implements IStringType {

                /**
                 * Constructs a new StringType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IStringType);

                /**
                 * Creates a new StringType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StringType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IStringType): TW.EthereumAbi.Proto.StringType;

                /**
                 * Encodes the specified StringType message. Does not implicitly {@link TW.EthereumAbi.Proto.StringType.verify|verify} messages.
                 * @param message StringType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IStringType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StringType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns StringType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.StringType;

                /**
                 * Verifies a StringType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a StringType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns StringType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.StringType;

                /**
                 * Creates a plain object from a StringType message. Also converts values to other types if specified.
                 * @param message StringType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.StringType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this StringType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AddressType. */
            interface IAddressType {
            }

            /** Represents an AddressType. */
            class AddressType implements IAddressType {

                /**
                 * Constructs a new AddressType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IAddressType);

                /**
                 * Creates a new AddressType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AddressType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IAddressType): TW.EthereumAbi.Proto.AddressType;

                /**
                 * Encodes the specified AddressType message. Does not implicitly {@link TW.EthereumAbi.Proto.AddressType.verify|verify} messages.
                 * @param message AddressType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IAddressType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AddressType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AddressType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.AddressType;

                /**
                 * Verifies an AddressType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AddressType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AddressType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.AddressType;

                /**
                 * Creates a plain object from an AddressType message. Also converts values to other types if specified.
                 * @param message AddressType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.AddressType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AddressType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an ArrayType. */
            interface IArrayType {

                /** ArrayType elementType */
                elementType?: (TW.EthereumAbi.Proto.IParamType|null);
            }

            /** Represents an ArrayType. */
            class ArrayType implements IArrayType {

                /**
                 * Constructs a new ArrayType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IArrayType);

                /** ArrayType elementType. */
                public elementType?: (TW.EthereumAbi.Proto.IParamType|null);

                /**
                 * Creates a new ArrayType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ArrayType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IArrayType): TW.EthereumAbi.Proto.ArrayType;

                /**
                 * Encodes the specified ArrayType message. Does not implicitly {@link TW.EthereumAbi.Proto.ArrayType.verify|verify} messages.
                 * @param message ArrayType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IArrayType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ArrayType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ArrayType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ArrayType;

                /**
                 * Verifies an ArrayType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an ArrayType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ArrayType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ArrayType;

                /**
                 * Creates a plain object from an ArrayType message. Also converts values to other types if specified.
                 * @param message ArrayType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ArrayType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ArrayType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FixedArrayType. */
            interface IFixedArrayType {

                /** FixedArrayType size */
                size?: (Long|null);

                /** FixedArrayType elementType */
                elementType?: (TW.EthereumAbi.Proto.IParamType|null);
            }

            /** Represents a FixedArrayType. */
            class FixedArrayType implements IFixedArrayType {

                /**
                 * Constructs a new FixedArrayType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IFixedArrayType);

                /** FixedArrayType size. */
                public size: Long;

                /** FixedArrayType elementType. */
                public elementType?: (TW.EthereumAbi.Proto.IParamType|null);

                /**
                 * Creates a new FixedArrayType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FixedArrayType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IFixedArrayType): TW.EthereumAbi.Proto.FixedArrayType;

                /**
                 * Encodes the specified FixedArrayType message. Does not implicitly {@link TW.EthereumAbi.Proto.FixedArrayType.verify|verify} messages.
                 * @param message FixedArrayType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IFixedArrayType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FixedArrayType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FixedArrayType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.FixedArrayType;

                /**
                 * Verifies a FixedArrayType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FixedArrayType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FixedArrayType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.FixedArrayType;

                /**
                 * Creates a plain object from a FixedArrayType message. Also converts values to other types if specified.
                 * @param message FixedArrayType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.FixedArrayType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FixedArrayType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ByteArrayType. */
            interface IByteArrayType {
            }

            /** Represents a ByteArrayType. */
            class ByteArrayType implements IByteArrayType {

                /**
                 * Constructs a new ByteArrayType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IByteArrayType);

                /**
                 * Creates a new ByteArrayType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ByteArrayType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IByteArrayType): TW.EthereumAbi.Proto.ByteArrayType;

                /**
                 * Encodes the specified ByteArrayType message. Does not implicitly {@link TW.EthereumAbi.Proto.ByteArrayType.verify|verify} messages.
                 * @param message ByteArrayType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IByteArrayType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ByteArrayType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ByteArrayType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ByteArrayType;

                /**
                 * Verifies a ByteArrayType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ByteArrayType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ByteArrayType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ByteArrayType;

                /**
                 * Creates a plain object from a ByteArrayType message. Also converts values to other types if specified.
                 * @param message ByteArrayType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ByteArrayType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ByteArrayType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ByteArrayFixType. */
            interface IByteArrayFixType {

                /** ByteArrayFixType size */
                size?: (Long|null);
            }

            /** Represents a ByteArrayFixType. */
            class ByteArrayFixType implements IByteArrayFixType {

                /**
                 * Constructs a new ByteArrayFixType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IByteArrayFixType);

                /** ByteArrayFixType size. */
                public size: Long;

                /**
                 * Creates a new ByteArrayFixType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ByteArrayFixType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IByteArrayFixType): TW.EthereumAbi.Proto.ByteArrayFixType;

                /**
                 * Encodes the specified ByteArrayFixType message. Does not implicitly {@link TW.EthereumAbi.Proto.ByteArrayFixType.verify|verify} messages.
                 * @param message ByteArrayFixType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IByteArrayFixType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ByteArrayFixType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ByteArrayFixType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ByteArrayFixType;

                /**
                 * Verifies a ByteArrayFixType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ByteArrayFixType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ByteArrayFixType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ByteArrayFixType;

                /**
                 * Creates a plain object from a ByteArrayFixType message. Also converts values to other types if specified.
                 * @param message ByteArrayFixType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ByteArrayFixType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ByteArrayFixType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TupleType. */
            interface ITupleType {

                /** TupleType params */
                params?: (TW.EthereumAbi.Proto.IParam[]|null);
            }

            /** Represents a TupleType. */
            class TupleType implements ITupleType {

                /**
                 * Constructs a new TupleType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.ITupleType);

                /** TupleType params. */
                public params: TW.EthereumAbi.Proto.IParam[];

                /**
                 * Creates a new TupleType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TupleType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.ITupleType): TW.EthereumAbi.Proto.TupleType;

                /**
                 * Encodes the specified TupleType message. Does not implicitly {@link TW.EthereumAbi.Proto.TupleType.verify|verify} messages.
                 * @param message TupleType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.ITupleType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TupleType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TupleType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.TupleType;

                /**
                 * Verifies a TupleType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TupleType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TupleType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.TupleType;

                /**
                 * Creates a plain object from a TupleType message. Also converts values to other types if specified.
                 * @param message TupleType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.TupleType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TupleType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Param. */
            interface IParam {

                /** Param name */
                name?: (string|null);

                /** Param param */
                param?: (TW.EthereumAbi.Proto.IParamType|null);
            }

            /** Represents a Param. */
            class Param implements IParam {

                /**
                 * Constructs a new Param.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IParam);

                /** Param name. */
                public name: string;

                /** Param param. */
                public param?: (TW.EthereumAbi.Proto.IParamType|null);

                /**
                 * Creates a new Param instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Param instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IParam): TW.EthereumAbi.Proto.Param;

                /**
                 * Encodes the specified Param message. Does not implicitly {@link TW.EthereumAbi.Proto.Param.verify|verify} messages.
                 * @param message Param message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IParam, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Param message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Param
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.Param;

                /**
                 * Verifies a Param message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Param message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Param
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.Param;

                /**
                 * Creates a plain object from a Param message. Also converts values to other types if specified.
                 * @param message Param
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.Param, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Param to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ParamType. */
            interface IParamType {

                /** ParamType boolean */
                boolean?: (TW.EthereumAbi.Proto.IBoolType|null);

                /** ParamType numberInt */
                numberInt?: (TW.EthereumAbi.Proto.INumberNType|null);

                /** ParamType numberUint */
                numberUint?: (TW.EthereumAbi.Proto.INumberNType|null);

                /** ParamType stringParam */
                stringParam?: (TW.EthereumAbi.Proto.IStringType|null);

                /** ParamType address */
                address?: (TW.EthereumAbi.Proto.IAddressType|null);

                /** ParamType byteArray */
                byteArray?: (TW.EthereumAbi.Proto.IByteArrayType|null);

                /** ParamType byteArrayFix */
                byteArrayFix?: (TW.EthereumAbi.Proto.IByteArrayFixType|null);

                /** ParamType array */
                array?: (TW.EthereumAbi.Proto.IArrayType|null);

                /** ParamType fixedArray */
                fixedArray?: (TW.EthereumAbi.Proto.IFixedArrayType|null);

                /** ParamType tuple */
                tuple?: (TW.EthereumAbi.Proto.ITupleType|null);
            }

            /** Represents a ParamType. */
            class ParamType implements IParamType {

                /**
                 * Constructs a new ParamType.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IParamType);

                /** ParamType boolean. */
                public boolean?: (TW.EthereumAbi.Proto.IBoolType|null);

                /** ParamType numberInt. */
                public numberInt?: (TW.EthereumAbi.Proto.INumberNType|null);

                /** ParamType numberUint. */
                public numberUint?: (TW.EthereumAbi.Proto.INumberNType|null);

                /** ParamType stringParam. */
                public stringParam?: (TW.EthereumAbi.Proto.IStringType|null);

                /** ParamType address. */
                public address?: (TW.EthereumAbi.Proto.IAddressType|null);

                /** ParamType byteArray. */
                public byteArray?: (TW.EthereumAbi.Proto.IByteArrayType|null);

                /** ParamType byteArrayFix. */
                public byteArrayFix?: (TW.EthereumAbi.Proto.IByteArrayFixType|null);

                /** ParamType array. */
                public array?: (TW.EthereumAbi.Proto.IArrayType|null);

                /** ParamType fixedArray. */
                public fixedArray?: (TW.EthereumAbi.Proto.IFixedArrayType|null);

                /** ParamType tuple. */
                public tuple?: (TW.EthereumAbi.Proto.ITupleType|null);

                /** ParamType param. */
                public param?: ("boolean"|"numberInt"|"numberUint"|"stringParam"|"address"|"byteArray"|"byteArrayFix"|"array"|"fixedArray"|"tuple");

                /**
                 * Creates a new ParamType instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ParamType instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IParamType): TW.EthereumAbi.Proto.ParamType;

                /**
                 * Encodes the specified ParamType message. Does not implicitly {@link TW.EthereumAbi.Proto.ParamType.verify|verify} messages.
                 * @param message ParamType message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IParamType, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ParamType message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ParamType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ParamType;

                /**
                 * Verifies a ParamType message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ParamType message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ParamType
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ParamType;

                /**
                 * Creates a plain object from a ParamType message. Also converts values to other types if specified.
                 * @param message ParamType
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ParamType, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ParamType to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a NumberNParam. */
            interface INumberNParam {

                /** NumberNParam bits */
                bits?: (number|null);

                /** NumberNParam value */
                value?: (Uint8Array|null);
            }

            /** Represents a NumberNParam. */
            class NumberNParam implements INumberNParam {

                /**
                 * Constructs a new NumberNParam.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.INumberNParam);

                /** NumberNParam bits. */
                public bits: number;

                /** NumberNParam value. */
                public value: Uint8Array;

                /**
                 * Creates a new NumberNParam instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NumberNParam instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.INumberNParam): TW.EthereumAbi.Proto.NumberNParam;

                /**
                 * Encodes the specified NumberNParam message. Does not implicitly {@link TW.EthereumAbi.Proto.NumberNParam.verify|verify} messages.
                 * @param message NumberNParam message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.INumberNParam, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NumberNParam message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NumberNParam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.NumberNParam;

                /**
                 * Verifies a NumberNParam message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NumberNParam message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NumberNParam
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.NumberNParam;

                /**
                 * Creates a plain object from a NumberNParam message. Also converts values to other types if specified.
                 * @param message NumberNParam
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.NumberNParam, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NumberNParam to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an ArrayParam. */
            interface IArrayParam {

                /** ArrayParam elementType */
                elementType?: (TW.EthereumAbi.Proto.IParamType|null);

                /** ArrayParam elements */
                elements?: (TW.EthereumAbi.Proto.IToken[]|null);
            }

            /** Represents an ArrayParam. */
            class ArrayParam implements IArrayParam {

                /**
                 * Constructs a new ArrayParam.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IArrayParam);

                /** ArrayParam elementType. */
                public elementType?: (TW.EthereumAbi.Proto.IParamType|null);

                /** ArrayParam elements. */
                public elements: TW.EthereumAbi.Proto.IToken[];

                /**
                 * Creates a new ArrayParam instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ArrayParam instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IArrayParam): TW.EthereumAbi.Proto.ArrayParam;

                /**
                 * Encodes the specified ArrayParam message. Does not implicitly {@link TW.EthereumAbi.Proto.ArrayParam.verify|verify} messages.
                 * @param message ArrayParam message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IArrayParam, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ArrayParam message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ArrayParam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ArrayParam;

                /**
                 * Verifies an ArrayParam message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an ArrayParam message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ArrayParam
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ArrayParam;

                /**
                 * Creates a plain object from an ArrayParam message. Also converts values to other types if specified.
                 * @param message ArrayParam
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ArrayParam, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ArrayParam to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TupleParam. */
            interface ITupleParam {

                /** TupleParam params */
                params?: (TW.EthereumAbi.Proto.IToken[]|null);
            }

            /** Represents a TupleParam. */
            class TupleParam implements ITupleParam {

                /**
                 * Constructs a new TupleParam.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.ITupleParam);

                /** TupleParam params. */
                public params: TW.EthereumAbi.Proto.IToken[];

                /**
                 * Creates a new TupleParam instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TupleParam instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.ITupleParam): TW.EthereumAbi.Proto.TupleParam;

                /**
                 * Encodes the specified TupleParam message. Does not implicitly {@link TW.EthereumAbi.Proto.TupleParam.verify|verify} messages.
                 * @param message TupleParam message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.ITupleParam, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TupleParam message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TupleParam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.TupleParam;

                /**
                 * Verifies a TupleParam message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TupleParam message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TupleParam
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.TupleParam;

                /**
                 * Creates a plain object from a TupleParam message. Also converts values to other types if specified.
                 * @param message TupleParam
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.TupleParam, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TupleParam to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Token. */
            interface IToken {

                /** Token name */
                name?: (string|null);

                /** Token boolean */
                boolean?: (boolean|null);

                /** Token numberInt */
                numberInt?: (TW.EthereumAbi.Proto.INumberNParam|null);

                /** Token numberUint */
                numberUint?: (TW.EthereumAbi.Proto.INumberNParam|null);

                /** Token stringValue */
                stringValue?: (string|null);

                /** Token address */
                address?: (string|null);

                /** Token byteArray */
                byteArray?: (Uint8Array|null);

                /** Token byteArrayFix */
                byteArrayFix?: (Uint8Array|null);

                /** Token array */
                array?: (TW.EthereumAbi.Proto.IArrayParam|null);

                /** Token fixedArray */
                fixedArray?: (TW.EthereumAbi.Proto.IArrayParam|null);

                /** Token tuple */
                tuple?: (TW.EthereumAbi.Proto.ITupleParam|null);
            }

            /** Represents a Token. */
            class Token implements IToken {

                /**
                 * Constructs a new Token.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IToken);

                /** Token name. */
                public name: string;

                /** Token boolean. */
                public boolean?: (boolean|null);

                /** Token numberInt. */
                public numberInt?: (TW.EthereumAbi.Proto.INumberNParam|null);

                /** Token numberUint. */
                public numberUint?: (TW.EthereumAbi.Proto.INumberNParam|null);

                /** Token stringValue. */
                public stringValue?: (string|null);

                /** Token address. */
                public address?: (string|null);

                /** Token byteArray. */
                public byteArray?: (Uint8Array|null);

                /** Token byteArrayFix. */
                public byteArrayFix?: (Uint8Array|null);

                /** Token array. */
                public array?: (TW.EthereumAbi.Proto.IArrayParam|null);

                /** Token fixedArray. */
                public fixedArray?: (TW.EthereumAbi.Proto.IArrayParam|null);

                /** Token tuple. */
                public tuple?: (TW.EthereumAbi.Proto.ITupleParam|null);

                /** Token token. */
                public token?: ("boolean"|"numberInt"|"numberUint"|"stringValue"|"address"|"byteArray"|"byteArrayFix"|"array"|"fixedArray"|"tuple");

                /**
                 * Creates a new Token instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Token instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IToken): TW.EthereumAbi.Proto.Token;

                /**
                 * Encodes the specified Token message. Does not implicitly {@link TW.EthereumAbi.Proto.Token.verify|verify} messages.
                 * @param message Token message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IToken, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Token message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Token
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.Token;

                /**
                 * Verifies a Token message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Token message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Token
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.Token;

                /**
                 * Creates a plain object from a Token message. Also converts values to other types if specified.
                 * @param message Token
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.Token, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Token to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ContractCallDecodingInput. */
            interface IContractCallDecodingInput {

                /** ContractCallDecodingInput encoded */
                encoded?: (Uint8Array|null);

                /** ContractCallDecodingInput smartContractAbiJson */
                smartContractAbiJson?: (string|null);
            }

            /** Represents a ContractCallDecodingInput. */
            class ContractCallDecodingInput implements IContractCallDecodingInput {

                /**
                 * Constructs a new ContractCallDecodingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IContractCallDecodingInput);

                /** ContractCallDecodingInput encoded. */
                public encoded: Uint8Array;

                /** ContractCallDecodingInput smartContractAbiJson. */
                public smartContractAbiJson: string;

                /**
                 * Creates a new ContractCallDecodingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractCallDecodingInput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IContractCallDecodingInput): TW.EthereumAbi.Proto.ContractCallDecodingInput;

                /**
                 * Encodes the specified ContractCallDecodingInput message. Does not implicitly {@link TW.EthereumAbi.Proto.ContractCallDecodingInput.verify|verify} messages.
                 * @param message ContractCallDecodingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IContractCallDecodingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractCallDecodingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ContractCallDecodingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ContractCallDecodingInput;

                /**
                 * Verifies a ContractCallDecodingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ContractCallDecodingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ContractCallDecodingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ContractCallDecodingInput;

                /**
                 * Creates a plain object from a ContractCallDecodingInput message. Also converts values to other types if specified.
                 * @param message ContractCallDecodingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ContractCallDecodingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ContractCallDecodingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ContractCallDecodingOutput. */
            interface IContractCallDecodingOutput {

                /** ContractCallDecodingOutput decodedJson */
                decodedJson?: (string|null);

                /** ContractCallDecodingOutput tokens */
                tokens?: (TW.EthereumAbi.Proto.IToken[]|null);

                /** ContractCallDecodingOutput error */
                error?: (TW.EthereumAbi.Proto.AbiError|null);

                /** ContractCallDecodingOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a ContractCallDecodingOutput. */
            class ContractCallDecodingOutput implements IContractCallDecodingOutput {

                /**
                 * Constructs a new ContractCallDecodingOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IContractCallDecodingOutput);

                /** ContractCallDecodingOutput decodedJson. */
                public decodedJson: string;

                /** ContractCallDecodingOutput tokens. */
                public tokens: TW.EthereumAbi.Proto.IToken[];

                /** ContractCallDecodingOutput error. */
                public error: TW.EthereumAbi.Proto.AbiError;

                /** ContractCallDecodingOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new ContractCallDecodingOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractCallDecodingOutput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IContractCallDecodingOutput): TW.EthereumAbi.Proto.ContractCallDecodingOutput;

                /**
                 * Encodes the specified ContractCallDecodingOutput message. Does not implicitly {@link TW.EthereumAbi.Proto.ContractCallDecodingOutput.verify|verify} messages.
                 * @param message ContractCallDecodingOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IContractCallDecodingOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractCallDecodingOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ContractCallDecodingOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ContractCallDecodingOutput;

                /**
                 * Verifies a ContractCallDecodingOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ContractCallDecodingOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ContractCallDecodingOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ContractCallDecodingOutput;

                /**
                 * Creates a plain object from a ContractCallDecodingOutput message. Also converts values to other types if specified.
                 * @param message ContractCallDecodingOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ContractCallDecodingOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ContractCallDecodingOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AbiParams. */
            interface IAbiParams {

                /** AbiParams params */
                params?: (TW.EthereumAbi.Proto.IParam[]|null);
            }

            /** Represents an AbiParams. */
            class AbiParams implements IAbiParams {

                /**
                 * Constructs a new AbiParams.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IAbiParams);

                /** AbiParams params. */
                public params: TW.EthereumAbi.Proto.IParam[];

                /**
                 * Creates a new AbiParams instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AbiParams instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IAbiParams): TW.EthereumAbi.Proto.AbiParams;

                /**
                 * Encodes the specified AbiParams message. Does not implicitly {@link TW.EthereumAbi.Proto.AbiParams.verify|verify} messages.
                 * @param message AbiParams message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IAbiParams, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AbiParams message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AbiParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.AbiParams;

                /**
                 * Verifies an AbiParams message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AbiParams message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AbiParams
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.AbiParams;

                /**
                 * Creates a plain object from an AbiParams message. Also converts values to other types if specified.
                 * @param message AbiParams
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.AbiParams, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AbiParams to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ParamsDecodingInput. */
            interface IParamsDecodingInput {

                /** ParamsDecodingInput encoded */
                encoded?: (Uint8Array|null);

                /** ParamsDecodingInput abiJson */
                abiJson?: (string|null);

                /** ParamsDecodingInput abiParams */
                abiParams?: (TW.EthereumAbi.Proto.IAbiParams|null);
            }

            /** Represents a ParamsDecodingInput. */
            class ParamsDecodingInput implements IParamsDecodingInput {

                /**
                 * Constructs a new ParamsDecodingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IParamsDecodingInput);

                /** ParamsDecodingInput encoded. */
                public encoded: Uint8Array;

                /** ParamsDecodingInput abiJson. */
                public abiJson?: (string|null);

                /** ParamsDecodingInput abiParams. */
                public abiParams?: (TW.EthereumAbi.Proto.IAbiParams|null);

                /** ParamsDecodingInput abi. */
                public abi?: ("abiJson"|"abiParams");

                /**
                 * Creates a new ParamsDecodingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ParamsDecodingInput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IParamsDecodingInput): TW.EthereumAbi.Proto.ParamsDecodingInput;

                /**
                 * Encodes the specified ParamsDecodingInput message. Does not implicitly {@link TW.EthereumAbi.Proto.ParamsDecodingInput.verify|verify} messages.
                 * @param message ParamsDecodingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IParamsDecodingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ParamsDecodingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ParamsDecodingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ParamsDecodingInput;

                /**
                 * Verifies a ParamsDecodingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ParamsDecodingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ParamsDecodingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ParamsDecodingInput;

                /**
                 * Creates a plain object from a ParamsDecodingInput message. Also converts values to other types if specified.
                 * @param message ParamsDecodingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ParamsDecodingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ParamsDecodingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ParamsDecodingOutput. */
            interface IParamsDecodingOutput {

                /** ParamsDecodingOutput tokens */
                tokens?: (TW.EthereumAbi.Proto.IToken[]|null);

                /** ParamsDecodingOutput error */
                error?: (TW.EthereumAbi.Proto.AbiError|null);

                /** ParamsDecodingOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a ParamsDecodingOutput. */
            class ParamsDecodingOutput implements IParamsDecodingOutput {

                /**
                 * Constructs a new ParamsDecodingOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IParamsDecodingOutput);

                /** ParamsDecodingOutput tokens. */
                public tokens: TW.EthereumAbi.Proto.IToken[];

                /** ParamsDecodingOutput error. */
                public error: TW.EthereumAbi.Proto.AbiError;

                /** ParamsDecodingOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new ParamsDecodingOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ParamsDecodingOutput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IParamsDecodingOutput): TW.EthereumAbi.Proto.ParamsDecodingOutput;

                /**
                 * Encodes the specified ParamsDecodingOutput message. Does not implicitly {@link TW.EthereumAbi.Proto.ParamsDecodingOutput.verify|verify} messages.
                 * @param message ParamsDecodingOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IParamsDecodingOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ParamsDecodingOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ParamsDecodingOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ParamsDecodingOutput;

                /**
                 * Verifies a ParamsDecodingOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ParamsDecodingOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ParamsDecodingOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ParamsDecodingOutput;

                /**
                 * Creates a plain object from a ParamsDecodingOutput message. Also converts values to other types if specified.
                 * @param message ParamsDecodingOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ParamsDecodingOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ParamsDecodingOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ValueDecodingInput. */
            interface IValueDecodingInput {

                /** ValueDecodingInput encoded */
                encoded?: (Uint8Array|null);

                /** ValueDecodingInput paramType */
                paramType?: (string|null);
            }

            /** Represents a ValueDecodingInput. */
            class ValueDecodingInput implements IValueDecodingInput {

                /**
                 * Constructs a new ValueDecodingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IValueDecodingInput);

                /** ValueDecodingInput encoded. */
                public encoded: Uint8Array;

                /** ValueDecodingInput paramType. */
                public paramType: string;

                /**
                 * Creates a new ValueDecodingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ValueDecodingInput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IValueDecodingInput): TW.EthereumAbi.Proto.ValueDecodingInput;

                /**
                 * Encodes the specified ValueDecodingInput message. Does not implicitly {@link TW.EthereumAbi.Proto.ValueDecodingInput.verify|verify} messages.
                 * @param message ValueDecodingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IValueDecodingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ValueDecodingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ValueDecodingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ValueDecodingInput;

                /**
                 * Verifies a ValueDecodingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ValueDecodingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ValueDecodingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ValueDecodingInput;

                /**
                 * Creates a plain object from a ValueDecodingInput message. Also converts values to other types if specified.
                 * @param message ValueDecodingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ValueDecodingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ValueDecodingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ValueDecodingOutput. */
            interface IValueDecodingOutput {

                /** ValueDecodingOutput token */
                token?: (TW.EthereumAbi.Proto.IToken|null);

                /** ValueDecodingOutput paramStr */
                paramStr?: (string|null);

                /** ValueDecodingOutput error */
                error?: (TW.EthereumAbi.Proto.AbiError|null);

                /** ValueDecodingOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a ValueDecodingOutput. */
            class ValueDecodingOutput implements IValueDecodingOutput {

                /**
                 * Constructs a new ValueDecodingOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IValueDecodingOutput);

                /** ValueDecodingOutput token. */
                public token?: (TW.EthereumAbi.Proto.IToken|null);

                /** ValueDecodingOutput paramStr. */
                public paramStr: string;

                /** ValueDecodingOutput error. */
                public error: TW.EthereumAbi.Proto.AbiError;

                /** ValueDecodingOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new ValueDecodingOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ValueDecodingOutput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IValueDecodingOutput): TW.EthereumAbi.Proto.ValueDecodingOutput;

                /**
                 * Encodes the specified ValueDecodingOutput message. Does not implicitly {@link TW.EthereumAbi.Proto.ValueDecodingOutput.verify|verify} messages.
                 * @param message ValueDecodingOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IValueDecodingOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ValueDecodingOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ValueDecodingOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.ValueDecodingOutput;

                /**
                 * Verifies a ValueDecodingOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ValueDecodingOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ValueDecodingOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.ValueDecodingOutput;

                /**
                 * Creates a plain object from a ValueDecodingOutput message. Also converts values to other types if specified.
                 * @param message ValueDecodingOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.ValueDecodingOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ValueDecodingOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FunctionEncodingInput. */
            interface IFunctionEncodingInput {

                /** FunctionEncodingInput functionName */
                functionName?: (string|null);

                /** FunctionEncodingInput tokens */
                tokens?: (TW.EthereumAbi.Proto.IToken[]|null);
            }

            /** Represents a FunctionEncodingInput. */
            class FunctionEncodingInput implements IFunctionEncodingInput {

                /**
                 * Constructs a new FunctionEncodingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IFunctionEncodingInput);

                /** FunctionEncodingInput functionName. */
                public functionName: string;

                /** FunctionEncodingInput tokens. */
                public tokens: TW.EthereumAbi.Proto.IToken[];

                /**
                 * Creates a new FunctionEncodingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FunctionEncodingInput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IFunctionEncodingInput): TW.EthereumAbi.Proto.FunctionEncodingInput;

                /**
                 * Encodes the specified FunctionEncodingInput message. Does not implicitly {@link TW.EthereumAbi.Proto.FunctionEncodingInput.verify|verify} messages.
                 * @param message FunctionEncodingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IFunctionEncodingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FunctionEncodingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FunctionEncodingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.FunctionEncodingInput;

                /**
                 * Verifies a FunctionEncodingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FunctionEncodingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FunctionEncodingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.FunctionEncodingInput;

                /**
                 * Creates a plain object from a FunctionEncodingInput message. Also converts values to other types if specified.
                 * @param message FunctionEncodingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.FunctionEncodingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FunctionEncodingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FunctionEncodingOutput. */
            interface IFunctionEncodingOutput {

                /** FunctionEncodingOutput functionType */
                functionType?: (string|null);

                /** FunctionEncodingOutput encoded */
                encoded?: (Uint8Array|null);

                /** FunctionEncodingOutput error */
                error?: (TW.EthereumAbi.Proto.AbiError|null);

                /** FunctionEncodingOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a FunctionEncodingOutput. */
            class FunctionEncodingOutput implements IFunctionEncodingOutput {

                /**
                 * Constructs a new FunctionEncodingOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IFunctionEncodingOutput);

                /** FunctionEncodingOutput functionType. */
                public functionType: string;

                /** FunctionEncodingOutput encoded. */
                public encoded: Uint8Array;

                /** FunctionEncodingOutput error. */
                public error: TW.EthereumAbi.Proto.AbiError;

                /** FunctionEncodingOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new FunctionEncodingOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FunctionEncodingOutput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IFunctionEncodingOutput): TW.EthereumAbi.Proto.FunctionEncodingOutput;

                /**
                 * Encodes the specified FunctionEncodingOutput message. Does not implicitly {@link TW.EthereumAbi.Proto.FunctionEncodingOutput.verify|verify} messages.
                 * @param message FunctionEncodingOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IFunctionEncodingOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FunctionEncodingOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FunctionEncodingOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.FunctionEncodingOutput;

                /**
                 * Verifies a FunctionEncodingOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FunctionEncodingOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FunctionEncodingOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.FunctionEncodingOutput;

                /**
                 * Creates a plain object from a FunctionEncodingOutput message. Also converts values to other types if specified.
                 * @param message FunctionEncodingOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.FunctionEncodingOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FunctionEncodingOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FunctionGetTypeInput. */
            interface IFunctionGetTypeInput {

                /** FunctionGetTypeInput functionName */
                functionName?: (string|null);

                /** FunctionGetTypeInput inputs */
                inputs?: (TW.EthereumAbi.Proto.IParam[]|null);
            }

            /** Represents a FunctionGetTypeInput. */
            class FunctionGetTypeInput implements IFunctionGetTypeInput {

                /**
                 * Constructs a new FunctionGetTypeInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumAbi.Proto.IFunctionGetTypeInput);

                /** FunctionGetTypeInput functionName. */
                public functionName: string;

                /** FunctionGetTypeInput inputs. */
                public inputs: TW.EthereumAbi.Proto.IParam[];

                /**
                 * Creates a new FunctionGetTypeInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FunctionGetTypeInput instance
                 */
                public static create(properties?: TW.EthereumAbi.Proto.IFunctionGetTypeInput): TW.EthereumAbi.Proto.FunctionGetTypeInput;

                /**
                 * Encodes the specified FunctionGetTypeInput message. Does not implicitly {@link TW.EthereumAbi.Proto.FunctionGetTypeInput.verify|verify} messages.
                 * @param message FunctionGetTypeInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumAbi.Proto.IFunctionGetTypeInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FunctionGetTypeInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FunctionGetTypeInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumAbi.Proto.FunctionGetTypeInput;

                /**
                 * Verifies a FunctionGetTypeInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FunctionGetTypeInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FunctionGetTypeInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumAbi.Proto.FunctionGetTypeInput;

                /**
                 * Creates a plain object from a FunctionGetTypeInput message. Also converts values to other types if specified.
                 * @param message FunctionGetTypeInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumAbi.Proto.FunctionGetTypeInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FunctionGetTypeInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace EthereumRlp. */
    namespace EthereumRlp {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a RlpList. */
            interface IRlpList {

                /** RlpList items */
                items?: (TW.EthereumRlp.Proto.IRlpItem[]|null);
            }

            /** Represents a RlpList. */
            class RlpList implements IRlpList {

                /**
                 * Constructs a new RlpList.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumRlp.Proto.IRlpList);

                /** RlpList items. */
                public items: TW.EthereumRlp.Proto.IRlpItem[];

                /**
                 * Creates a new RlpList instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RlpList instance
                 */
                public static create(properties?: TW.EthereumRlp.Proto.IRlpList): TW.EthereumRlp.Proto.RlpList;

                /**
                 * Encodes the specified RlpList message. Does not implicitly {@link TW.EthereumRlp.Proto.RlpList.verify|verify} messages.
                 * @param message RlpList message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumRlp.Proto.IRlpList, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RlpList message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RlpList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumRlp.Proto.RlpList;

                /**
                 * Verifies a RlpList message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RlpList message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RlpList
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumRlp.Proto.RlpList;

                /**
                 * Creates a plain object from a RlpList message. Also converts values to other types if specified.
                 * @param message RlpList
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumRlp.Proto.RlpList, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RlpList to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a RlpItem. */
            interface IRlpItem {

                /** RlpItem stringItem */
                stringItem?: (string|null);

                /** RlpItem numberU64 */
                numberU64?: (Long|null);

                /** RlpItem numberU256 */
                numberU256?: (Uint8Array|null);

                /** RlpItem address */
                address?: (string|null);

                /** RlpItem data */
                data?: (Uint8Array|null);

                /** RlpItem list */
                list?: (TW.EthereumRlp.Proto.IRlpList|null);

                /** RlpItem rawEncoded */
                rawEncoded?: (Uint8Array|null);
            }

            /** Represents a RlpItem. */
            class RlpItem implements IRlpItem {

                /**
                 * Constructs a new RlpItem.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumRlp.Proto.IRlpItem);

                /** RlpItem stringItem. */
                public stringItem?: (string|null);

                /** RlpItem numberU64. */
                public numberU64?: (Long|null);

                /** RlpItem numberU256. */
                public numberU256?: (Uint8Array|null);

                /** RlpItem address. */
                public address?: (string|null);

                /** RlpItem data. */
                public data?: (Uint8Array|null);

                /** RlpItem list. */
                public list?: (TW.EthereumRlp.Proto.IRlpList|null);

                /** RlpItem rawEncoded. */
                public rawEncoded?: (Uint8Array|null);

                /** RlpItem item. */
                public item?: ("stringItem"|"numberU64"|"numberU256"|"address"|"data"|"list"|"rawEncoded");

                /**
                 * Creates a new RlpItem instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RlpItem instance
                 */
                public static create(properties?: TW.EthereumRlp.Proto.IRlpItem): TW.EthereumRlp.Proto.RlpItem;

                /**
                 * Encodes the specified RlpItem message. Does not implicitly {@link TW.EthereumRlp.Proto.RlpItem.verify|verify} messages.
                 * @param message RlpItem message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumRlp.Proto.IRlpItem, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RlpItem message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RlpItem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumRlp.Proto.RlpItem;

                /**
                 * Verifies a RlpItem message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RlpItem message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RlpItem
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumRlp.Proto.RlpItem;

                /**
                 * Creates a plain object from a RlpItem message. Also converts values to other types if specified.
                 * @param message RlpItem
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumRlp.Proto.RlpItem, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RlpItem to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an EncodingInput. */
            interface IEncodingInput {

                /** EncodingInput item */
                item?: (TW.EthereumRlp.Proto.IRlpItem|null);
            }

            /** Represents an EncodingInput. */
            class EncodingInput implements IEncodingInput {

                /**
                 * Constructs a new EncodingInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumRlp.Proto.IEncodingInput);

                /** EncodingInput item. */
                public item?: (TW.EthereumRlp.Proto.IRlpItem|null);

                /**
                 * Creates a new EncodingInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns EncodingInput instance
                 */
                public static create(properties?: TW.EthereumRlp.Proto.IEncodingInput): TW.EthereumRlp.Proto.EncodingInput;

                /**
                 * Encodes the specified EncodingInput message. Does not implicitly {@link TW.EthereumRlp.Proto.EncodingInput.verify|verify} messages.
                 * @param message EncodingInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumRlp.Proto.IEncodingInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an EncodingInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns EncodingInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumRlp.Proto.EncodingInput;

                /**
                 * Verifies an EncodingInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an EncodingInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns EncodingInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumRlp.Proto.EncodingInput;

                /**
                 * Creates a plain object from an EncodingInput message. Also converts values to other types if specified.
                 * @param message EncodingInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumRlp.Proto.EncodingInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this EncodingInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an EncodingOutput. */
            interface IEncodingOutput {

                /** EncodingOutput encoded */
                encoded?: (Uint8Array|null);

                /** EncodingOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** EncodingOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** RLP encoding output. */
            class EncodingOutput implements IEncodingOutput {

                /**
                 * Constructs a new EncodingOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.EthereumRlp.Proto.IEncodingOutput);

                /** EncodingOutput encoded. */
                public encoded: Uint8Array;

                /** EncodingOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** EncodingOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new EncodingOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns EncodingOutput instance
                 */
                public static create(properties?: TW.EthereumRlp.Proto.IEncodingOutput): TW.EthereumRlp.Proto.EncodingOutput;

                /**
                 * Encodes the specified EncodingOutput message. Does not implicitly {@link TW.EthereumRlp.Proto.EncodingOutput.verify|verify} messages.
                 * @param message EncodingOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.EthereumRlp.Proto.IEncodingOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an EncodingOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns EncodingOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.EthereumRlp.Proto.EncodingOutput;

                /**
                 * Verifies an EncodingOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an EncodingOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns EncodingOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.EthereumRlp.Proto.EncodingOutput;

                /**
                 * Creates a plain object from an EncodingOutput message. Also converts values to other types if specified.
                 * @param message EncodingOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.EthereumRlp.Proto.EncodingOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this EncodingOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Everscale. */
    namespace Everscale {

        /** Namespace Proto. */
        namespace Proto {

            /** MessageBehavior enum. */
            enum MessageBehavior {
                SimpleTransfer = 0,
                SendAllBalance = 1
            }

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer bounce */
                bounce?: (boolean|null);

                /** Transfer behavior */
                behavior?: (TW.Everscale.Proto.MessageBehavior|null);

                /** Transfer amount */
                amount?: (Long|null);

                /** Transfer expiredAt */
                expiredAt?: (number|null);

                /** Transfer to */
                to?: (string|null);

                /** Transfer encodedContractData */
                encodedContractData?: (string|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Everscale.Proto.ITransfer);

                /** Transfer bounce. */
                public bounce: boolean;

                /** Transfer behavior. */
                public behavior: TW.Everscale.Proto.MessageBehavior;

                /** Transfer amount. */
                public amount: Long;

                /** Transfer expiredAt. */
                public expiredAt: number;

                /** Transfer to. */
                public to: string;

                /** Transfer encodedContractData. */
                public encodedContractData?: (string|null);

                /** Transfer accountStateOneof. */
                public accountStateOneof?: "encodedContractData";

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.Everscale.Proto.ITransfer): TW.Everscale.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.Everscale.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Everscale.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Everscale.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Everscale.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Everscale.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput transfer */
                transfer?: (TW.Everscale.Proto.ITransfer|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Everscale.Proto.ISigningInput);

                /** SigningInput transfer. */
                public transfer?: (TW.Everscale.Proto.ITransfer|null);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput actionOneof. */
                public actionOneof?: "transfer";

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Everscale.Proto.ISigningInput): TW.Everscale.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Everscale.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Everscale.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Everscale.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Everscale.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Everscale.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Everscale.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Everscale.Proto.ISigningOutput): TW.Everscale.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Everscale.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Everscale.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Everscale.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Everscale.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Everscale.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Filecoin. */
    namespace Filecoin {

        /** Namespace Proto. */
        namespace Proto {

            /** DerivationType enum. */
            enum DerivationType {
                SECP256K1 = 0,
                DELEGATED = 1
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput to */
                to?: (string|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput value */
                value?: (Uint8Array|null);

                /** SigningInput gasLimit */
                gasLimit?: (Long|null);

                /** SigningInput gasFeeCap */
                gasFeeCap?: (Uint8Array|null);

                /** SigningInput gasPremium */
                gasPremium?: (Uint8Array|null);

                /** SigningInput params */
                params?: (Uint8Array|null);

                /** SigningInput derivation */
                derivation?: (TW.Filecoin.Proto.DerivationType|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Filecoin.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput to. */
                public to: string;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput value. */
                public value: Uint8Array;

                /** SigningInput gasLimit. */
                public gasLimit: Long;

                /** SigningInput gasFeeCap. */
                public gasFeeCap: Uint8Array;

                /** SigningInput gasPremium. */
                public gasPremium: Uint8Array;

                /** SigningInput params. */
                public params: Uint8Array;

                /** SigningInput derivation. */
                public derivation: TW.Filecoin.Proto.DerivationType;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Filecoin.Proto.ISigningInput): TW.Filecoin.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Filecoin.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Filecoin.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Filecoin.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Filecoin.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Filecoin.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Filecoin.Proto.ISigningOutput);

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Filecoin.Proto.ISigningOutput): TW.Filecoin.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Filecoin.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Filecoin.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Filecoin.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Filecoin.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Filecoin.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace FIO. */
    namespace FIO {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a PublicAddress. */
            interface IPublicAddress {

                /** PublicAddress coinSymbol */
                coinSymbol?: (string|null);

                /** PublicAddress address */
                address?: (string|null);
            }

            /** Represents a PublicAddress. */
            class PublicAddress implements IPublicAddress {

                /**
                 * Constructs a new PublicAddress.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.IPublicAddress);

                /** PublicAddress coinSymbol. */
                public coinSymbol: string;

                /** PublicAddress address. */
                public address: string;

                /**
                 * Creates a new PublicAddress instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PublicAddress instance
                 */
                public static create(properties?: TW.FIO.Proto.IPublicAddress): TW.FIO.Proto.PublicAddress;

                /**
                 * Encodes the specified PublicAddress message. Does not implicitly {@link TW.FIO.Proto.PublicAddress.verify|verify} messages.
                 * @param message PublicAddress message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.IPublicAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PublicAddress message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PublicAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.PublicAddress;

                /**
                 * Verifies a PublicAddress message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PublicAddress message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PublicAddress
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.PublicAddress;

                /**
                 * Creates a plain object from a PublicAddress message. Also converts values to other types if specified.
                 * @param message PublicAddress
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.PublicAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PublicAddress to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a NewFundsContent. */
            interface INewFundsContent {

                /** NewFundsContent payeePublicAddress */
                payeePublicAddress?: (string|null);

                /** NewFundsContent amount */
                amount?: (string|null);

                /** NewFundsContent coinSymbol */
                coinSymbol?: (string|null);

                /** NewFundsContent memo */
                memo?: (string|null);

                /** NewFundsContent hash */
                hash?: (string|null);

                /** NewFundsContent offlineUrl */
                offlineUrl?: (string|null);
            }

            /** Represents a NewFundsContent. */
            class NewFundsContent implements INewFundsContent {

                /**
                 * Constructs a new NewFundsContent.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.INewFundsContent);

                /** NewFundsContent payeePublicAddress. */
                public payeePublicAddress: string;

                /** NewFundsContent amount. */
                public amount: string;

                /** NewFundsContent coinSymbol. */
                public coinSymbol: string;

                /** NewFundsContent memo. */
                public memo: string;

                /** NewFundsContent hash. */
                public hash: string;

                /** NewFundsContent offlineUrl. */
                public offlineUrl: string;

                /**
                 * Creates a new NewFundsContent instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NewFundsContent instance
                 */
                public static create(properties?: TW.FIO.Proto.INewFundsContent): TW.FIO.Proto.NewFundsContent;

                /**
                 * Encodes the specified NewFundsContent message. Does not implicitly {@link TW.FIO.Proto.NewFundsContent.verify|verify} messages.
                 * @param message NewFundsContent message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.INewFundsContent, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NewFundsContent message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NewFundsContent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.NewFundsContent;

                /**
                 * Verifies a NewFundsContent message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NewFundsContent message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NewFundsContent
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.NewFundsContent;

                /**
                 * Creates a plain object from a NewFundsContent message. Also converts values to other types if specified.
                 * @param message NewFundsContent
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.NewFundsContent, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NewFundsContent to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Action. */
            interface IAction {

                /** Action registerFioAddressMessage */
                registerFioAddressMessage?: (TW.FIO.Proto.Action.IRegisterFioAddress|null);

                /** Action addPubAddressMessage */
                addPubAddressMessage?: (TW.FIO.Proto.Action.IAddPubAddress|null);

                /** Action transferMessage */
                transferMessage?: (TW.FIO.Proto.Action.ITransfer|null);

                /** Action renewFioAddressMessage */
                renewFioAddressMessage?: (TW.FIO.Proto.Action.IRenewFioAddress|null);

                /** Action newFundsRequestMessage */
                newFundsRequestMessage?: (TW.FIO.Proto.Action.INewFundsRequest|null);
            }

            /** Represents an Action. */
            class Action implements IAction {

                /**
                 * Constructs a new Action.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.IAction);

                /** Action registerFioAddressMessage. */
                public registerFioAddressMessage?: (TW.FIO.Proto.Action.IRegisterFioAddress|null);

                /** Action addPubAddressMessage. */
                public addPubAddressMessage?: (TW.FIO.Proto.Action.IAddPubAddress|null);

                /** Action transferMessage. */
                public transferMessage?: (TW.FIO.Proto.Action.ITransfer|null);

                /** Action renewFioAddressMessage. */
                public renewFioAddressMessage?: (TW.FIO.Proto.Action.IRenewFioAddress|null);

                /** Action newFundsRequestMessage. */
                public newFundsRequestMessage?: (TW.FIO.Proto.Action.INewFundsRequest|null);

                /** Action messageOneof. */
                public messageOneof?: ("registerFioAddressMessage"|"addPubAddressMessage"|"transferMessage"|"renewFioAddressMessage"|"newFundsRequestMessage");

                /**
                 * Creates a new Action instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Action instance
                 */
                public static create(properties?: TW.FIO.Proto.IAction): TW.FIO.Proto.Action;

                /**
                 * Encodes the specified Action message. Does not implicitly {@link TW.FIO.Proto.Action.verify|verify} messages.
                 * @param message Action message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.IAction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Action message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action;

                /**
                 * Verifies an Action message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Action
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action;

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @param message Action
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.Action, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Action to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Action {

                /** Properties of a RegisterFioAddress. */
                interface IRegisterFioAddress {

                    /** RegisterFioAddress fioAddress */
                    fioAddress?: (string|null);

                    /** RegisterFioAddress ownerFioPublicKey */
                    ownerFioPublicKey?: (string|null);

                    /** RegisterFioAddress fee */
                    fee?: (Long|null);
                }

                /** Represents a RegisterFioAddress. */
                class RegisterFioAddress implements IRegisterFioAddress {

                    /**
                     * Constructs a new RegisterFioAddress.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.FIO.Proto.Action.IRegisterFioAddress);

                    /** RegisterFioAddress fioAddress. */
                    public fioAddress: string;

                    /** RegisterFioAddress ownerFioPublicKey. */
                    public ownerFioPublicKey: string;

                    /** RegisterFioAddress fee. */
                    public fee: Long;

                    /**
                     * Creates a new RegisterFioAddress instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns RegisterFioAddress instance
                     */
                    public static create(properties?: TW.FIO.Proto.Action.IRegisterFioAddress): TW.FIO.Proto.Action.RegisterFioAddress;

                    /**
                     * Encodes the specified RegisterFioAddress message. Does not implicitly {@link TW.FIO.Proto.Action.RegisterFioAddress.verify|verify} messages.
                     * @param message RegisterFioAddress message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.FIO.Proto.Action.IRegisterFioAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a RegisterFioAddress message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns RegisterFioAddress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action.RegisterFioAddress;

                    /**
                     * Verifies a RegisterFioAddress message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a RegisterFioAddress message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns RegisterFioAddress
                     */
                    public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action.RegisterFioAddress;

                    /**
                     * Creates a plain object from a RegisterFioAddress message. Also converts values to other types if specified.
                     * @param message RegisterFioAddress
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.FIO.Proto.Action.RegisterFioAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this RegisterFioAddress to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an AddPubAddress. */
                interface IAddPubAddress {

                    /** AddPubAddress fioAddress */
                    fioAddress?: (string|null);

                    /** AddPubAddress publicAddresses */
                    publicAddresses?: (TW.FIO.Proto.IPublicAddress[]|null);

                    /** AddPubAddress fee */
                    fee?: (Long|null);
                }

                /** Represents an AddPubAddress. */
                class AddPubAddress implements IAddPubAddress {

                    /**
                     * Constructs a new AddPubAddress.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.FIO.Proto.Action.IAddPubAddress);

                    /** AddPubAddress fioAddress. */
                    public fioAddress: string;

                    /** AddPubAddress publicAddresses. */
                    public publicAddresses: TW.FIO.Proto.IPublicAddress[];

                    /** AddPubAddress fee. */
                    public fee: Long;

                    /**
                     * Creates a new AddPubAddress instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AddPubAddress instance
                     */
                    public static create(properties?: TW.FIO.Proto.Action.IAddPubAddress): TW.FIO.Proto.Action.AddPubAddress;

                    /**
                     * Encodes the specified AddPubAddress message. Does not implicitly {@link TW.FIO.Proto.Action.AddPubAddress.verify|verify} messages.
                     * @param message AddPubAddress message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.FIO.Proto.Action.IAddPubAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AddPubAddress message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AddPubAddress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action.AddPubAddress;

                    /**
                     * Verifies an AddPubAddress message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AddPubAddress message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AddPubAddress
                     */
                    public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action.AddPubAddress;

                    /**
                     * Creates a plain object from an AddPubAddress message. Also converts values to other types if specified.
                     * @param message AddPubAddress
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.FIO.Proto.Action.AddPubAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AddPubAddress to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer payeePublicKey */
                    payeePublicKey?: (string|null);

                    /** Transfer amount */
                    amount?: (Long|null);

                    /** Transfer fee */
                    fee?: (Long|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.FIO.Proto.Action.ITransfer);

                    /** Transfer payeePublicKey. */
                    public payeePublicKey: string;

                    /** Transfer amount. */
                    public amount: Long;

                    /** Transfer fee. */
                    public fee: Long;

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.FIO.Proto.Action.ITransfer): TW.FIO.Proto.Action.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.FIO.Proto.Action.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.FIO.Proto.Action.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.FIO.Proto.Action.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a RenewFioAddress. */
                interface IRenewFioAddress {

                    /** RenewFioAddress fioAddress */
                    fioAddress?: (string|null);

                    /** RenewFioAddress ownerFioPublicKey */
                    ownerFioPublicKey?: (string|null);

                    /** RenewFioAddress fee */
                    fee?: (Long|null);
                }

                /** Represents a RenewFioAddress. */
                class RenewFioAddress implements IRenewFioAddress {

                    /**
                     * Constructs a new RenewFioAddress.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.FIO.Proto.Action.IRenewFioAddress);

                    /** RenewFioAddress fioAddress. */
                    public fioAddress: string;

                    /** RenewFioAddress ownerFioPublicKey. */
                    public ownerFioPublicKey: string;

                    /** RenewFioAddress fee. */
                    public fee: Long;

                    /**
                     * Creates a new RenewFioAddress instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns RenewFioAddress instance
                     */
                    public static create(properties?: TW.FIO.Proto.Action.IRenewFioAddress): TW.FIO.Proto.Action.RenewFioAddress;

                    /**
                     * Encodes the specified RenewFioAddress message. Does not implicitly {@link TW.FIO.Proto.Action.RenewFioAddress.verify|verify} messages.
                     * @param message RenewFioAddress message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.FIO.Proto.Action.IRenewFioAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a RenewFioAddress message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns RenewFioAddress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action.RenewFioAddress;

                    /**
                     * Verifies a RenewFioAddress message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a RenewFioAddress message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns RenewFioAddress
                     */
                    public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action.RenewFioAddress;

                    /**
                     * Creates a plain object from a RenewFioAddress message. Also converts values to other types if specified.
                     * @param message RenewFioAddress
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.FIO.Proto.Action.RenewFioAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this RenewFioAddress to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a NewFundsRequest. */
                interface INewFundsRequest {

                    /** NewFundsRequest payerFioName */
                    payerFioName?: (string|null);

                    /** NewFundsRequest payerFioAddress */
                    payerFioAddress?: (string|null);

                    /** NewFundsRequest payeeFioName */
                    payeeFioName?: (string|null);

                    /** NewFundsRequest content */
                    content?: (TW.FIO.Proto.INewFundsContent|null);

                    /** NewFundsRequest fee */
                    fee?: (Long|null);
                }

                /** Represents a NewFundsRequest. */
                class NewFundsRequest implements INewFundsRequest {

                    /**
                     * Constructs a new NewFundsRequest.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.FIO.Proto.Action.INewFundsRequest);

                    /** NewFundsRequest payerFioName. */
                    public payerFioName: string;

                    /** NewFundsRequest payerFioAddress. */
                    public payerFioAddress: string;

                    /** NewFundsRequest payeeFioName. */
                    public payeeFioName: string;

                    /** NewFundsRequest content. */
                    public content?: (TW.FIO.Proto.INewFundsContent|null);

                    /** NewFundsRequest fee. */
                    public fee: Long;

                    /**
                     * Creates a new NewFundsRequest instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns NewFundsRequest instance
                     */
                    public static create(properties?: TW.FIO.Proto.Action.INewFundsRequest): TW.FIO.Proto.Action.NewFundsRequest;

                    /**
                     * Encodes the specified NewFundsRequest message. Does not implicitly {@link TW.FIO.Proto.Action.NewFundsRequest.verify|verify} messages.
                     * @param message NewFundsRequest message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.FIO.Proto.Action.INewFundsRequest, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a NewFundsRequest message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns NewFundsRequest
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.Action.NewFundsRequest;

                    /**
                     * Verifies a NewFundsRequest message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a NewFundsRequest message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns NewFundsRequest
                     */
                    public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.Action.NewFundsRequest;

                    /**
                     * Creates a plain object from a NewFundsRequest message. Also converts values to other types if specified.
                     * @param message NewFundsRequest
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.FIO.Proto.Action.NewFundsRequest, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this NewFundsRequest to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a ChainParams. */
            interface IChainParams {

                /** ChainParams chainId */
                chainId?: (Uint8Array|null);

                /** ChainParams headBlockNumber */
                headBlockNumber?: (Long|null);

                /** ChainParams refBlockPrefix */
                refBlockPrefix?: (Long|null);
            }

            /** Represents a ChainParams. */
            class ChainParams implements IChainParams {

                /**
                 * Constructs a new ChainParams.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.IChainParams);

                /** ChainParams chainId. */
                public chainId: Uint8Array;

                /** ChainParams headBlockNumber. */
                public headBlockNumber: Long;

                /** ChainParams refBlockPrefix. */
                public refBlockPrefix: Long;

                /**
                 * Creates a new ChainParams instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ChainParams instance
                 */
                public static create(properties?: TW.FIO.Proto.IChainParams): TW.FIO.Proto.ChainParams;

                /**
                 * Encodes the specified ChainParams message. Does not implicitly {@link TW.FIO.Proto.ChainParams.verify|verify} messages.
                 * @param message ChainParams message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.IChainParams, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ChainParams message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ChainParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.ChainParams;

                /**
                 * Verifies a ChainParams message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ChainParams message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ChainParams
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.ChainParams;

                /**
                 * Creates a plain object from a ChainParams message. Also converts values to other types if specified.
                 * @param message ChainParams
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.ChainParams, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ChainParams to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput expiry */
                expiry?: (number|null);

                /** SigningInput chainParams */
                chainParams?: (TW.FIO.Proto.IChainParams|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput tpid */
                tpid?: (string|null);

                /** SigningInput action */
                action?: (TW.FIO.Proto.IAction|null);

                /** SigningInput ownerPublicKey */
                ownerPublicKey?: (string|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.ISigningInput);

                /** SigningInput expiry. */
                public expiry: number;

                /** SigningInput chainParams. */
                public chainParams?: (TW.FIO.Proto.IChainParams|null);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput tpid. */
                public tpid: string;

                /** SigningInput action. */
                public action?: (TW.FIO.Proto.IAction|null);

                /** SigningInput ownerPublicKey. */
                public ownerPublicKey: string;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.FIO.Proto.ISigningInput): TW.FIO.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.FIO.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.FIO.Proto.ISigningOutput);

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.FIO.Proto.ISigningOutput): TW.FIO.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.FIO.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.FIO.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.FIO.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.FIO.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.FIO.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Greenfield. */
    namespace Greenfield {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of an Amount. */
            interface IAmount {

                /** Amount denom */
                denom?: (string|null);

                /** Amount amount */
                amount?: (string|null);
            }

            /** Represents an Amount. */
            class Amount implements IAmount {

                /**
                 * Constructs a new Amount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Greenfield.Proto.IAmount);

                /** Amount denom. */
                public denom: string;

                /** Amount amount. */
                public amount: string;

                /**
                 * Creates a new Amount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Amount instance
                 */
                public static create(properties?: TW.Greenfield.Proto.IAmount): TW.Greenfield.Proto.Amount;

                /**
                 * Encodes the specified Amount message. Does not implicitly {@link TW.Greenfield.Proto.Amount.verify|verify} messages.
                 * @param message Amount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Greenfield.Proto.IAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Amount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Amount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.Amount;

                /**
                 * Verifies an Amount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Amount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.Amount;

                /**
                 * Creates a plain object from an Amount message. Also converts values to other types if specified.
                 * @param message Amount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Greenfield.Proto.Amount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Amount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Fee. */
            interface IFee {

                /** Fee amounts */
                amounts?: (TW.Greenfield.Proto.IAmount[]|null);

                /** Fee gas */
                gas?: (Long|null);
            }

            /** Represents a Fee. */
            class Fee implements IFee {

                /**
                 * Constructs a new Fee.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Greenfield.Proto.IFee);

                /** Fee amounts. */
                public amounts: TW.Greenfield.Proto.IAmount[];

                /** Fee gas. */
                public gas: Long;

                /**
                 * Creates a new Fee instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Fee instance
                 */
                public static create(properties?: TW.Greenfield.Proto.IFee): TW.Greenfield.Proto.Fee;

                /**
                 * Encodes the specified Fee message. Does not implicitly {@link TW.Greenfield.Proto.Fee.verify|verify} messages.
                 * @param message Fee message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Greenfield.Proto.IFee, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Fee message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Fee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.Fee;

                /**
                 * Verifies a Fee message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Fee
                 */
                public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.Fee;

                /**
                 * Creates a plain object from a Fee message. Also converts values to other types if specified.
                 * @param message Fee
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Greenfield.Proto.Fee, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Fee to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** BroadcastMode enum. */
            enum BroadcastMode {
                SYNC = 0,
                ASYNC = 1
            }

            /** Properties of a Message. */
            interface IMessage {

                /** Message sendCoinsMessage */
                sendCoinsMessage?: (TW.Greenfield.Proto.Message.ISend|null);

                /** Message bridgeTransferOut */
                bridgeTransferOut?: (TW.Greenfield.Proto.Message.IBridgeTransferOut|null);
            }

            /** Represents a Message. */
            class Message implements IMessage {

                /**
                 * Constructs a new Message.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Greenfield.Proto.IMessage);

                /** Message sendCoinsMessage. */
                public sendCoinsMessage?: (TW.Greenfield.Proto.Message.ISend|null);

                /** Message bridgeTransferOut. */
                public bridgeTransferOut?: (TW.Greenfield.Proto.Message.IBridgeTransferOut|null);

                /** Message messageOneof. */
                public messageOneof?: ("sendCoinsMessage"|"bridgeTransferOut");

                /**
                 * Creates a new Message instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Message instance
                 */
                public static create(properties?: TW.Greenfield.Proto.IMessage): TW.Greenfield.Proto.Message;

                /**
                 * Encodes the specified Message message. Does not implicitly {@link TW.Greenfield.Proto.Message.verify|verify} messages.
                 * @param message Message message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Greenfield.Proto.IMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.Message;

                /**
                 * Verifies a Message message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Message
                 */
                public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.Message;

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @param message Message
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Greenfield.Proto.Message, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Message to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Message {

                /** Properties of a Send. */
                interface ISend {

                    /** Send fromAddress */
                    fromAddress?: (string|null);

                    /** Send toAddress */
                    toAddress?: (string|null);

                    /** Send amounts */
                    amounts?: (TW.Greenfield.Proto.IAmount[]|null);

                    /** Send typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a Send. */
                class Send implements ISend {

                    /**
                     * Constructs a new Send.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Greenfield.Proto.Message.ISend);

                    /** Send fromAddress. */
                    public fromAddress: string;

                    /** Send toAddress. */
                    public toAddress: string;

                    /** Send amounts. */
                    public amounts: TW.Greenfield.Proto.IAmount[];

                    /** Send typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new Send instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Send instance
                     */
                    public static create(properties?: TW.Greenfield.Proto.Message.ISend): TW.Greenfield.Proto.Message.Send;

                    /**
                     * Encodes the specified Send message. Does not implicitly {@link TW.Greenfield.Proto.Message.Send.verify|verify} messages.
                     * @param message Send message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Greenfield.Proto.Message.ISend, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Send message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Send
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.Message.Send;

                    /**
                     * Verifies a Send message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Send message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Send
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.Message.Send;

                    /**
                     * Creates a plain object from a Send message. Also converts values to other types if specified.
                     * @param message Send
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Greenfield.Proto.Message.Send, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Send to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BridgeTransferOut. */
                interface IBridgeTransferOut {

                    /** BridgeTransferOut fromAddress */
                    fromAddress?: (string|null);

                    /** BridgeTransferOut toAddress */
                    toAddress?: (string|null);

                    /** BridgeTransferOut amount */
                    amount?: (TW.Greenfield.Proto.IAmount|null);

                    /** BridgeTransferOut typePrefix */
                    typePrefix?: (string|null);
                }

                /** Represents a BridgeTransferOut. */
                class BridgeTransferOut implements IBridgeTransferOut {

                    /**
                     * Constructs a new BridgeTransferOut.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Greenfield.Proto.Message.IBridgeTransferOut);

                    /** BridgeTransferOut fromAddress. */
                    public fromAddress: string;

                    /** BridgeTransferOut toAddress. */
                    public toAddress: string;

                    /** BridgeTransferOut amount. */
                    public amount?: (TW.Greenfield.Proto.IAmount|null);

                    /** BridgeTransferOut typePrefix. */
                    public typePrefix: string;

                    /**
                     * Creates a new BridgeTransferOut instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BridgeTransferOut instance
                     */
                    public static create(properties?: TW.Greenfield.Proto.Message.IBridgeTransferOut): TW.Greenfield.Proto.Message.BridgeTransferOut;

                    /**
                     * Encodes the specified BridgeTransferOut message. Does not implicitly {@link TW.Greenfield.Proto.Message.BridgeTransferOut.verify|verify} messages.
                     * @param message BridgeTransferOut message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Greenfield.Proto.Message.IBridgeTransferOut, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BridgeTransferOut message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BridgeTransferOut
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.Message.BridgeTransferOut;

                    /**
                     * Verifies a BridgeTransferOut message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BridgeTransferOut message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BridgeTransferOut
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.Message.BridgeTransferOut;

                    /**
                     * Creates a plain object from a BridgeTransferOut message. Also converts values to other types if specified.
                     * @param message BridgeTransferOut
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Greenfield.Proto.Message.BridgeTransferOut, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BridgeTransferOut to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** EncodingMode enum. */
            enum EncodingMode {
                Protobuf = 0
            }

            /** SigningMode enum. */
            enum SigningMode {
                Eip712 = 0
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput encodingMode */
                encodingMode?: (TW.Greenfield.Proto.EncodingMode|null);

                /** SigningInput signingMode */
                signingMode?: (TW.Greenfield.Proto.SigningMode|null);

                /** SigningInput accountNumber */
                accountNumber?: (Long|null);

                /** SigningInput ethChainId */
                ethChainId?: (string|null);

                /** SigningInput cosmosChainId */
                cosmosChainId?: (string|null);

                /** SigningInput fee */
                fee?: (TW.Greenfield.Proto.IFee|null);

                /** SigningInput memo */
                memo?: (string|null);

                /** SigningInput sequence */
                sequence?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput messages */
                messages?: (TW.Greenfield.Proto.IMessage[]|null);

                /** SigningInput mode */
                mode?: (TW.Greenfield.Proto.BroadcastMode|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Greenfield.Proto.ISigningInput);

                /** SigningInput encodingMode. */
                public encodingMode: TW.Greenfield.Proto.EncodingMode;

                /** SigningInput signingMode. */
                public signingMode: TW.Greenfield.Proto.SigningMode;

                /** SigningInput accountNumber. */
                public accountNumber: Long;

                /** SigningInput ethChainId. */
                public ethChainId: string;

                /** SigningInput cosmosChainId. */
                public cosmosChainId: string;

                /** SigningInput fee. */
                public fee?: (TW.Greenfield.Proto.IFee|null);

                /** SigningInput memo. */
                public memo: string;

                /** SigningInput sequence. */
                public sequence: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput messages. */
                public messages: TW.Greenfield.Proto.IMessage[];

                /** SigningInput mode. */
                public mode: TW.Greenfield.Proto.BroadcastMode;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Greenfield.Proto.ISigningInput): TW.Greenfield.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Greenfield.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Greenfield.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Greenfield.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput serialized */
                serialized?: (string|null);

                /** SigningOutput signatureJson */
                signatureJson?: (string|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Greenfield.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput serialized. */
                public serialized: string;

                /** SigningOutput signatureJson. */
                public signatureJson: string;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Greenfield.Proto.ISigningOutput): TW.Greenfield.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Greenfield.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Greenfield.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Greenfield.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Greenfield.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Greenfield.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Harmony. */
    namespace Harmony {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput chainId */
                chainId?: (Uint8Array|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transactionMessage */
                transactionMessage?: (TW.Harmony.Proto.ITransactionMessage|null);

                /** SigningInput stakingMessage */
                stakingMessage?: (TW.Harmony.Proto.IStakingMessage|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.ISigningInput);

                /** SigningInput chainId. */
                public chainId: Uint8Array;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transactionMessage. */
                public transactionMessage?: (TW.Harmony.Proto.ITransactionMessage|null);

                /** SigningInput stakingMessage. */
                public stakingMessage?: (TW.Harmony.Proto.IStakingMessage|null);

                /** SigningInput messageOneof. */
                public messageOneof?: ("transactionMessage"|"stakingMessage");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Harmony.Proto.ISigningInput): TW.Harmony.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Harmony.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput v */
                v?: (Uint8Array|null);

                /** SigningOutput r */
                r?: (Uint8Array|null);

                /** SigningOutput s */
                s?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput v. */
                public v: Uint8Array;

                /** SigningOutput r. */
                public r: Uint8Array;

                /** SigningOutput s. */
                public s: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Harmony.Proto.ISigningOutput): TW.Harmony.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Harmony.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionMessage. */
            interface ITransactionMessage {

                /** TransactionMessage nonce */
                nonce?: (Uint8Array|null);

                /** TransactionMessage gasPrice */
                gasPrice?: (Uint8Array|null);

                /** TransactionMessage gasLimit */
                gasLimit?: (Uint8Array|null);

                /** TransactionMessage toAddress */
                toAddress?: (string|null);

                /** TransactionMessage amount */
                amount?: (Uint8Array|null);

                /** TransactionMessage payload */
                payload?: (Uint8Array|null);

                /** TransactionMessage fromShardId */
                fromShardId?: (Uint8Array|null);

                /** TransactionMessage toShardId */
                toShardId?: (Uint8Array|null);
            }

            /** Represents a TransactionMessage. */
            class TransactionMessage implements ITransactionMessage {

                /**
                 * Constructs a new TransactionMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.ITransactionMessage);

                /** TransactionMessage nonce. */
                public nonce: Uint8Array;

                /** TransactionMessage gasPrice. */
                public gasPrice: Uint8Array;

                /** TransactionMessage gasLimit. */
                public gasLimit: Uint8Array;

                /** TransactionMessage toAddress. */
                public toAddress: string;

                /** TransactionMessage amount. */
                public amount: Uint8Array;

                /** TransactionMessage payload. */
                public payload: Uint8Array;

                /** TransactionMessage fromShardId. */
                public fromShardId: Uint8Array;

                /** TransactionMessage toShardId. */
                public toShardId: Uint8Array;

                /**
                 * Creates a new TransactionMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionMessage instance
                 */
                public static create(properties?: TW.Harmony.Proto.ITransactionMessage): TW.Harmony.Proto.TransactionMessage;

                /**
                 * Encodes the specified TransactionMessage message. Does not implicitly {@link TW.Harmony.Proto.TransactionMessage.verify|verify} messages.
                 * @param message TransactionMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.ITransactionMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.TransactionMessage;

                /**
                 * Verifies a TransactionMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.TransactionMessage;

                /**
                 * Creates a plain object from a TransactionMessage message. Also converts values to other types if specified.
                 * @param message TransactionMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.TransactionMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a StakingMessage. */
            interface IStakingMessage {

                /** StakingMessage createValidatorMessage */
                createValidatorMessage?: (TW.Harmony.Proto.IDirectiveCreateValidator|null);

                /** StakingMessage editValidatorMessage */
                editValidatorMessage?: (TW.Harmony.Proto.IDirectiveEditValidator|null);

                /** StakingMessage delegateMessage */
                delegateMessage?: (TW.Harmony.Proto.IDirectiveDelegate|null);

                /** StakingMessage undelegateMessage */
                undelegateMessage?: (TW.Harmony.Proto.IDirectiveUndelegate|null);

                /** StakingMessage collectRewards */
                collectRewards?: (TW.Harmony.Proto.IDirectiveCollectRewards|null);

                /** StakingMessage nonce */
                nonce?: (Uint8Array|null);

                /** StakingMessage gasPrice */
                gasPrice?: (Uint8Array|null);

                /** StakingMessage gasLimit */
                gasLimit?: (Uint8Array|null);
            }

            /** Represents a StakingMessage. */
            class StakingMessage implements IStakingMessage {

                /**
                 * Constructs a new StakingMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IStakingMessage);

                /** StakingMessage createValidatorMessage. */
                public createValidatorMessage?: (TW.Harmony.Proto.IDirectiveCreateValidator|null);

                /** StakingMessage editValidatorMessage. */
                public editValidatorMessage?: (TW.Harmony.Proto.IDirectiveEditValidator|null);

                /** StakingMessage delegateMessage. */
                public delegateMessage?: (TW.Harmony.Proto.IDirectiveDelegate|null);

                /** StakingMessage undelegateMessage. */
                public undelegateMessage?: (TW.Harmony.Proto.IDirectiveUndelegate|null);

                /** StakingMessage collectRewards. */
                public collectRewards?: (TW.Harmony.Proto.IDirectiveCollectRewards|null);

                /** StakingMessage nonce. */
                public nonce: Uint8Array;

                /** StakingMessage gasPrice. */
                public gasPrice: Uint8Array;

                /** StakingMessage gasLimit. */
                public gasLimit: Uint8Array;

                /** StakingMessage stakeMsg. */
                public stakeMsg?: ("createValidatorMessage"|"editValidatorMessage"|"delegateMessage"|"undelegateMessage"|"collectRewards");

                /**
                 * Creates a new StakingMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StakingMessage instance
                 */
                public static create(properties?: TW.Harmony.Proto.IStakingMessage): TW.Harmony.Proto.StakingMessage;

                /**
                 * Encodes the specified StakingMessage message. Does not implicitly {@link TW.Harmony.Proto.StakingMessage.verify|verify} messages.
                 * @param message StakingMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IStakingMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StakingMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns StakingMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.StakingMessage;

                /**
                 * Verifies a StakingMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a StakingMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns StakingMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.StakingMessage;

                /**
                 * Creates a plain object from a StakingMessage message. Also converts values to other types if specified.
                 * @param message StakingMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.StakingMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this StakingMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Description. */
            interface IDescription {

                /** Description name */
                name?: (string|null);

                /** Description identity */
                identity?: (string|null);

                /** Description website */
                website?: (string|null);

                /** Description securityContact */
                securityContact?: (string|null);

                /** Description details */
                details?: (string|null);
            }

            /** Represents a Description. */
            class Description implements IDescription {

                /**
                 * Constructs a new Description.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDescription);

                /** Description name. */
                public name: string;

                /** Description identity. */
                public identity: string;

                /** Description website. */
                public website: string;

                /** Description securityContact. */
                public securityContact: string;

                /** Description details. */
                public details: string;

                /**
                 * Creates a new Description instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Description instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDescription): TW.Harmony.Proto.Description;

                /**
                 * Encodes the specified Description message. Does not implicitly {@link TW.Harmony.Proto.Description.verify|verify} messages.
                 * @param message Description message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDescription, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Description message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Description
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.Description;

                /**
                 * Verifies a Description message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Description message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Description
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.Description;

                /**
                 * Creates a plain object from a Description message. Also converts values to other types if specified.
                 * @param message Description
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.Description, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Description to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Decimal. */
            interface IDecimal {

                /** Decimal value */
                value?: (Uint8Array|null);

                /** Decimal precision */
                precision?: (Uint8Array|null);
            }

            /** Represents a Decimal. */
            class Decimal implements IDecimal {

                /**
                 * Constructs a new Decimal.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDecimal);

                /** Decimal value. */
                public value: Uint8Array;

                /** Decimal precision. */
                public precision: Uint8Array;

                /**
                 * Creates a new Decimal instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Decimal instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDecimal): TW.Harmony.Proto.Decimal;

                /**
                 * Encodes the specified Decimal message. Does not implicitly {@link TW.Harmony.Proto.Decimal.verify|verify} messages.
                 * @param message Decimal message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDecimal, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Decimal message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Decimal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.Decimal;

                /**
                 * Verifies a Decimal message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Decimal message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Decimal
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.Decimal;

                /**
                 * Creates a plain object from a Decimal message. Also converts values to other types if specified.
                 * @param message Decimal
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.Decimal, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Decimal to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CommissionRate. */
            interface ICommissionRate {

                /** CommissionRate rate */
                rate?: (TW.Harmony.Proto.IDecimal|null);

                /** CommissionRate maxRate */
                maxRate?: (TW.Harmony.Proto.IDecimal|null);

                /** CommissionRate maxChangeRate */
                maxChangeRate?: (TW.Harmony.Proto.IDecimal|null);
            }

            /** Represents a CommissionRate. */
            class CommissionRate implements ICommissionRate {

                /**
                 * Constructs a new CommissionRate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.ICommissionRate);

                /** CommissionRate rate. */
                public rate?: (TW.Harmony.Proto.IDecimal|null);

                /** CommissionRate maxRate. */
                public maxRate?: (TW.Harmony.Proto.IDecimal|null);

                /** CommissionRate maxChangeRate. */
                public maxChangeRate?: (TW.Harmony.Proto.IDecimal|null);

                /**
                 * Creates a new CommissionRate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CommissionRate instance
                 */
                public static create(properties?: TW.Harmony.Proto.ICommissionRate): TW.Harmony.Proto.CommissionRate;

                /**
                 * Encodes the specified CommissionRate message. Does not implicitly {@link TW.Harmony.Proto.CommissionRate.verify|verify} messages.
                 * @param message CommissionRate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.ICommissionRate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CommissionRate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CommissionRate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.CommissionRate;

                /**
                 * Verifies a CommissionRate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CommissionRate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CommissionRate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.CommissionRate;

                /**
                 * Creates a plain object from a CommissionRate message. Also converts values to other types if specified.
                 * @param message CommissionRate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.CommissionRate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CommissionRate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DirectiveCreateValidator. */
            interface IDirectiveCreateValidator {

                /** DirectiveCreateValidator validatorAddress */
                validatorAddress?: (string|null);

                /** DirectiveCreateValidator description */
                description?: (TW.Harmony.Proto.IDescription|null);

                /** DirectiveCreateValidator commissionRates */
                commissionRates?: (TW.Harmony.Proto.ICommissionRate|null);

                /** DirectiveCreateValidator minSelfDelegation */
                minSelfDelegation?: (Uint8Array|null);

                /** DirectiveCreateValidator maxTotalDelegation */
                maxTotalDelegation?: (Uint8Array|null);

                /** DirectiveCreateValidator slotPubKeys */
                slotPubKeys?: (Uint8Array[]|null);

                /** DirectiveCreateValidator slotKeySigs */
                slotKeySigs?: (Uint8Array[]|null);

                /** DirectiveCreateValidator amount */
                amount?: (Uint8Array|null);
            }

            /** Represents a DirectiveCreateValidator. */
            class DirectiveCreateValidator implements IDirectiveCreateValidator {

                /**
                 * Constructs a new DirectiveCreateValidator.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDirectiveCreateValidator);

                /** DirectiveCreateValidator validatorAddress. */
                public validatorAddress: string;

                /** DirectiveCreateValidator description. */
                public description?: (TW.Harmony.Proto.IDescription|null);

                /** DirectiveCreateValidator commissionRates. */
                public commissionRates?: (TW.Harmony.Proto.ICommissionRate|null);

                /** DirectiveCreateValidator minSelfDelegation. */
                public minSelfDelegation: Uint8Array;

                /** DirectiveCreateValidator maxTotalDelegation. */
                public maxTotalDelegation: Uint8Array;

                /** DirectiveCreateValidator slotPubKeys. */
                public slotPubKeys: Uint8Array[];

                /** DirectiveCreateValidator slotKeySigs. */
                public slotKeySigs: Uint8Array[];

                /** DirectiveCreateValidator amount. */
                public amount: Uint8Array;

                /**
                 * Creates a new DirectiveCreateValidator instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DirectiveCreateValidator instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDirectiveCreateValidator): TW.Harmony.Proto.DirectiveCreateValidator;

                /**
                 * Encodes the specified DirectiveCreateValidator message. Does not implicitly {@link TW.Harmony.Proto.DirectiveCreateValidator.verify|verify} messages.
                 * @param message DirectiveCreateValidator message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDirectiveCreateValidator, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DirectiveCreateValidator message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DirectiveCreateValidator
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.DirectiveCreateValidator;

                /**
                 * Verifies a DirectiveCreateValidator message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DirectiveCreateValidator message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DirectiveCreateValidator
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.DirectiveCreateValidator;

                /**
                 * Creates a plain object from a DirectiveCreateValidator message. Also converts values to other types if specified.
                 * @param message DirectiveCreateValidator
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.DirectiveCreateValidator, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DirectiveCreateValidator to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DirectiveEditValidator. */
            interface IDirectiveEditValidator {

                /** DirectiveEditValidator validatorAddress */
                validatorAddress?: (string|null);

                /** DirectiveEditValidator description */
                description?: (TW.Harmony.Proto.IDescription|null);

                /** DirectiveEditValidator commissionRate */
                commissionRate?: (TW.Harmony.Proto.IDecimal|null);

                /** DirectiveEditValidator minSelfDelegation */
                minSelfDelegation?: (Uint8Array|null);

                /** DirectiveEditValidator maxTotalDelegation */
                maxTotalDelegation?: (Uint8Array|null);

                /** DirectiveEditValidator slotKeyToRemove */
                slotKeyToRemove?: (Uint8Array|null);

                /** DirectiveEditValidator slotKeyToAdd */
                slotKeyToAdd?: (Uint8Array|null);

                /** DirectiveEditValidator slotKeyToAddSig */
                slotKeyToAddSig?: (Uint8Array|null);

                /** DirectiveEditValidator active */
                active?: (Uint8Array|null);
            }

            /** Represents a DirectiveEditValidator. */
            class DirectiveEditValidator implements IDirectiveEditValidator {

                /**
                 * Constructs a new DirectiveEditValidator.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDirectiveEditValidator);

                /** DirectiveEditValidator validatorAddress. */
                public validatorAddress: string;

                /** DirectiveEditValidator description. */
                public description?: (TW.Harmony.Proto.IDescription|null);

                /** DirectiveEditValidator commissionRate. */
                public commissionRate?: (TW.Harmony.Proto.IDecimal|null);

                /** DirectiveEditValidator minSelfDelegation. */
                public minSelfDelegation: Uint8Array;

                /** DirectiveEditValidator maxTotalDelegation. */
                public maxTotalDelegation: Uint8Array;

                /** DirectiveEditValidator slotKeyToRemove. */
                public slotKeyToRemove: Uint8Array;

                /** DirectiveEditValidator slotKeyToAdd. */
                public slotKeyToAdd: Uint8Array;

                /** DirectiveEditValidator slotKeyToAddSig. */
                public slotKeyToAddSig: Uint8Array;

                /** DirectiveEditValidator active. */
                public active: Uint8Array;

                /**
                 * Creates a new DirectiveEditValidator instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DirectiveEditValidator instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDirectiveEditValidator): TW.Harmony.Proto.DirectiveEditValidator;

                /**
                 * Encodes the specified DirectiveEditValidator message. Does not implicitly {@link TW.Harmony.Proto.DirectiveEditValidator.verify|verify} messages.
                 * @param message DirectiveEditValidator message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDirectiveEditValidator, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DirectiveEditValidator message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DirectiveEditValidator
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.DirectiveEditValidator;

                /**
                 * Verifies a DirectiveEditValidator message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DirectiveEditValidator message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DirectiveEditValidator
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.DirectiveEditValidator;

                /**
                 * Creates a plain object from a DirectiveEditValidator message. Also converts values to other types if specified.
                 * @param message DirectiveEditValidator
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.DirectiveEditValidator, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DirectiveEditValidator to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DirectiveDelegate. */
            interface IDirectiveDelegate {

                /** DirectiveDelegate delegatorAddress */
                delegatorAddress?: (string|null);

                /** DirectiveDelegate validatorAddress */
                validatorAddress?: (string|null);

                /** DirectiveDelegate amount */
                amount?: (Uint8Array|null);
            }

            /** Represents a DirectiveDelegate. */
            class DirectiveDelegate implements IDirectiveDelegate {

                /**
                 * Constructs a new DirectiveDelegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDirectiveDelegate);

                /** DirectiveDelegate delegatorAddress. */
                public delegatorAddress: string;

                /** DirectiveDelegate validatorAddress. */
                public validatorAddress: string;

                /** DirectiveDelegate amount. */
                public amount: Uint8Array;

                /**
                 * Creates a new DirectiveDelegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DirectiveDelegate instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDirectiveDelegate): TW.Harmony.Proto.DirectiveDelegate;

                /**
                 * Encodes the specified DirectiveDelegate message. Does not implicitly {@link TW.Harmony.Proto.DirectiveDelegate.verify|verify} messages.
                 * @param message DirectiveDelegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDirectiveDelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DirectiveDelegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DirectiveDelegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.DirectiveDelegate;

                /**
                 * Verifies a DirectiveDelegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DirectiveDelegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DirectiveDelegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.DirectiveDelegate;

                /**
                 * Creates a plain object from a DirectiveDelegate message. Also converts values to other types if specified.
                 * @param message DirectiveDelegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.DirectiveDelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DirectiveDelegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DirectiveUndelegate. */
            interface IDirectiveUndelegate {

                /** DirectiveUndelegate delegatorAddress */
                delegatorAddress?: (string|null);

                /** DirectiveUndelegate validatorAddress */
                validatorAddress?: (string|null);

                /** DirectiveUndelegate amount */
                amount?: (Uint8Array|null);
            }

            /** Represents a DirectiveUndelegate. */
            class DirectiveUndelegate implements IDirectiveUndelegate {

                /**
                 * Constructs a new DirectiveUndelegate.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDirectiveUndelegate);

                /** DirectiveUndelegate delegatorAddress. */
                public delegatorAddress: string;

                /** DirectiveUndelegate validatorAddress. */
                public validatorAddress: string;

                /** DirectiveUndelegate amount. */
                public amount: Uint8Array;

                /**
                 * Creates a new DirectiveUndelegate instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DirectiveUndelegate instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDirectiveUndelegate): TW.Harmony.Proto.DirectiveUndelegate;

                /**
                 * Encodes the specified DirectiveUndelegate message. Does not implicitly {@link TW.Harmony.Proto.DirectiveUndelegate.verify|verify} messages.
                 * @param message DirectiveUndelegate message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDirectiveUndelegate, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DirectiveUndelegate message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DirectiveUndelegate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.DirectiveUndelegate;

                /**
                 * Verifies a DirectiveUndelegate message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DirectiveUndelegate message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DirectiveUndelegate
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.DirectiveUndelegate;

                /**
                 * Creates a plain object from a DirectiveUndelegate message. Also converts values to other types if specified.
                 * @param message DirectiveUndelegate
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.DirectiveUndelegate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DirectiveUndelegate to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DirectiveCollectRewards. */
            interface IDirectiveCollectRewards {

                /** DirectiveCollectRewards delegatorAddress */
                delegatorAddress?: (string|null);
            }

            /** Represents a DirectiveCollectRewards. */
            class DirectiveCollectRewards implements IDirectiveCollectRewards {

                /**
                 * Constructs a new DirectiveCollectRewards.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Harmony.Proto.IDirectiveCollectRewards);

                /** DirectiveCollectRewards delegatorAddress. */
                public delegatorAddress: string;

                /**
                 * Creates a new DirectiveCollectRewards instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DirectiveCollectRewards instance
                 */
                public static create(properties?: TW.Harmony.Proto.IDirectiveCollectRewards): TW.Harmony.Proto.DirectiveCollectRewards;

                /**
                 * Encodes the specified DirectiveCollectRewards message. Does not implicitly {@link TW.Harmony.Proto.DirectiveCollectRewards.verify|verify} messages.
                 * @param message DirectiveCollectRewards message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Harmony.Proto.IDirectiveCollectRewards, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DirectiveCollectRewards message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DirectiveCollectRewards
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Harmony.Proto.DirectiveCollectRewards;

                /**
                 * Verifies a DirectiveCollectRewards message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DirectiveCollectRewards message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DirectiveCollectRewards
                 */
                public static fromObject(object: { [k: string]: any }): TW.Harmony.Proto.DirectiveCollectRewards;

                /**
                 * Creates a plain object from a DirectiveCollectRewards message. Also converts values to other types if specified.
                 * @param message DirectiveCollectRewards
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Harmony.Proto.DirectiveCollectRewards, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DirectiveCollectRewards to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Hedera. */
    namespace Hedera {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Timestamp. */
            interface ITimestamp {

                /** Timestamp seconds */
                seconds?: (Long|null);

                /** Timestamp nanos */
                nanos?: (number|null);
            }

            /** Represents a Timestamp. */
            class Timestamp implements ITimestamp {

                /**
                 * Constructs a new Timestamp.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ITimestamp);

                /** Timestamp seconds. */
                public seconds: Long;

                /** Timestamp nanos. */
                public nanos: number;

                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Timestamp instance
                 */
                public static create(properties?: TW.Hedera.Proto.ITimestamp): TW.Hedera.Proto.Timestamp;

                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link TW.Hedera.Proto.Timestamp.verify|verify} messages.
                 * @param message Timestamp message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ITimestamp, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.Timestamp;

                /**
                 * Verifies a Timestamp message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Timestamp
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.Timestamp;

                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @param message Timestamp
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.Timestamp, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Timestamp to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionID. */
            interface ITransactionID {

                /** TransactionID transactionValidStart */
                transactionValidStart?: (TW.Hedera.Proto.ITimestamp|null);

                /** TransactionID accountID */
                accountID?: (string|null);

                /** TransactionID scheduled */
                scheduled?: (boolean|null);

                /** TransactionID nonce */
                nonce?: (number|null);
            }

            /** Represents a TransactionID. */
            class TransactionID implements ITransactionID {

                /**
                 * Constructs a new TransactionID.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ITransactionID);

                /** TransactionID transactionValidStart. */
                public transactionValidStart?: (TW.Hedera.Proto.ITimestamp|null);

                /** TransactionID accountID. */
                public accountID: string;

                /** TransactionID scheduled. */
                public scheduled: boolean;

                /** TransactionID nonce. */
                public nonce: number;

                /**
                 * Creates a new TransactionID instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionID instance
                 */
                public static create(properties?: TW.Hedera.Proto.ITransactionID): TW.Hedera.Proto.TransactionID;

                /**
                 * Encodes the specified TransactionID message. Does not implicitly {@link TW.Hedera.Proto.TransactionID.verify|verify} messages.
                 * @param message TransactionID message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ITransactionID, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionID message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionID
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.TransactionID;

                /**
                 * Verifies a TransactionID message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionID message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionID
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.TransactionID;

                /**
                 * Creates a plain object from a TransactionID message. Also converts values to other types if specified.
                 * @param message TransactionID
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.TransactionID, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionID to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransferMessage. */
            interface ITransferMessage {

                /** TransferMessage from */
                from?: (string|null);

                /** TransferMessage to */
                to?: (string|null);

                /** TransferMessage amount */
                amount?: (Long|null);
            }

            /** Represents a TransferMessage. */
            class TransferMessage implements ITransferMessage {

                /**
                 * Constructs a new TransferMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ITransferMessage);

                /** TransferMessage from. */
                public from: string;

                /** TransferMessage to. */
                public to: string;

                /** TransferMessage amount. */
                public amount: Long;

                /**
                 * Creates a new TransferMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferMessage instance
                 */
                public static create(properties?: TW.Hedera.Proto.ITransferMessage): TW.Hedera.Proto.TransferMessage;

                /**
                 * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Hedera.Proto.TransferMessage.verify|verify} messages.
                 * @param message TransferMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ITransferMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.TransferMessage;

                /**
                 * Verifies a TransferMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.TransferMessage;

                /**
                 * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                 * @param message TransferMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.TransferMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionBody. */
            interface ITransactionBody {

                /** TransactionBody transactionID */
                transactionID?: (TW.Hedera.Proto.ITransactionID|null);

                /** TransactionBody nodeAccountID */
                nodeAccountID?: (string|null);

                /** TransactionBody transactionFee */
                transactionFee?: (Long|null);

                /** TransactionBody transactionValidDuration */
                transactionValidDuration?: (Long|null);

                /** TransactionBody memo */
                memo?: (string|null);

                /** TransactionBody transfer */
                transfer?: (TW.Hedera.Proto.ITransferMessage|null);
            }

            /** Represents a TransactionBody. */
            class TransactionBody implements ITransactionBody {

                /**
                 * Constructs a new TransactionBody.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ITransactionBody);

                /** TransactionBody transactionID. */
                public transactionID?: (TW.Hedera.Proto.ITransactionID|null);

                /** TransactionBody nodeAccountID. */
                public nodeAccountID: string;

                /** TransactionBody transactionFee. */
                public transactionFee: Long;

                /** TransactionBody transactionValidDuration. */
                public transactionValidDuration: Long;

                /** TransactionBody memo. */
                public memo: string;

                /** TransactionBody transfer. */
                public transfer?: (TW.Hedera.Proto.ITransferMessage|null);

                /** TransactionBody data. */
                public data?: "transfer";

                /**
                 * Creates a new TransactionBody instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionBody instance
                 */
                public static create(properties?: TW.Hedera.Proto.ITransactionBody): TW.Hedera.Proto.TransactionBody;

                /**
                 * Encodes the specified TransactionBody message. Does not implicitly {@link TW.Hedera.Proto.TransactionBody.verify|verify} messages.
                 * @param message TransactionBody message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ITransactionBody, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionBody message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.TransactionBody;

                /**
                 * Verifies a TransactionBody message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionBody message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionBody
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.TransactionBody;

                /**
                 * Creates a plain object from a TransactionBody message. Also converts values to other types if specified.
                 * @param message TransactionBody
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.TransactionBody, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionBody to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput body */
                body?: (TW.Hedera.Proto.ITransactionBody|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput body. */
                public body?: (TW.Hedera.Proto.ITransactionBody|null);

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Hedera.Proto.ISigningInput): TW.Hedera.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Hedera.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Hedera.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Hedera.Proto.ISigningOutput): TW.Hedera.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Hedera.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Hedera.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Hedera.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Hedera.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Hedera.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Icon. */
    namespace Icon {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput fromAddress */
                fromAddress?: (string|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput value */
                value?: (Uint8Array|null);

                /** SigningInput stepLimit */
                stepLimit?: (Uint8Array|null);

                /** SigningInput timestamp */
                timestamp?: (Long|null);

                /** SigningInput nonce */
                nonce?: (Uint8Array|null);

                /** SigningInput networkId */
                networkId?: (Uint8Array|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Icon.Proto.ISigningInput);

                /** SigningInput fromAddress. */
                public fromAddress: string;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput value. */
                public value: Uint8Array;

                /** SigningInput stepLimit. */
                public stepLimit: Uint8Array;

                /** SigningInput timestamp. */
                public timestamp: Long;

                /** SigningInput nonce. */
                public nonce: Uint8Array;

                /** SigningInput networkId. */
                public networkId: Uint8Array;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Icon.Proto.ISigningInput): TW.Icon.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Icon.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Icon.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Icon.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Icon.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Icon.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Icon.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Icon.Proto.ISigningOutput): TW.Icon.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Icon.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Icon.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Icon.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Icon.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Icon.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace InternetComputer. */
    namespace InternetComputer {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction transfer */
                transfer?: (TW.InternetComputer.Proto.Transaction.ITransfer|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.InternetComputer.Proto.ITransaction);

                /** Transaction transfer. */
                public transfer?: (TW.InternetComputer.Proto.Transaction.ITransfer|null);

                /** Transaction transactionOneof. */
                public transactionOneof?: "transfer";

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.InternetComputer.Proto.ITransaction): TW.InternetComputer.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.InternetComputer.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.InternetComputer.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.InternetComputer.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.InternetComputer.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.InternetComputer.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Transaction {

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer toAccountIdentifier */
                    toAccountIdentifier?: (string|null);

                    /** Transfer amount */
                    amount?: (Long|null);

                    /** Transfer memo */
                    memo?: (Long|null);

                    /** Transfer currentTimestampNanos */
                    currentTimestampNanos?: (Long|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.InternetComputer.Proto.Transaction.ITransfer);

                    /** Transfer toAccountIdentifier. */
                    public toAccountIdentifier: string;

                    /** Transfer amount. */
                    public amount: Long;

                    /** Transfer memo. */
                    public memo: Long;

                    /** Transfer currentTimestampNanos. */
                    public currentTimestampNanos: Long;

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.InternetComputer.Proto.Transaction.ITransfer): TW.InternetComputer.Proto.Transaction.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.InternetComputer.Proto.Transaction.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.InternetComputer.Proto.Transaction.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.InternetComputer.Proto.Transaction.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.InternetComputer.Proto.Transaction.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.InternetComputer.Proto.Transaction.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transaction */
                transaction?: (TW.InternetComputer.Proto.ITransaction|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.InternetComputer.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transaction. */
                public transaction?: (TW.InternetComputer.Proto.ITransaction|null);

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.InternetComputer.Proto.ISigningInput): TW.InternetComputer.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.InternetComputer.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.InternetComputer.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.InternetComputer.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.InternetComputer.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.InternetComputer.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signedTransaction */
                signedTransaction?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.InternetComputer.Proto.ISigningOutput);

                /** SigningOutput signedTransaction. */
                public signedTransaction: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.InternetComputer.Proto.ISigningOutput): TW.InternetComputer.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.InternetComputer.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.InternetComputer.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.InternetComputer.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.InternetComputer.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.InternetComputer.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace IOST. */
    namespace IOST {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of an Action. */
            interface IAction {

                /** Action contract */
                contract?: (string|null);

                /** Action actionName */
                actionName?: (string|null);

                /** Action data */
                data?: (string|null);
            }

            /** Represents an Action. */
            class Action implements IAction {

                /**
                 * Constructs a new Action.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.IAction);

                /** Action contract. */
                public contract: string;

                /** Action actionName. */
                public actionName: string;

                /** Action data. */
                public data: string;

                /**
                 * Creates a new Action instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Action instance
                 */
                public static create(properties?: TW.IOST.Proto.IAction): TW.IOST.Proto.Action;

                /**
                 * Encodes the specified Action message. Does not implicitly {@link TW.IOST.Proto.Action.verify|verify} messages.
                 * @param message Action message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.IAction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Action message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.Action;

                /**
                 * Verifies an Action message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Action
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.Action;

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @param message Action
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.Action, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Action to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AmountLimit. */
            interface IAmountLimit {

                /** AmountLimit token */
                token?: (string|null);

                /** AmountLimit value */
                value?: (string|null);
            }

            /** Represents an AmountLimit. */
            class AmountLimit implements IAmountLimit {

                /**
                 * Constructs a new AmountLimit.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.IAmountLimit);

                /** AmountLimit token. */
                public token: string;

                /** AmountLimit value. */
                public value: string;

                /**
                 * Creates a new AmountLimit instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AmountLimit instance
                 */
                public static create(properties?: TW.IOST.Proto.IAmountLimit): TW.IOST.Proto.AmountLimit;

                /**
                 * Encodes the specified AmountLimit message. Does not implicitly {@link TW.IOST.Proto.AmountLimit.verify|verify} messages.
                 * @param message AmountLimit message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.IAmountLimit, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AmountLimit message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AmountLimit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.AmountLimit;

                /**
                 * Verifies an AmountLimit message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AmountLimit message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AmountLimit
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.AmountLimit;

                /**
                 * Creates a plain object from an AmountLimit message. Also converts values to other types if specified.
                 * @param message AmountLimit
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.AmountLimit, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AmountLimit to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Algorithm enum. */
            enum Algorithm {
                UNKNOWN = 0,
                SECP256K1 = 1,
                ED25519 = 2
            }

            /** Properties of a Signature. */
            interface ISignature {

                /** Signature algorithm */
                algorithm?: (TW.IOST.Proto.Algorithm|null);

                /** Signature signature */
                signature?: (Uint8Array|null);

                /** Signature publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a Signature. */
            class Signature implements ISignature {

                /**
                 * Constructs a new Signature.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.ISignature);

                /** Signature algorithm. */
                public algorithm: TW.IOST.Proto.Algorithm;

                /** Signature signature. */
                public signature: Uint8Array;

                /** Signature publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new Signature instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Signature instance
                 */
                public static create(properties?: TW.IOST.Proto.ISignature): TW.IOST.Proto.Signature;

                /**
                 * Encodes the specified Signature message. Does not implicitly {@link TW.IOST.Proto.Signature.verify|verify} messages.
                 * @param message Signature message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.ISignature, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Signature message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Signature
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.Signature;

                /**
                 * Verifies a Signature message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Signature
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.Signature;

                /**
                 * Creates a plain object from a Signature message. Also converts values to other types if specified.
                 * @param message Signature
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.Signature, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Signature to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction time */
                time?: (Long|null);

                /** Transaction expiration */
                expiration?: (Long|null);

                /** Transaction gasRatio */
                gasRatio?: (number|null);

                /** Transaction gasLimit */
                gasLimit?: (number|null);

                /** Transaction delay */
                delay?: (Long|null);

                /** Transaction chainId */
                chainId?: (number|null);

                /** Transaction actions */
                actions?: (TW.IOST.Proto.IAction[]|null);

                /** Transaction amountLimit */
                amountLimit?: (TW.IOST.Proto.IAmountLimit[]|null);

                /** Transaction signers */
                signers?: (string[]|null);

                /** Transaction signatures */
                signatures?: (TW.IOST.Proto.ISignature[]|null);

                /** Transaction publisher */
                publisher?: (string|null);

                /** Transaction publisherSigs */
                publisherSigs?: (TW.IOST.Proto.ISignature[]|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.ITransaction);

                /** Transaction time. */
                public time: Long;

                /** Transaction expiration. */
                public expiration: Long;

                /** Transaction gasRatio. */
                public gasRatio: number;

                /** Transaction gasLimit. */
                public gasLimit: number;

                /** Transaction delay. */
                public delay: Long;

                /** Transaction chainId. */
                public chainId: number;

                /** Transaction actions. */
                public actions: TW.IOST.Proto.IAction[];

                /** Transaction amountLimit. */
                public amountLimit: TW.IOST.Proto.IAmountLimit[];

                /** Transaction signers. */
                public signers: string[];

                /** Transaction signatures. */
                public signatures: TW.IOST.Proto.ISignature[];

                /** Transaction publisher. */
                public publisher: string;

                /** Transaction publisherSigs. */
                public publisherSigs: TW.IOST.Proto.ISignature[];

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.IOST.Proto.ITransaction): TW.IOST.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.IOST.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AccountInfo. */
            interface IAccountInfo {

                /** AccountInfo name */
                name?: (string|null);

                /** AccountInfo activeKey */
                activeKey?: (Uint8Array|null);

                /** AccountInfo ownerKey */
                ownerKey?: (Uint8Array|null);
            }

            /** Represents an AccountInfo. */
            class AccountInfo implements IAccountInfo {

                /**
                 * Constructs a new AccountInfo.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.IAccountInfo);

                /** AccountInfo name. */
                public name: string;

                /** AccountInfo activeKey. */
                public activeKey: Uint8Array;

                /** AccountInfo ownerKey. */
                public ownerKey: Uint8Array;

                /**
                 * Creates a new AccountInfo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccountInfo instance
                 */
                public static create(properties?: TW.IOST.Proto.IAccountInfo): TW.IOST.Proto.AccountInfo;

                /**
                 * Encodes the specified AccountInfo message. Does not implicitly {@link TW.IOST.Proto.AccountInfo.verify|verify} messages.
                 * @param message AccountInfo message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.IAccountInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccountInfo message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AccountInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.AccountInfo;

                /**
                 * Verifies an AccountInfo message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AccountInfo message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AccountInfo
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.AccountInfo;

                /**
                 * Creates a plain object from an AccountInfo message. Also converts values to other types if specified.
                 * @param message AccountInfo
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.AccountInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AccountInfo to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput account */
                account?: (TW.IOST.Proto.IAccountInfo|null);

                /** SigningInput transactionTemplate */
                transactionTemplate?: (TW.IOST.Proto.ITransaction|null);

                /** SigningInput transferDestination */
                transferDestination?: (string|null);

                /** SigningInput transferAmount */
                transferAmount?: (string|null);

                /** SigningInput transferMemo */
                transferMemo?: (string|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.ISigningInput);

                /** SigningInput account. */
                public account?: (TW.IOST.Proto.IAccountInfo|null);

                /** SigningInput transactionTemplate. */
                public transactionTemplate?: (TW.IOST.Proto.ITransaction|null);

                /** SigningInput transferDestination. */
                public transferDestination: string;

                /** SigningInput transferAmount. */
                public transferAmount: string;

                /** SigningInput transferMemo. */
                public transferMemo: string;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.IOST.Proto.ISigningInput): TW.IOST.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.IOST.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput transaction */
                transaction?: (TW.IOST.Proto.ITransaction|null);

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IOST.Proto.ISigningOutput);

                /** SigningOutput transaction. */
                public transaction?: (TW.IOST.Proto.ITransaction|null);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.IOST.Proto.ISigningOutput): TW.IOST.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.IOST.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IOST.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IOST.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.IOST.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IOST.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace IoTeX. */
    namespace IoTeX {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer amount */
                amount?: (string|null);

                /** Transfer recipient */
                recipient?: (string|null);

                /** Transfer payload */
                payload?: (Uint8Array|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.ITransfer);

                /** Transfer amount. */
                public amount: string;

                /** Transfer recipient. */
                public recipient: string;

                /** Transfer payload. */
                public payload: Uint8Array;

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.IoTeX.Proto.ITransfer): TW.IoTeX.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.IoTeX.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Staking. */
            interface IStaking {

                /** Staking stakeCreate */
                stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** Staking stakeUnstake */
                stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** Staking stakeWithdraw */
                stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** Staking stakeAddDeposit */
                stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** Staking stakeRestake */
                stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** Staking stakeChangeCandidate */
                stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** Staking stakeTransferOwnership */
                stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** Staking candidateRegister */
                candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** Staking candidateUpdate */
                candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);
            }

            /** Represents a Staking. */
            class Staking implements IStaking {

                /**
                 * Constructs a new Staking.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.IStaking);

                /** Staking stakeCreate. */
                public stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** Staking stakeUnstake. */
                public stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** Staking stakeWithdraw. */
                public stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** Staking stakeAddDeposit. */
                public stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** Staking stakeRestake. */
                public stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** Staking stakeChangeCandidate. */
                public stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** Staking stakeTransferOwnership. */
                public stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** Staking candidateRegister. */
                public candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** Staking candidateUpdate. */
                public candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);

                /** Staking message. */
                public message?: ("stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate");

                /**
                 * Creates a new Staking instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Staking instance
                 */
                public static create(properties?: TW.IoTeX.Proto.IStaking): TW.IoTeX.Proto.Staking;

                /**
                 * Encodes the specified Staking message. Does not implicitly {@link TW.IoTeX.Proto.Staking.verify|verify} messages.
                 * @param message Staking message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.IStaking, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Staking message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Staking
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking;

                /**
                 * Verifies a Staking message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Staking message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Staking
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking;

                /**
                 * Creates a plain object from a Staking message. Also converts values to other types if specified.
                 * @param message Staking
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.Staking, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Staking to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Staking {

                /** Properties of a Create. */
                interface ICreate {

                    /** Create candidateName */
                    candidateName?: (string|null);

                    /** Create stakedAmount */
                    stakedAmount?: (string|null);

                    /** Create stakedDuration */
                    stakedDuration?: (number|null);

                    /** Create autoStake */
                    autoStake?: (boolean|null);

                    /** Create payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a Create. */
                class Create implements ICreate {

                    /**
                     * Constructs a new Create.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.ICreate);

                    /** Create candidateName. */
                    public candidateName: string;

                    /** Create stakedAmount. */
                    public stakedAmount: string;

                    /** Create stakedDuration. */
                    public stakedDuration: number;

                    /** Create autoStake. */
                    public autoStake: boolean;

                    /** Create payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new Create instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Create instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.ICreate): TW.IoTeX.Proto.Staking.Create;

                    /**
                     * Encodes the specified Create message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Create.verify|verify} messages.
                     * @param message Create message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.ICreate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Create message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Create
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.Create;

                    /**
                     * Verifies a Create message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Create message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Create
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.Create;

                    /**
                     * Creates a plain object from a Create message. Also converts values to other types if specified.
                     * @param message Create
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.Create, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Create to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Reclaim. */
                interface IReclaim {

                    /** Reclaim bucketIndex */
                    bucketIndex?: (Long|null);

                    /** Reclaim payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a Reclaim. */
                class Reclaim implements IReclaim {

                    /**
                     * Constructs a new Reclaim.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.IReclaim);

                    /** Reclaim bucketIndex. */
                    public bucketIndex: Long;

                    /** Reclaim payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new Reclaim instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Reclaim instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.IReclaim): TW.IoTeX.Proto.Staking.Reclaim;

                    /**
                     * Encodes the specified Reclaim message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Reclaim.verify|verify} messages.
                     * @param message Reclaim message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.IReclaim, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Reclaim message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Reclaim
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.Reclaim;

                    /**
                     * Verifies a Reclaim message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Reclaim message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Reclaim
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.Reclaim;

                    /**
                     * Creates a plain object from a Reclaim message. Also converts values to other types if specified.
                     * @param message Reclaim
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.Reclaim, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Reclaim to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an AddDeposit. */
                interface IAddDeposit {

                    /** AddDeposit bucketIndex */
                    bucketIndex?: (Long|null);

                    /** AddDeposit amount */
                    amount?: (string|null);

                    /** AddDeposit payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents an AddDeposit. */
                class AddDeposit implements IAddDeposit {

                    /**
                     * Constructs a new AddDeposit.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.IAddDeposit);

                    /** AddDeposit bucketIndex. */
                    public bucketIndex: Long;

                    /** AddDeposit amount. */
                    public amount: string;

                    /** AddDeposit payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new AddDeposit instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AddDeposit instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.IAddDeposit): TW.IoTeX.Proto.Staking.AddDeposit;

                    /**
                     * Encodes the specified AddDeposit message. Does not implicitly {@link TW.IoTeX.Proto.Staking.AddDeposit.verify|verify} messages.
                     * @param message AddDeposit message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.IAddDeposit, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AddDeposit message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AddDeposit
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.AddDeposit;

                    /**
                     * Verifies an AddDeposit message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AddDeposit message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AddDeposit
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.AddDeposit;

                    /**
                     * Creates a plain object from an AddDeposit message. Also converts values to other types if specified.
                     * @param message AddDeposit
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.AddDeposit, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AddDeposit to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Restake. */
                interface IRestake {

                    /** Restake bucketIndex */
                    bucketIndex?: (Long|null);

                    /** Restake stakedDuration */
                    stakedDuration?: (number|null);

                    /** Restake autoStake */
                    autoStake?: (boolean|null);

                    /** Restake payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a Restake. */
                class Restake implements IRestake {

                    /**
                     * Constructs a new Restake.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.IRestake);

                    /** Restake bucketIndex. */
                    public bucketIndex: Long;

                    /** Restake stakedDuration. */
                    public stakedDuration: number;

                    /** Restake autoStake. */
                    public autoStake: boolean;

                    /** Restake payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new Restake instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Restake instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.IRestake): TW.IoTeX.Proto.Staking.Restake;

                    /**
                     * Encodes the specified Restake message. Does not implicitly {@link TW.IoTeX.Proto.Staking.Restake.verify|verify} messages.
                     * @param message Restake message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.IRestake, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Restake message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Restake
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.Restake;

                    /**
                     * Verifies a Restake message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Restake message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Restake
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.Restake;

                    /**
                     * Creates a plain object from a Restake message. Also converts values to other types if specified.
                     * @param message Restake
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.Restake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Restake to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ChangeCandidate. */
                interface IChangeCandidate {

                    /** ChangeCandidate bucketIndex */
                    bucketIndex?: (Long|null);

                    /** ChangeCandidate candidateName */
                    candidateName?: (string|null);

                    /** ChangeCandidate payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a ChangeCandidate. */
                class ChangeCandidate implements IChangeCandidate {

                    /**
                     * Constructs a new ChangeCandidate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.IChangeCandidate);

                    /** ChangeCandidate bucketIndex. */
                    public bucketIndex: Long;

                    /** ChangeCandidate candidateName. */
                    public candidateName: string;

                    /** ChangeCandidate payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new ChangeCandidate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ChangeCandidate instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.IChangeCandidate): TW.IoTeX.Proto.Staking.ChangeCandidate;

                    /**
                     * Encodes the specified ChangeCandidate message. Does not implicitly {@link TW.IoTeX.Proto.Staking.ChangeCandidate.verify|verify} messages.
                     * @param message ChangeCandidate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.IChangeCandidate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ChangeCandidate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ChangeCandidate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.ChangeCandidate;

                    /**
                     * Verifies a ChangeCandidate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ChangeCandidate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ChangeCandidate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.ChangeCandidate;

                    /**
                     * Creates a plain object from a ChangeCandidate message. Also converts values to other types if specified.
                     * @param message ChangeCandidate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.ChangeCandidate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ChangeCandidate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a TransferOwnership. */
                interface ITransferOwnership {

                    /** TransferOwnership bucketIndex */
                    bucketIndex?: (Long|null);

                    /** TransferOwnership voterAddress */
                    voterAddress?: (string|null);

                    /** TransferOwnership payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a TransferOwnership. */
                class TransferOwnership implements ITransferOwnership {

                    /**
                     * Constructs a new TransferOwnership.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.ITransferOwnership);

                    /** TransferOwnership bucketIndex. */
                    public bucketIndex: Long;

                    /** TransferOwnership voterAddress. */
                    public voterAddress: string;

                    /** TransferOwnership payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new TransferOwnership instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns TransferOwnership instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.ITransferOwnership): TW.IoTeX.Proto.Staking.TransferOwnership;

                    /**
                     * Encodes the specified TransferOwnership message. Does not implicitly {@link TW.IoTeX.Proto.Staking.TransferOwnership.verify|verify} messages.
                     * @param message TransferOwnership message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.ITransferOwnership, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a TransferOwnership message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns TransferOwnership
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.TransferOwnership;

                    /**
                     * Verifies a TransferOwnership message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a TransferOwnership message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns TransferOwnership
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.TransferOwnership;

                    /**
                     * Creates a plain object from a TransferOwnership message. Also converts values to other types if specified.
                     * @param message TransferOwnership
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.TransferOwnership, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this TransferOwnership to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a CandidateBasicInfo. */
                interface ICandidateBasicInfo {

                    /** CandidateBasicInfo name */
                    name?: (string|null);

                    /** CandidateBasicInfo operatorAddress */
                    operatorAddress?: (string|null);

                    /** CandidateBasicInfo rewardAddress */
                    rewardAddress?: (string|null);
                }

                /** Represents a CandidateBasicInfo. */
                class CandidateBasicInfo implements ICandidateBasicInfo {

                    /**
                     * Constructs a new CandidateBasicInfo.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.ICandidateBasicInfo);

                    /** CandidateBasicInfo name. */
                    public name: string;

                    /** CandidateBasicInfo operatorAddress. */
                    public operatorAddress: string;

                    /** CandidateBasicInfo rewardAddress. */
                    public rewardAddress: string;

                    /**
                     * Creates a new CandidateBasicInfo instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns CandidateBasicInfo instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.ICandidateBasicInfo): TW.IoTeX.Proto.Staking.CandidateBasicInfo;

                    /**
                     * Encodes the specified CandidateBasicInfo message. Does not implicitly {@link TW.IoTeX.Proto.Staking.CandidateBasicInfo.verify|verify} messages.
                     * @param message CandidateBasicInfo message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.ICandidateBasicInfo, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a CandidateBasicInfo message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns CandidateBasicInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.CandidateBasicInfo;

                    /**
                     * Verifies a CandidateBasicInfo message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a CandidateBasicInfo message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns CandidateBasicInfo
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.CandidateBasicInfo;

                    /**
                     * Creates a plain object from a CandidateBasicInfo message. Also converts values to other types if specified.
                     * @param message CandidateBasicInfo
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.CandidateBasicInfo, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this CandidateBasicInfo to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a CandidateRegister. */
                interface ICandidateRegister {

                    /** CandidateRegister candidate */
                    candidate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);

                    /** CandidateRegister stakedAmount */
                    stakedAmount?: (string|null);

                    /** CandidateRegister stakedDuration */
                    stakedDuration?: (number|null);

                    /** CandidateRegister autoStake */
                    autoStake?: (boolean|null);

                    /** CandidateRegister ownerAddress */
                    ownerAddress?: (string|null);

                    /** CandidateRegister payload */
                    payload?: (Uint8Array|null);
                }

                /** Represents a CandidateRegister. */
                class CandidateRegister implements ICandidateRegister {

                    /**
                     * Constructs a new CandidateRegister.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.IoTeX.Proto.Staking.ICandidateRegister);

                    /** CandidateRegister candidate. */
                    public candidate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);

                    /** CandidateRegister stakedAmount. */
                    public stakedAmount: string;

                    /** CandidateRegister stakedDuration. */
                    public stakedDuration: number;

                    /** CandidateRegister autoStake. */
                    public autoStake: boolean;

                    /** CandidateRegister ownerAddress. */
                    public ownerAddress: string;

                    /** CandidateRegister payload. */
                    public payload: Uint8Array;

                    /**
                     * Creates a new CandidateRegister instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns CandidateRegister instance
                     */
                    public static create(properties?: TW.IoTeX.Proto.Staking.ICandidateRegister): TW.IoTeX.Proto.Staking.CandidateRegister;

                    /**
                     * Encodes the specified CandidateRegister message. Does not implicitly {@link TW.IoTeX.Proto.Staking.CandidateRegister.verify|verify} messages.
                     * @param message CandidateRegister message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.IoTeX.Proto.Staking.ICandidateRegister, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a CandidateRegister message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns CandidateRegister
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Staking.CandidateRegister;

                    /**
                     * Verifies a CandidateRegister message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a CandidateRegister message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns CandidateRegister
                     */
                    public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Staking.CandidateRegister;

                    /**
                     * Creates a plain object from a CandidateRegister message. Also converts values to other types if specified.
                     * @param message CandidateRegister
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.IoTeX.Proto.Staking.CandidateRegister, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this CandidateRegister to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a ContractCall. */
            interface IContractCall {

                /** ContractCall amount */
                amount?: (string|null);

                /** ContractCall contract */
                contract?: (string|null);

                /** ContractCall data */
                data?: (Uint8Array|null);
            }

            /** Represents a ContractCall. */
            class ContractCall implements IContractCall {

                /**
                 * Constructs a new ContractCall.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.IContractCall);

                /** ContractCall amount. */
                public amount: string;

                /** ContractCall contract. */
                public contract: string;

                /** ContractCall data. */
                public data: Uint8Array;

                /**
                 * Creates a new ContractCall instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ContractCall instance
                 */
                public static create(properties?: TW.IoTeX.Proto.IContractCall): TW.IoTeX.Proto.ContractCall;

                /**
                 * Encodes the specified ContractCall message. Does not implicitly {@link TW.IoTeX.Proto.ContractCall.verify|verify} messages.
                 * @param message ContractCall message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.IContractCall, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ContractCall message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ContractCall
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.ContractCall;

                /**
                 * Verifies a ContractCall message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ContractCall message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ContractCall
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.ContractCall;

                /**
                 * Creates a plain object from a ContractCall message. Also converts values to other types if specified.
                 * @param message ContractCall
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.ContractCall, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ContractCall to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput version */
                version?: (number|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput gasLimit */
                gasLimit?: (Long|null);

                /** SigningInput gasPrice */
                gasPrice?: (string|null);

                /** SigningInput chainID */
                chainID?: (number|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transfer */
                transfer?: (TW.IoTeX.Proto.ITransfer|null);

                /** SigningInput call */
                call?: (TW.IoTeX.Proto.IContractCall|null);

                /** SigningInput stakeCreate */
                stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** SigningInput stakeUnstake */
                stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** SigningInput stakeWithdraw */
                stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** SigningInput stakeAddDeposit */
                stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** SigningInput stakeRestake */
                stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** SigningInput stakeChangeCandidate */
                stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** SigningInput stakeTransferOwnership */
                stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** SigningInput candidateRegister */
                candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** SigningInput candidateUpdate */
                candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.ISigningInput);

                /** SigningInput version. */
                public version: number;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput gasLimit. */
                public gasLimit: Long;

                /** SigningInput gasPrice. */
                public gasPrice: string;

                /** SigningInput chainID. */
                public chainID: number;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transfer. */
                public transfer?: (TW.IoTeX.Proto.ITransfer|null);

                /** SigningInput call. */
                public call?: (TW.IoTeX.Proto.IContractCall|null);

                /** SigningInput stakeCreate. */
                public stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** SigningInput stakeUnstake. */
                public stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** SigningInput stakeWithdraw. */
                public stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** SigningInput stakeAddDeposit. */
                public stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** SigningInput stakeRestake. */
                public stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** SigningInput stakeChangeCandidate. */
                public stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** SigningInput stakeTransferOwnership. */
                public stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** SigningInput candidateRegister. */
                public candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** SigningInput candidateUpdate. */
                public candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);

                /** SigningInput action. */
                public action?: ("transfer"|"call"|"stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.IoTeX.Proto.ISigningInput): TW.IoTeX.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.IoTeX.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput hash */
                hash?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput hash. */
                public hash: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.IoTeX.Proto.ISigningOutput): TW.IoTeX.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.IoTeX.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an ActionCore. */
            interface IActionCore {

                /** ActionCore version */
                version?: (number|null);

                /** ActionCore nonce */
                nonce?: (Long|null);

                /** ActionCore gasLimit */
                gasLimit?: (Long|null);

                /** ActionCore gasPrice */
                gasPrice?: (string|null);

                /** ActionCore chainID */
                chainID?: (number|null);

                /** ActionCore transfer */
                transfer?: (TW.IoTeX.Proto.ITransfer|null);

                /** ActionCore execution */
                execution?: (TW.IoTeX.Proto.IContractCall|null);

                /** ActionCore stakeCreate */
                stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** ActionCore stakeUnstake */
                stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** ActionCore stakeWithdraw */
                stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** ActionCore stakeAddDeposit */
                stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** ActionCore stakeRestake */
                stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** ActionCore stakeChangeCandidate */
                stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** ActionCore stakeTransferOwnership */
                stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** ActionCore candidateRegister */
                candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** ActionCore candidateUpdate */
                candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);
            }

            /** Represents an ActionCore. */
            class ActionCore implements IActionCore {

                /**
                 * Constructs a new ActionCore.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.IActionCore);

                /** ActionCore version. */
                public version: number;

                /** ActionCore nonce. */
                public nonce: Long;

                /** ActionCore gasLimit. */
                public gasLimit: Long;

                /** ActionCore gasPrice. */
                public gasPrice: string;

                /** ActionCore chainID. */
                public chainID: number;

                /** ActionCore transfer. */
                public transfer?: (TW.IoTeX.Proto.ITransfer|null);

                /** ActionCore execution. */
                public execution?: (TW.IoTeX.Proto.IContractCall|null);

                /** ActionCore stakeCreate. */
                public stakeCreate?: (TW.IoTeX.Proto.Staking.ICreate|null);

                /** ActionCore stakeUnstake. */
                public stakeUnstake?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** ActionCore stakeWithdraw. */
                public stakeWithdraw?: (TW.IoTeX.Proto.Staking.IReclaim|null);

                /** ActionCore stakeAddDeposit. */
                public stakeAddDeposit?: (TW.IoTeX.Proto.Staking.IAddDeposit|null);

                /** ActionCore stakeRestake. */
                public stakeRestake?: (TW.IoTeX.Proto.Staking.IRestake|null);

                /** ActionCore stakeChangeCandidate. */
                public stakeChangeCandidate?: (TW.IoTeX.Proto.Staking.IChangeCandidate|null);

                /** ActionCore stakeTransferOwnership. */
                public stakeTransferOwnership?: (TW.IoTeX.Proto.Staking.ITransferOwnership|null);

                /** ActionCore candidateRegister. */
                public candidateRegister?: (TW.IoTeX.Proto.Staking.ICandidateRegister|null);

                /** ActionCore candidateUpdate. */
                public candidateUpdate?: (TW.IoTeX.Proto.Staking.ICandidateBasicInfo|null);

                /** ActionCore action. */
                public action?: ("transfer"|"execution"|"stakeCreate"|"stakeUnstake"|"stakeWithdraw"|"stakeAddDeposit"|"stakeRestake"|"stakeChangeCandidate"|"stakeTransferOwnership"|"candidateRegister"|"candidateUpdate");

                /**
                 * Creates a new ActionCore instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ActionCore instance
                 */
                public static create(properties?: TW.IoTeX.Proto.IActionCore): TW.IoTeX.Proto.ActionCore;

                /**
                 * Encodes the specified ActionCore message. Does not implicitly {@link TW.IoTeX.Proto.ActionCore.verify|verify} messages.
                 * @param message ActionCore message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.IActionCore, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ActionCore message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ActionCore
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.ActionCore;

                /**
                 * Verifies an ActionCore message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an ActionCore message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ActionCore
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.ActionCore;

                /**
                 * Creates a plain object from an ActionCore message. Also converts values to other types if specified.
                 * @param message ActionCore
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.ActionCore, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ActionCore to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Action. */
            interface IAction {

                /** Action core */
                core?: (TW.IoTeX.Proto.IActionCore|null);

                /** Action senderPubKey */
                senderPubKey?: (Uint8Array|null);

                /** Action signature */
                signature?: (Uint8Array|null);
            }

            /** Represents an Action. */
            class Action implements IAction {

                /**
                 * Constructs a new Action.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.IoTeX.Proto.IAction);

                /** Action core. */
                public core?: (TW.IoTeX.Proto.IActionCore|null);

                /** Action senderPubKey. */
                public senderPubKey: Uint8Array;

                /** Action signature. */
                public signature: Uint8Array;

                /**
                 * Creates a new Action instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Action instance
                 */
                public static create(properties?: TW.IoTeX.Proto.IAction): TW.IoTeX.Proto.Action;

                /**
                 * Encodes the specified Action message. Does not implicitly {@link TW.IoTeX.Proto.Action.verify|verify} messages.
                 * @param message Action message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.IoTeX.Proto.IAction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Action message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.IoTeX.Proto.Action;

                /**
                 * Verifies an Action message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Action
                 */
                public static fromObject(object: { [k: string]: any }): TW.IoTeX.Proto.Action;

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @param message Action
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.IoTeX.Proto.Action, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Action to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace LiquidStaking. */
    namespace LiquidStaking {

        /** Namespace Proto. */
        namespace Proto {

            /** Coin enum. */
            enum Coin {
                MATIC = 0,
                ATOM = 1,
                BNB = 2,
                APT = 3,
                ETH = 4
            }

            /** Blockchain enum. */
            enum Blockchain {
                ETHEREUM = 0,
                POLYGON = 1,
                STRIDE = 2,
                BNB_BSC = 3,
                APTOS = 4
            }

            /** Protocol enum. */
            enum Protocol {
                Strader = 0,
                Stride = 1,
                Tortuga = 2,
                Lido = 3
            }

            /** StatusCode enum. */
            enum StatusCode {
                OK = 0,
                ERROR_ACTION_NOT_SET = 1,
                ERROR_TARGETED_BLOCKCHAIN_NOT_SUPPORTED_BY_PROTOCOL = 2,
                ERROR_SMART_CONTRACT_ADDRESS_NOT_SET = 3,
                ERROR_INPUT_PROTO_DESERIALIZATION = 4,
                ERROR_OPERATION_NOT_SUPPORTED_BY_PROTOCOL = 5
            }

            /** Properties of a Status. */
            interface IStatus {

                /** Status code */
                code?: (TW.LiquidStaking.Proto.StatusCode|null);

                /** Status message */
                message?: (string|null);
            }

            /** Represents a Status. */
            class Status implements IStatus {

                /**
                 * Constructs a new Status.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IStatus);

                /** Status code. */
                public code: TW.LiquidStaking.Proto.StatusCode;

                /** Status message. */
                public message: string;

                /**
                 * Creates a new Status instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Status instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IStatus): TW.LiquidStaking.Proto.Status;

                /**
                 * Encodes the specified Status message. Does not implicitly {@link TW.LiquidStaking.Proto.Status.verify|verify} messages.
                 * @param message Status message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IStatus, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Status message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Status
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Status;

                /**
                 * Verifies a Status message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Status message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Status
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Status;

                /**
                 * Creates a plain object from a Status message. Also converts values to other types if specified.
                 * @param message Status
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Status, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Status to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Asset. */
            interface IAsset {

                /** Asset stakingToken */
                stakingToken?: (TW.LiquidStaking.Proto.Coin|null);

                /** Asset liquidToken */
                liquidToken?: (string|null);

                /** Asset denom */
                denom?: (string|null);

                /** Asset fromAddress */
                fromAddress?: (string|null);
            }

            /** Represents an Asset. */
            class Asset implements IAsset {

                /**
                 * Constructs a new Asset.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IAsset);

                /** Asset stakingToken. */
                public stakingToken: TW.LiquidStaking.Proto.Coin;

                /** Asset liquidToken. */
                public liquidToken: string;

                /** Asset denom. */
                public denom: string;

                /** Asset fromAddress. */
                public fromAddress: string;

                /**
                 * Creates a new Asset instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Asset instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IAsset): TW.LiquidStaking.Proto.Asset;

                /**
                 * Encodes the specified Asset message. Does not implicitly {@link TW.LiquidStaking.Proto.Asset.verify|verify} messages.
                 * @param message Asset message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IAsset, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Asset message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Asset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Asset;

                /**
                 * Verifies an Asset message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Asset
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Asset;

                /**
                 * Creates a plain object from an Asset message. Also converts values to other types if specified.
                 * @param message Asset
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Asset, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Asset to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Stake. */
            interface IStake {

                /** Stake asset */
                asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Stake amount */
                amount?: (string|null);
            }

            /** Represents a Stake. */
            class Stake implements IStake {

                /**
                 * Constructs a new Stake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IStake);

                /** Stake asset. */
                public asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Stake amount. */
                public amount: string;

                /**
                 * Creates a new Stake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Stake instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IStake): TW.LiquidStaking.Proto.Stake;

                /**
                 * Encodes the specified Stake message. Does not implicitly {@link TW.LiquidStaking.Proto.Stake.verify|verify} messages.
                 * @param message Stake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Stake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Stake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Stake;

                /**
                 * Verifies a Stake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Stake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Stake
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Stake;

                /**
                 * Creates a plain object from a Stake message. Also converts values to other types if specified.
                 * @param message Stake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Stake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Stake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Unstake. */
            interface IUnstake {

                /** Unstake asset */
                asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Unstake amount */
                amount?: (string|null);

                /** Unstake receiverAddress */
                receiverAddress?: (string|null);

                /** Unstake receiverChainId */
                receiverChainId?: (string|null);
            }

            /** Represents an Unstake. */
            class Unstake implements IUnstake {

                /**
                 * Constructs a new Unstake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IUnstake);

                /** Unstake asset. */
                public asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Unstake amount. */
                public amount: string;

                /** Unstake receiverAddress. */
                public receiverAddress: string;

                /** Unstake receiverChainId. */
                public receiverChainId: string;

                /**
                 * Creates a new Unstake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Unstake instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IUnstake): TW.LiquidStaking.Proto.Unstake;

                /**
                 * Encodes the specified Unstake message. Does not implicitly {@link TW.LiquidStaking.Proto.Unstake.verify|verify} messages.
                 * @param message Unstake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IUnstake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Unstake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Unstake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Unstake;

                /**
                 * Verifies an Unstake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Unstake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Unstake
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Unstake;

                /**
                 * Creates a plain object from an Unstake message. Also converts values to other types if specified.
                 * @param message Unstake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Unstake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Unstake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Withdraw. */
            interface IWithdraw {

                /** Withdraw asset */
                asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Withdraw amount */
                amount?: (string|null);

                /** Withdraw idx */
                idx?: (string|null);
            }

            /** Represents a Withdraw. */
            class Withdraw implements IWithdraw {

                /**
                 * Constructs a new Withdraw.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IWithdraw);

                /** Withdraw asset. */
                public asset?: (TW.LiquidStaking.Proto.IAsset|null);

                /** Withdraw amount. */
                public amount: string;

                /** Withdraw idx. */
                public idx: string;

                /**
                 * Creates a new Withdraw instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Withdraw instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IWithdraw): TW.LiquidStaking.Proto.Withdraw;

                /**
                 * Encodes the specified Withdraw message. Does not implicitly {@link TW.LiquidStaking.Proto.Withdraw.verify|verify} messages.
                 * @param message Withdraw message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IWithdraw, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Withdraw message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Withdraw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Withdraw;

                /**
                 * Verifies a Withdraw message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Withdraw message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Withdraw
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Withdraw;

                /**
                 * Creates a plain object from a Withdraw message. Also converts values to other types if specified.
                 * @param message Withdraw
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Withdraw, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Withdraw to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Input. */
            interface IInput {

                /** Input stake */
                stake?: (TW.LiquidStaking.Proto.IStake|null);

                /** Input unstake */
                unstake?: (TW.LiquidStaking.Proto.IUnstake|null);

                /** Input withdraw */
                withdraw?: (TW.LiquidStaking.Proto.IWithdraw|null);

                /** Input smartContractAddress */
                smartContractAddress?: (string|null);

                /** Input protocol */
                protocol?: (TW.LiquidStaking.Proto.Protocol|null);

                /** Input blockchain */
                blockchain?: (TW.LiquidStaking.Proto.Blockchain|null);
            }

            /** Represents an Input. */
            class Input implements IInput {

                /**
                 * Constructs a new Input.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IInput);

                /** Input stake. */
                public stake?: (TW.LiquidStaking.Proto.IStake|null);

                /** Input unstake. */
                public unstake?: (TW.LiquidStaking.Proto.IUnstake|null);

                /** Input withdraw. */
                public withdraw?: (TW.LiquidStaking.Proto.IWithdraw|null);

                /** Input smartContractAddress. */
                public smartContractAddress: string;

                /** Input protocol. */
                public protocol: TW.LiquidStaking.Proto.Protocol;

                /** Input blockchain. */
                public blockchain: TW.LiquidStaking.Proto.Blockchain;

                /** Input action. */
                public action?: ("stake"|"unstake"|"withdraw");

                /**
                 * Creates a new Input instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Input instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IInput): TW.LiquidStaking.Proto.Input;

                /**
                 * Encodes the specified Input message. Does not implicitly {@link TW.LiquidStaking.Proto.Input.verify|verify} messages.
                 * @param message Input message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Input message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Input
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Input;

                /**
                 * Verifies an Input message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Input message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Input
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Input;

                /**
                 * Creates a plain object from an Input message. Also converts values to other types if specified.
                 * @param message Input
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Input, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Input to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Output. */
            interface IOutput {

                /** Output status */
                status?: (TW.LiquidStaking.Proto.IStatus|null);

                /** Output ethereum */
                ethereum?: (TW.Ethereum.Proto.ISigningInput|null);

                /** Output cosmos */
                cosmos?: (TW.Cosmos.Proto.ISigningInput|null);

                /** Output aptos */
                aptos?: (TW.Aptos.Proto.ISigningInput|null);
            }

            /** Represents an Output. */
            class Output implements IOutput {

                /**
                 * Constructs a new Output.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.LiquidStaking.Proto.IOutput);

                /** Output status. */
                public status?: (TW.LiquidStaking.Proto.IStatus|null);

                /** Output ethereum. */
                public ethereum?: (TW.Ethereum.Proto.ISigningInput|null);

                /** Output cosmos. */
                public cosmos?: (TW.Cosmos.Proto.ISigningInput|null);

                /** Output aptos. */
                public aptos?: (TW.Aptos.Proto.ISigningInput|null);

                /** Output signingInputOneof. */
                public signingInputOneof?: ("ethereum"|"cosmos"|"aptos");

                /**
                 * Creates a new Output instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Output instance
                 */
                public static create(properties?: TW.LiquidStaking.Proto.IOutput): TW.LiquidStaking.Proto.Output;

                /**
                 * Encodes the specified Output message. Does not implicitly {@link TW.LiquidStaking.Proto.Output.verify|verify} messages.
                 * @param message Output message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.LiquidStaking.Proto.IOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Output message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Output
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.LiquidStaking.Proto.Output;

                /**
                 * Verifies an Output message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Output message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Output
                 */
                public static fromObject(object: { [k: string]: any }): TW.LiquidStaking.Proto.Output;

                /**
                 * Creates a plain object from an Output message. Also converts values to other types if specified.
                 * @param message Output
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.LiquidStaking.Proto.Output, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Output to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace MultiversX. */
    namespace MultiversX {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a GenericAction. */
            interface IGenericAction {

                /** GenericAction accounts */
                accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** GenericAction value */
                value?: (string|null);

                /** GenericAction data */
                data?: (string|null);

                /** GenericAction version */
                version?: (number|null);

                /** GenericAction options */
                options?: (number|null);
            }

            /** Represents a GenericAction. */
            class GenericAction implements IGenericAction {

                /**
                 * Constructs a new GenericAction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.IGenericAction);

                /** GenericAction accounts. */
                public accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** GenericAction value. */
                public value: string;

                /** GenericAction data. */
                public data: string;

                /** GenericAction version. */
                public version: number;

                /** GenericAction options. */
                public options: number;

                /**
                 * Creates a new GenericAction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns GenericAction instance
                 */
                public static create(properties?: TW.MultiversX.Proto.IGenericAction): TW.MultiversX.Proto.GenericAction;

                /**
                 * Encodes the specified GenericAction message. Does not implicitly {@link TW.MultiversX.Proto.GenericAction.verify|verify} messages.
                 * @param message GenericAction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.IGenericAction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a GenericAction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns GenericAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.GenericAction;

                /**
                 * Verifies a GenericAction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a GenericAction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns GenericAction
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.GenericAction;

                /**
                 * Creates a plain object from a GenericAction message. Also converts values to other types if specified.
                 * @param message GenericAction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.GenericAction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this GenericAction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a EGLDTransfer. */
            interface IEGLDTransfer {

                /** EGLDTransfer accounts */
                accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** EGLDTransfer amount */
                amount?: (string|null);

                /** EGLDTransfer data */
                data?: (string|null);

                /** EGLDTransfer version */
                version?: (number|null);
            }

            /** Represents a EGLDTransfer. */
            class EGLDTransfer implements IEGLDTransfer {

                /**
                 * Constructs a new EGLDTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.IEGLDTransfer);

                /** EGLDTransfer accounts. */
                public accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** EGLDTransfer amount. */
                public amount: string;

                /** EGLDTransfer data. */
                public data: string;

                /** EGLDTransfer version. */
                public version: number;

                /**
                 * Creates a new EGLDTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns EGLDTransfer instance
                 */
                public static create(properties?: TW.MultiversX.Proto.IEGLDTransfer): TW.MultiversX.Proto.EGLDTransfer;

                /**
                 * Encodes the specified EGLDTransfer message. Does not implicitly {@link TW.MultiversX.Proto.EGLDTransfer.verify|verify} messages.
                 * @param message EGLDTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.IEGLDTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a EGLDTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns EGLDTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.EGLDTransfer;

                /**
                 * Verifies a EGLDTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a EGLDTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns EGLDTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.EGLDTransfer;

                /**
                 * Creates a plain object from a EGLDTransfer message. Also converts values to other types if specified.
                 * @param message EGLDTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.EGLDTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this EGLDTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ESDTTransfer. */
            interface IESDTTransfer {

                /** ESDTTransfer accounts */
                accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** ESDTTransfer tokenIdentifier */
                tokenIdentifier?: (string|null);

                /** ESDTTransfer amount */
                amount?: (string|null);

                /** ESDTTransfer version */
                version?: (number|null);
            }

            /** Represents a ESDTTransfer. */
            class ESDTTransfer implements IESDTTransfer {

                /**
                 * Constructs a new ESDTTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.IESDTTransfer);

                /** ESDTTransfer accounts. */
                public accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** ESDTTransfer tokenIdentifier. */
                public tokenIdentifier: string;

                /** ESDTTransfer amount. */
                public amount: string;

                /** ESDTTransfer version. */
                public version: number;

                /**
                 * Creates a new ESDTTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ESDTTransfer instance
                 */
                public static create(properties?: TW.MultiversX.Proto.IESDTTransfer): TW.MultiversX.Proto.ESDTTransfer;

                /**
                 * Encodes the specified ESDTTransfer message. Does not implicitly {@link TW.MultiversX.Proto.ESDTTransfer.verify|verify} messages.
                 * @param message ESDTTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.IESDTTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ESDTTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ESDTTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.ESDTTransfer;

                /**
                 * Verifies a ESDTTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ESDTTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ESDTTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.ESDTTransfer;

                /**
                 * Creates a plain object from a ESDTTransfer message. Also converts values to other types if specified.
                 * @param message ESDTTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.ESDTTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ESDTTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ESDTNFTTransfer. */
            interface IESDTNFTTransfer {

                /** ESDTNFTTransfer accounts */
                accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** ESDTNFTTransfer tokenCollection */
                tokenCollection?: (string|null);

                /** ESDTNFTTransfer tokenNonce */
                tokenNonce?: (Long|null);

                /** ESDTNFTTransfer amount */
                amount?: (string|null);

                /** ESDTNFTTransfer version */
                version?: (number|null);
            }

            /** Represents a ESDTNFTTransfer. */
            class ESDTNFTTransfer implements IESDTNFTTransfer {

                /**
                 * Constructs a new ESDTNFTTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.IESDTNFTTransfer);

                /** ESDTNFTTransfer accounts. */
                public accounts?: (TW.MultiversX.Proto.IAccounts|null);

                /** ESDTNFTTransfer tokenCollection. */
                public tokenCollection: string;

                /** ESDTNFTTransfer tokenNonce. */
                public tokenNonce: Long;

                /** ESDTNFTTransfer amount. */
                public amount: string;

                /** ESDTNFTTransfer version. */
                public version: number;

                /**
                 * Creates a new ESDTNFTTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ESDTNFTTransfer instance
                 */
                public static create(properties?: TW.MultiversX.Proto.IESDTNFTTransfer): TW.MultiversX.Proto.ESDTNFTTransfer;

                /**
                 * Encodes the specified ESDTNFTTransfer message. Does not implicitly {@link TW.MultiversX.Proto.ESDTNFTTransfer.verify|verify} messages.
                 * @param message ESDTNFTTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.IESDTNFTTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ESDTNFTTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ESDTNFTTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.ESDTNFTTransfer;

                /**
                 * Verifies a ESDTNFTTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ESDTNFTTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ESDTNFTTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.ESDTNFTTransfer;

                /**
                 * Creates a plain object from a ESDTNFTTransfer message. Also converts values to other types if specified.
                 * @param message ESDTNFTTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.ESDTNFTTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ESDTNFTTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Accounts. */
            interface IAccounts {

                /** Accounts senderNonce */
                senderNonce?: (Long|null);

                /** Accounts sender */
                sender?: (string|null);

                /** Accounts senderUsername */
                senderUsername?: (string|null);

                /** Accounts receiver */
                receiver?: (string|null);

                /** Accounts receiverUsername */
                receiverUsername?: (string|null);

                /** Accounts guardian */
                guardian?: (string|null);
            }

            /** Represents an Accounts. */
            class Accounts implements IAccounts {

                /**
                 * Constructs a new Accounts.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.IAccounts);

                /** Accounts senderNonce. */
                public senderNonce: Long;

                /** Accounts sender. */
                public sender: string;

                /** Accounts senderUsername. */
                public senderUsername: string;

                /** Accounts receiver. */
                public receiver: string;

                /** Accounts receiverUsername. */
                public receiverUsername: string;

                /** Accounts guardian. */
                public guardian: string;

                /**
                 * Creates a new Accounts instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Accounts instance
                 */
                public static create(properties?: TW.MultiversX.Proto.IAccounts): TW.MultiversX.Proto.Accounts;

                /**
                 * Encodes the specified Accounts message. Does not implicitly {@link TW.MultiversX.Proto.Accounts.verify|verify} messages.
                 * @param message Accounts message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.IAccounts, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Accounts message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Accounts
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.Accounts;

                /**
                 * Verifies an Accounts message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Accounts message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Accounts
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.Accounts;

                /**
                 * Creates a plain object from an Accounts message. Also converts values to other types if specified.
                 * @param message Accounts
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.Accounts, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Accounts to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput chainId */
                chainId?: (string|null);

                /** SigningInput gasPrice */
                gasPrice?: (Long|null);

                /** SigningInput gasLimit */
                gasLimit?: (Long|null);

                /** SigningInput genericAction */
                genericAction?: (TW.MultiversX.Proto.IGenericAction|null);

                /** SigningInput egldTransfer */
                egldTransfer?: (TW.MultiversX.Proto.IEGLDTransfer|null);

                /** SigningInput esdtTransfer */
                esdtTransfer?: (TW.MultiversX.Proto.IESDTTransfer|null);

                /** SigningInput esdtnftTransfer */
                esdtnftTransfer?: (TW.MultiversX.Proto.IESDTNFTTransfer|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput chainId. */
                public chainId: string;

                /** SigningInput gasPrice. */
                public gasPrice: Long;

                /** SigningInput gasLimit. */
                public gasLimit: Long;

                /** SigningInput genericAction. */
                public genericAction?: (TW.MultiversX.Proto.IGenericAction|null);

                /** SigningInput egldTransfer. */
                public egldTransfer?: (TW.MultiversX.Proto.IEGLDTransfer|null);

                /** SigningInput esdtTransfer. */
                public esdtTransfer?: (TW.MultiversX.Proto.IESDTTransfer|null);

                /** SigningInput esdtnftTransfer. */
                public esdtnftTransfer?: (TW.MultiversX.Proto.IESDTNFTTransfer|null);

                /** SigningInput messageOneof. */
                public messageOneof?: ("genericAction"|"egldTransfer"|"esdtTransfer"|"esdtnftTransfer");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.MultiversX.Proto.ISigningInput): TW.MultiversX.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.MultiversX.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);

                /** SigningOutput signature */
                signature?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.MultiversX.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /** SigningOutput signature. */
                public signature: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.MultiversX.Proto.ISigningOutput): TW.MultiversX.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.MultiversX.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.MultiversX.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.MultiversX.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.MultiversX.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.MultiversX.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Nano. */
    namespace Nano {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput parentBlock */
                parentBlock?: (Uint8Array|null);

                /** SigningInput linkBlock */
                linkBlock?: (Uint8Array|null);

                /** SigningInput linkRecipient */
                linkRecipient?: (string|null);

                /** SigningInput representative */
                representative?: (string|null);

                /** SigningInput balance */
                balance?: (string|null);

                /** SigningInput work */
                work?: (string|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nano.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput parentBlock. */
                public parentBlock: Uint8Array;

                /** SigningInput linkBlock. */
                public linkBlock?: (Uint8Array|null);

                /** SigningInput linkRecipient. */
                public linkRecipient?: (string|null);

                /** SigningInput representative. */
                public representative: string;

                /** SigningInput balance. */
                public balance: string;

                /** SigningInput work. */
                public work: string;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /** SigningInput linkOneof. */
                public linkOneof?: ("linkBlock"|"linkRecipient");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Nano.Proto.ISigningInput): TW.Nano.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nano.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nano.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nano.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nano.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nano.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput blockHash */
                blockHash?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nano.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput blockHash. */
                public blockHash: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Nano.Proto.ISigningOutput): TW.Nano.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nano.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nano.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nano.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nano.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nano.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace NEAR. */
    namespace NEAR {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a PublicKey. */
            interface IPublicKey {

                /** PublicKey keyType */
                keyType?: (number|null);

                /** PublicKey data */
                data?: (Uint8Array|null);
            }

            /** Represents a PublicKey. */
            class PublicKey implements IPublicKey {

                /**
                 * Constructs a new PublicKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IPublicKey);

                /** PublicKey keyType. */
                public keyType: number;

                /** PublicKey data. */
                public data: Uint8Array;

                /**
                 * Creates a new PublicKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PublicKey instance
                 */
                public static create(properties?: TW.NEAR.Proto.IPublicKey): TW.NEAR.Proto.PublicKey;

                /**
                 * Encodes the specified PublicKey message. Does not implicitly {@link TW.NEAR.Proto.PublicKey.verify|verify} messages.
                 * @param message PublicKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IPublicKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PublicKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PublicKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.PublicKey;

                /**
                 * Verifies a PublicKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PublicKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.PublicKey;

                /**
                 * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
                 * @param message PublicKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.PublicKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PublicKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FunctionCallPermission. */
            interface IFunctionCallPermission {

                /** FunctionCallPermission allowance */
                allowance?: (Uint8Array|null);

                /** FunctionCallPermission receiverId */
                receiverId?: (string|null);

                /** FunctionCallPermission methodNames */
                methodNames?: (string[]|null);
            }

            /** Represents a FunctionCallPermission. */
            class FunctionCallPermission implements IFunctionCallPermission {

                /**
                 * Constructs a new FunctionCallPermission.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IFunctionCallPermission);

                /** FunctionCallPermission allowance. */
                public allowance: Uint8Array;

                /** FunctionCallPermission receiverId. */
                public receiverId: string;

                /** FunctionCallPermission methodNames. */
                public methodNames: string[];

                /**
                 * Creates a new FunctionCallPermission instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FunctionCallPermission instance
                 */
                public static create(properties?: TW.NEAR.Proto.IFunctionCallPermission): TW.NEAR.Proto.FunctionCallPermission;

                /**
                 * Encodes the specified FunctionCallPermission message. Does not implicitly {@link TW.NEAR.Proto.FunctionCallPermission.verify|verify} messages.
                 * @param message FunctionCallPermission message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IFunctionCallPermission, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FunctionCallPermission message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FunctionCallPermission
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.FunctionCallPermission;

                /**
                 * Verifies a FunctionCallPermission message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FunctionCallPermission message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FunctionCallPermission
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.FunctionCallPermission;

                /**
                 * Creates a plain object from a FunctionCallPermission message. Also converts values to other types if specified.
                 * @param message FunctionCallPermission
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.FunctionCallPermission, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FunctionCallPermission to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FullAccessPermission. */
            interface IFullAccessPermission {
            }

            /** Represents a FullAccessPermission. */
            class FullAccessPermission implements IFullAccessPermission {

                /**
                 * Constructs a new FullAccessPermission.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IFullAccessPermission);

                /**
                 * Creates a new FullAccessPermission instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FullAccessPermission instance
                 */
                public static create(properties?: TW.NEAR.Proto.IFullAccessPermission): TW.NEAR.Proto.FullAccessPermission;

                /**
                 * Encodes the specified FullAccessPermission message. Does not implicitly {@link TW.NEAR.Proto.FullAccessPermission.verify|verify} messages.
                 * @param message FullAccessPermission message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IFullAccessPermission, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FullAccessPermission message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FullAccessPermission
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.FullAccessPermission;

                /**
                 * Verifies a FullAccessPermission message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FullAccessPermission message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FullAccessPermission
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.FullAccessPermission;

                /**
                 * Creates a plain object from a FullAccessPermission message. Also converts values to other types if specified.
                 * @param message FullAccessPermission
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.FullAccessPermission, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FullAccessPermission to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AccessKey. */
            interface IAccessKey {

                /** AccessKey nonce */
                nonce?: (Long|null);

                /** AccessKey functionCall */
                functionCall?: (TW.NEAR.Proto.IFunctionCallPermission|null);

                /** AccessKey fullAccess */
                fullAccess?: (TW.NEAR.Proto.IFullAccessPermission|null);
            }

            /** Represents an AccessKey. */
            class AccessKey implements IAccessKey {

                /**
                 * Constructs a new AccessKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IAccessKey);

                /** AccessKey nonce. */
                public nonce: Long;

                /** AccessKey functionCall. */
                public functionCall?: (TW.NEAR.Proto.IFunctionCallPermission|null);

                /** AccessKey fullAccess. */
                public fullAccess?: (TW.NEAR.Proto.IFullAccessPermission|null);

                /** AccessKey permission. */
                public permission?: ("functionCall"|"fullAccess");

                /**
                 * Creates a new AccessKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AccessKey instance
                 */
                public static create(properties?: TW.NEAR.Proto.IAccessKey): TW.NEAR.Proto.AccessKey;

                /**
                 * Encodes the specified AccessKey message. Does not implicitly {@link TW.NEAR.Proto.AccessKey.verify|verify} messages.
                 * @param message AccessKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IAccessKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AccessKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AccessKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.AccessKey;

                /**
                 * Verifies an AccessKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AccessKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AccessKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.AccessKey;

                /**
                 * Creates a plain object from an AccessKey message. Also converts values to other types if specified.
                 * @param message AccessKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.AccessKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AccessKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CreateAccount. */
            interface ICreateAccount {
            }

            /** Represents a CreateAccount. */
            class CreateAccount implements ICreateAccount {

                /**
                 * Constructs a new CreateAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.ICreateAccount);

                /**
                 * Creates a new CreateAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CreateAccount instance
                 */
                public static create(properties?: TW.NEAR.Proto.ICreateAccount): TW.NEAR.Proto.CreateAccount;

                /**
                 * Encodes the specified CreateAccount message. Does not implicitly {@link TW.NEAR.Proto.CreateAccount.verify|verify} messages.
                 * @param message CreateAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.ICreateAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CreateAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CreateAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.CreateAccount;

                /**
                 * Verifies a CreateAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CreateAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CreateAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.CreateAccount;

                /**
                 * Creates a plain object from a CreateAccount message. Also converts values to other types if specified.
                 * @param message CreateAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.CreateAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CreateAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeployContract. */
            interface IDeployContract {

                /** DeployContract code */
                code?: (Uint8Array|null);
            }

            /** Represents a DeployContract. */
            class DeployContract implements IDeployContract {

                /**
                 * Constructs a new DeployContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IDeployContract);

                /** DeployContract code. */
                public code: Uint8Array;

                /**
                 * Creates a new DeployContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeployContract instance
                 */
                public static create(properties?: TW.NEAR.Proto.IDeployContract): TW.NEAR.Proto.DeployContract;

                /**
                 * Encodes the specified DeployContract message. Does not implicitly {@link TW.NEAR.Proto.DeployContract.verify|verify} messages.
                 * @param message DeployContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IDeployContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeployContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeployContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.DeployContract;

                /**
                 * Verifies a DeployContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeployContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeployContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.DeployContract;

                /**
                 * Creates a plain object from a DeployContract message. Also converts values to other types if specified.
                 * @param message DeployContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.DeployContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeployContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FunctionCall. */
            interface IFunctionCall {

                /** FunctionCall methodName */
                methodName?: (string|null);

                /** FunctionCall args */
                args?: (Uint8Array|null);

                /** FunctionCall gas */
                gas?: (Long|null);

                /** FunctionCall deposit */
                deposit?: (Uint8Array|null);
            }

            /** Represents a FunctionCall. */
            class FunctionCall implements IFunctionCall {

                /**
                 * Constructs a new FunctionCall.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IFunctionCall);

                /** FunctionCall methodName. */
                public methodName: string;

                /** FunctionCall args. */
                public args: Uint8Array;

                /** FunctionCall gas. */
                public gas: Long;

                /** FunctionCall deposit. */
                public deposit: Uint8Array;

                /**
                 * Creates a new FunctionCall instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FunctionCall instance
                 */
                public static create(properties?: TW.NEAR.Proto.IFunctionCall): TW.NEAR.Proto.FunctionCall;

                /**
                 * Encodes the specified FunctionCall message. Does not implicitly {@link TW.NEAR.Proto.FunctionCall.verify|verify} messages.
                 * @param message FunctionCall message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IFunctionCall, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FunctionCall message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FunctionCall
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.FunctionCall;

                /**
                 * Verifies a FunctionCall message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FunctionCall message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FunctionCall
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.FunctionCall;

                /**
                 * Creates a plain object from a FunctionCall message. Also converts values to other types if specified.
                 * @param message FunctionCall
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.FunctionCall, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FunctionCall to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer deposit */
                deposit?: (Uint8Array|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.ITransfer);

                /** Transfer deposit. */
                public deposit: Uint8Array;

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.NEAR.Proto.ITransfer): TW.NEAR.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.NEAR.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Stake. */
            interface IStake {

                /** Stake stake */
                stake?: (Uint8Array|null);

                /** Stake publicKey */
                publicKey?: (TW.NEAR.Proto.IPublicKey|null);
            }

            /** Represents a Stake. */
            class Stake implements IStake {

                /**
                 * Constructs a new Stake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IStake);

                /** Stake stake. */
                public stake: Uint8Array;

                /** Stake publicKey. */
                public publicKey?: (TW.NEAR.Proto.IPublicKey|null);

                /**
                 * Creates a new Stake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Stake instance
                 */
                public static create(properties?: TW.NEAR.Proto.IStake): TW.NEAR.Proto.Stake;

                /**
                 * Encodes the specified Stake message. Does not implicitly {@link TW.NEAR.Proto.Stake.verify|verify} messages.
                 * @param message Stake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Stake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Stake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.Stake;

                /**
                 * Verifies a Stake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Stake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Stake
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.Stake;

                /**
                 * Creates a plain object from a Stake message. Also converts values to other types if specified.
                 * @param message Stake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.Stake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Stake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AddKey. */
            interface IAddKey {

                /** AddKey publicKey */
                publicKey?: (TW.NEAR.Proto.IPublicKey|null);

                /** AddKey accessKey */
                accessKey?: (TW.NEAR.Proto.IAccessKey|null);
            }

            /** Represents an AddKey. */
            class AddKey implements IAddKey {

                /**
                 * Constructs a new AddKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IAddKey);

                /** AddKey publicKey. */
                public publicKey?: (TW.NEAR.Proto.IPublicKey|null);

                /** AddKey accessKey. */
                public accessKey?: (TW.NEAR.Proto.IAccessKey|null);

                /**
                 * Creates a new AddKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AddKey instance
                 */
                public static create(properties?: TW.NEAR.Proto.IAddKey): TW.NEAR.Proto.AddKey;

                /**
                 * Encodes the specified AddKey message. Does not implicitly {@link TW.NEAR.Proto.AddKey.verify|verify} messages.
                 * @param message AddKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IAddKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AddKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AddKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.AddKey;

                /**
                 * Verifies an AddKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AddKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AddKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.AddKey;

                /**
                 * Creates a plain object from an AddKey message. Also converts values to other types if specified.
                 * @param message AddKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.AddKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AddKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeleteKey. */
            interface IDeleteKey {

                /** DeleteKey publicKey */
                publicKey?: (TW.NEAR.Proto.IPublicKey|null);
            }

            /** Represents a DeleteKey. */
            class DeleteKey implements IDeleteKey {

                /**
                 * Constructs a new DeleteKey.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IDeleteKey);

                /** DeleteKey publicKey. */
                public publicKey?: (TW.NEAR.Proto.IPublicKey|null);

                /**
                 * Creates a new DeleteKey instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeleteKey instance
                 */
                public static create(properties?: TW.NEAR.Proto.IDeleteKey): TW.NEAR.Proto.DeleteKey;

                /**
                 * Encodes the specified DeleteKey message. Does not implicitly {@link TW.NEAR.Proto.DeleteKey.verify|verify} messages.
                 * @param message DeleteKey message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IDeleteKey, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeleteKey message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeleteKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.DeleteKey;

                /**
                 * Verifies a DeleteKey message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeleteKey message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeleteKey
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.DeleteKey;

                /**
                 * Creates a plain object from a DeleteKey message. Also converts values to other types if specified.
                 * @param message DeleteKey
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.DeleteKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeleteKey to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeleteAccount. */
            interface IDeleteAccount {

                /** DeleteAccount beneficiaryId */
                beneficiaryId?: (string|null);
            }

            /** Represents a DeleteAccount. */
            class DeleteAccount implements IDeleteAccount {

                /**
                 * Constructs a new DeleteAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IDeleteAccount);

                /** DeleteAccount beneficiaryId. */
                public beneficiaryId: string;

                /**
                 * Creates a new DeleteAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeleteAccount instance
                 */
                public static create(properties?: TW.NEAR.Proto.IDeleteAccount): TW.NEAR.Proto.DeleteAccount;

                /**
                 * Encodes the specified DeleteAccount message. Does not implicitly {@link TW.NEAR.Proto.DeleteAccount.verify|verify} messages.
                 * @param message DeleteAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IDeleteAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeleteAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeleteAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.DeleteAccount;

                /**
                 * Verifies a DeleteAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeleteAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeleteAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.DeleteAccount;

                /**
                 * Creates a plain object from a DeleteAccount message. Also converts values to other types if specified.
                 * @param message DeleteAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.DeleteAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeleteAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenTransfer. */
            interface ITokenTransfer {

                /** TokenTransfer tokenAmount */
                tokenAmount?: (string|null);

                /** TokenTransfer receiverId */
                receiverId?: (string|null);

                /** TokenTransfer gas */
                gas?: (Long|null);

                /** TokenTransfer deposit */
                deposit?: (Uint8Array|null);
            }

            /** Represents a TokenTransfer. */
            class TokenTransfer implements ITokenTransfer {

                /**
                 * Constructs a new TokenTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.ITokenTransfer);

                /** TokenTransfer tokenAmount. */
                public tokenAmount: string;

                /** TokenTransfer receiverId. */
                public receiverId: string;

                /** TokenTransfer gas. */
                public gas: Long;

                /** TokenTransfer deposit. */
                public deposit: Uint8Array;

                /**
                 * Creates a new TokenTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenTransfer instance
                 */
                public static create(properties?: TW.NEAR.Proto.ITokenTransfer): TW.NEAR.Proto.TokenTransfer;

                /**
                 * Encodes the specified TokenTransfer message. Does not implicitly {@link TW.NEAR.Proto.TokenTransfer.verify|verify} messages.
                 * @param message TokenTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.ITokenTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.TokenTransfer;

                /**
                 * Verifies a TokenTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.TokenTransfer;

                /**
                 * Creates a plain object from a TokenTransfer message. Also converts values to other types if specified.
                 * @param message TokenTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.TokenTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Action. */
            interface IAction {

                /** Action createAccount */
                createAccount?: (TW.NEAR.Proto.ICreateAccount|null);

                /** Action deployContract */
                deployContract?: (TW.NEAR.Proto.IDeployContract|null);

                /** Action functionCall */
                functionCall?: (TW.NEAR.Proto.IFunctionCall|null);

                /** Action transfer */
                transfer?: (TW.NEAR.Proto.ITransfer|null);

                /** Action stake */
                stake?: (TW.NEAR.Proto.IStake|null);

                /** Action addKey */
                addKey?: (TW.NEAR.Proto.IAddKey|null);

                /** Action deleteKey */
                deleteKey?: (TW.NEAR.Proto.IDeleteKey|null);

                /** Action deleteAccount */
                deleteAccount?: (TW.NEAR.Proto.IDeleteAccount|null);

                /** Action tokenTransfer */
                tokenTransfer?: (TW.NEAR.Proto.ITokenTransfer|null);
            }

            /** Represents an Action. */
            class Action implements IAction {

                /**
                 * Constructs a new Action.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.IAction);

                /** Action createAccount. */
                public createAccount?: (TW.NEAR.Proto.ICreateAccount|null);

                /** Action deployContract. */
                public deployContract?: (TW.NEAR.Proto.IDeployContract|null);

                /** Action functionCall. */
                public functionCall?: (TW.NEAR.Proto.IFunctionCall|null);

                /** Action transfer. */
                public transfer?: (TW.NEAR.Proto.ITransfer|null);

                /** Action stake. */
                public stake?: (TW.NEAR.Proto.IStake|null);

                /** Action addKey. */
                public addKey?: (TW.NEAR.Proto.IAddKey|null);

                /** Action deleteKey. */
                public deleteKey?: (TW.NEAR.Proto.IDeleteKey|null);

                /** Action deleteAccount. */
                public deleteAccount?: (TW.NEAR.Proto.IDeleteAccount|null);

                /** Action tokenTransfer. */
                public tokenTransfer?: (TW.NEAR.Proto.ITokenTransfer|null);

                /** Action payload. */
                public payload?: ("createAccount"|"deployContract"|"functionCall"|"transfer"|"stake"|"addKey"|"deleteKey"|"deleteAccount"|"tokenTransfer");

                /**
                 * Creates a new Action instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Action instance
                 */
                public static create(properties?: TW.NEAR.Proto.IAction): TW.NEAR.Proto.Action;

                /**
                 * Encodes the specified Action message. Does not implicitly {@link TW.NEAR.Proto.Action.verify|verify} messages.
                 * @param message Action message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.IAction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Action message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.Action;

                /**
                 * Verifies an Action message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Action
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.Action;

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @param message Action
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.Action, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Action to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput signerId */
                signerId?: (string|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput receiverId */
                receiverId?: (string|null);

                /** SigningInput blockHash */
                blockHash?: (Uint8Array|null);

                /** SigningInput actions */
                actions?: (TW.NEAR.Proto.IAction[]|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.ISigningInput);

                /** SigningInput signerId. */
                public signerId: string;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput receiverId. */
                public receiverId: string;

                /** SigningInput blockHash. */
                public blockHash: Uint8Array;

                /** SigningInput actions. */
                public actions: TW.NEAR.Proto.IAction[];

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.NEAR.Proto.ISigningInput): TW.NEAR.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.NEAR.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signedTransaction */
                signedTransaction?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput hash */
                hash?: (Uint8Array|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEAR.Proto.ISigningOutput);

                /** SigningOutput signedTransaction. */
                public signedTransaction: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput hash. */
                public hash: Uint8Array;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.NEAR.Proto.ISigningOutput): TW.NEAR.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NEAR.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEAR.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEAR.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEAR.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEAR.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Nebulas. */
    namespace Nebulas {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput fromAddress */
                fromAddress?: (string|null);

                /** SigningInput chainId */
                chainId?: (Uint8Array|null);

                /** SigningInput nonce */
                nonce?: (Uint8Array|null);

                /** SigningInput gasPrice */
                gasPrice?: (Uint8Array|null);

                /** SigningInput gasLimit */
                gasLimit?: (Uint8Array|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput amount */
                amount?: (Uint8Array|null);

                /** SigningInput timestamp */
                timestamp?: (Uint8Array|null);

                /** SigningInput payload */
                payload?: (string|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nebulas.Proto.ISigningInput);

                /** SigningInput fromAddress. */
                public fromAddress: string;

                /** SigningInput chainId. */
                public chainId: Uint8Array;

                /** SigningInput nonce. */
                public nonce: Uint8Array;

                /** SigningInput gasPrice. */
                public gasPrice: Uint8Array;

                /** SigningInput gasLimit. */
                public gasLimit: Uint8Array;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput amount. */
                public amount: Uint8Array;

                /** SigningInput timestamp. */
                public timestamp: Uint8Array;

                /** SigningInput payload. */
                public payload: string;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Nebulas.Proto.ISigningInput): TW.Nebulas.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nebulas.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nebulas.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nebulas.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nebulas.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nebulas.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput algorithm */
                algorithm?: (number|null);

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput raw */
                raw?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nebulas.Proto.ISigningOutput);

                /** SigningOutput algorithm. */
                public algorithm: number;

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput raw. */
                public raw: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Nebulas.Proto.ISigningOutput): TW.Nebulas.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nebulas.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nebulas.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nebulas.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nebulas.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nebulas.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Data. */
            interface IData {

                /** Data type */
                type?: (string|null);

                /** Data payload */
                payload?: (Uint8Array|null);
            }

            /** Represents a Data. */
            class Data implements IData {

                /**
                 * Constructs a new Data.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nebulas.Proto.IData);

                /** Data type. */
                public type: string;

                /** Data payload. */
                public payload: Uint8Array;

                /**
                 * Creates a new Data instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Data instance
                 */
                public static create(properties?: TW.Nebulas.Proto.IData): TW.Nebulas.Proto.Data;

                /**
                 * Encodes the specified Data message. Does not implicitly {@link TW.Nebulas.Proto.Data.verify|verify} messages.
                 * @param message Data message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nebulas.Proto.IData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Data message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nebulas.Proto.Data;

                /**
                 * Verifies a Data message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Data
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nebulas.Proto.Data;

                /**
                 * Creates a plain object from a Data message. Also converts values to other types if specified.
                 * @param message Data
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nebulas.Proto.Data, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Data to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a RawTransaction. */
            interface IRawTransaction {

                /** RawTransaction hash */
                hash?: (Uint8Array|null);

                /** RawTransaction from */
                from?: (Uint8Array|null);

                /** RawTransaction to */
                to?: (Uint8Array|null);

                /** RawTransaction value */
                value?: (Uint8Array|null);

                /** RawTransaction nonce */
                nonce?: (Long|null);

                /** RawTransaction timestamp */
                timestamp?: (Long|null);

                /** RawTransaction data */
                data?: (TW.Nebulas.Proto.IData|null);

                /** RawTransaction chainId */
                chainId?: (number|null);

                /** RawTransaction gasPrice */
                gasPrice?: (Uint8Array|null);

                /** RawTransaction gasLimit */
                gasLimit?: (Uint8Array|null);

                /** RawTransaction alg */
                alg?: (number|null);

                /** RawTransaction sign */
                sign?: (Uint8Array|null);
            }

            /** Represents a RawTransaction. */
            class RawTransaction implements IRawTransaction {

                /**
                 * Constructs a new RawTransaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nebulas.Proto.IRawTransaction);

                /** RawTransaction hash. */
                public hash: Uint8Array;

                /** RawTransaction from. */
                public from: Uint8Array;

                /** RawTransaction to. */
                public to: Uint8Array;

                /** RawTransaction value. */
                public value: Uint8Array;

                /** RawTransaction nonce. */
                public nonce: Long;

                /** RawTransaction timestamp. */
                public timestamp: Long;

                /** RawTransaction data. */
                public data?: (TW.Nebulas.Proto.IData|null);

                /** RawTransaction chainId. */
                public chainId: number;

                /** RawTransaction gasPrice. */
                public gasPrice: Uint8Array;

                /** RawTransaction gasLimit. */
                public gasLimit: Uint8Array;

                /** RawTransaction alg. */
                public alg: number;

                /** RawTransaction sign. */
                public sign: Uint8Array;

                /**
                 * Creates a new RawTransaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RawTransaction instance
                 */
                public static create(properties?: TW.Nebulas.Proto.IRawTransaction): TW.Nebulas.Proto.RawTransaction;

                /**
                 * Encodes the specified RawTransaction message. Does not implicitly {@link TW.Nebulas.Proto.RawTransaction.verify|verify} messages.
                 * @param message RawTransaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nebulas.Proto.IRawTransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RawTransaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RawTransaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nebulas.Proto.RawTransaction;

                /**
                 * Verifies a RawTransaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RawTransaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RawTransaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nebulas.Proto.RawTransaction;

                /**
                 * Creates a plain object from a RawTransaction message. Also converts values to other types if specified.
                 * @param message RawTransaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nebulas.Proto.RawTransaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RawTransaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace NEO. */
    namespace NEO {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransactionInput. */
            interface ITransactionInput {

                /** TransactionInput prevHash */
                prevHash?: (Uint8Array|null);

                /** TransactionInput prevIndex */
                prevIndex?: (number|null);

                /** TransactionInput value */
                value?: (Long|null);

                /** TransactionInput assetId */
                assetId?: (string|null);
            }

            /** Represents a TransactionInput. */
            class TransactionInput implements ITransactionInput {

                /**
                 * Constructs a new TransactionInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransactionInput);

                /** TransactionInput prevHash. */
                public prevHash: Uint8Array;

                /** TransactionInput prevIndex. */
                public prevIndex: number;

                /** TransactionInput value. */
                public value: Long;

                /** TransactionInput assetId. */
                public assetId: string;

                /**
                 * Creates a new TransactionInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionInput instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransactionInput): TW.NEO.Proto.TransactionInput;

                /**
                 * Encodes the specified TransactionInput message. Does not implicitly {@link TW.NEO.Proto.TransactionInput.verify|verify} messages.
                 * @param message TransactionInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransactionInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.TransactionInput;

                /**
                 * Verifies a TransactionInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.TransactionInput;

                /**
                 * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                 * @param message TransactionInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.TransactionInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OutputAddress. */
            interface IOutputAddress {

                /** OutputAddress amount */
                amount?: (Long|null);

                /** OutputAddress toAddress */
                toAddress?: (string|null);
            }

            /** Represents an OutputAddress. */
            class OutputAddress implements IOutputAddress {

                /**
                 * Constructs a new OutputAddress.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.IOutputAddress);

                /** OutputAddress amount. */
                public amount: Long;

                /** OutputAddress toAddress. */
                public toAddress: string;

                /**
                 * Creates a new OutputAddress instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OutputAddress instance
                 */
                public static create(properties?: TW.NEO.Proto.IOutputAddress): TW.NEO.Proto.OutputAddress;

                /**
                 * Encodes the specified OutputAddress message. Does not implicitly {@link TW.NEO.Proto.OutputAddress.verify|verify} messages.
                 * @param message OutputAddress message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.IOutputAddress, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OutputAddress message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OutputAddress
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.OutputAddress;

                /**
                 * Verifies an OutputAddress message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OutputAddress message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OutputAddress
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.OutputAddress;

                /**
                 * Creates a plain object from an OutputAddress message. Also converts values to other types if specified.
                 * @param message OutputAddress
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.OutputAddress, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OutputAddress to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOutput. */
            interface ITransactionOutput {

                /** TransactionOutput assetId */
                assetId?: (string|null);

                /** TransactionOutput amount */
                amount?: (Long|null);

                /** TransactionOutput toAddress */
                toAddress?: (string|null);

                /** TransactionOutput changeAddress */
                changeAddress?: (string|null);

                /** TransactionOutput extraOutputs */
                extraOutputs?: (TW.NEO.Proto.IOutputAddress[]|null);
            }

            /** Represents a TransactionOutput. */
            class TransactionOutput implements ITransactionOutput {

                /**
                 * Constructs a new TransactionOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransactionOutput);

                /** TransactionOutput assetId. */
                public assetId: string;

                /** TransactionOutput amount. */
                public amount: Long;

                /** TransactionOutput toAddress. */
                public toAddress: string;

                /** TransactionOutput changeAddress. */
                public changeAddress: string;

                /** TransactionOutput extraOutputs. */
                public extraOutputs: TW.NEO.Proto.IOutputAddress[];

                /**
                 * Creates a new TransactionOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOutput instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransactionOutput): TW.NEO.Proto.TransactionOutput;

                /**
                 * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.NEO.Proto.TransactionOutput.verify|verify} messages.
                 * @param message TransactionOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransactionOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.TransactionOutput;

                /**
                 * Verifies a TransactionOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.TransactionOutput;

                /**
                 * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                 * @param message TransactionOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.TransactionOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction nep5Transfer */
                nep5Transfer?: (TW.NEO.Proto.Transaction.INep5Transfer|null);

                /** Transaction invocationGeneric */
                invocationGeneric?: (TW.NEO.Proto.Transaction.IInvocationGeneric|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransaction);

                /** Transaction nep5Transfer. */
                public nep5Transfer?: (TW.NEO.Proto.Transaction.INep5Transfer|null);

                /** Transaction invocationGeneric. */
                public invocationGeneric?: (TW.NEO.Proto.Transaction.IInvocationGeneric|null);

                /** Transaction transactionOneof. */
                public transactionOneof?: ("nep5Transfer"|"invocationGeneric");

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransaction): TW.NEO.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.NEO.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Transaction {

                /** Properties of a Nep5Transfer. */
                interface INep5Transfer {

                    /** Nep5Transfer assetId */
                    assetId?: (string|null);

                    /** Nep5Transfer from */
                    from?: (string|null);

                    /** Nep5Transfer to */
                    to?: (string|null);

                    /** Nep5Transfer amount */
                    amount?: (Uint8Array|null);

                    /** Nep5Transfer scriptWithRet */
                    scriptWithRet?: (boolean|null);
                }

                /** Represents a Nep5Transfer. */
                class Nep5Transfer implements INep5Transfer {

                    /**
                     * Constructs a new Nep5Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.NEO.Proto.Transaction.INep5Transfer);

                    /** Nep5Transfer assetId. */
                    public assetId: string;

                    /** Nep5Transfer from. */
                    public from: string;

                    /** Nep5Transfer to. */
                    public to: string;

                    /** Nep5Transfer amount. */
                    public amount: Uint8Array;

                    /** Nep5Transfer scriptWithRet. */
                    public scriptWithRet: boolean;

                    /**
                     * Creates a new Nep5Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Nep5Transfer instance
                     */
                    public static create(properties?: TW.NEO.Proto.Transaction.INep5Transfer): TW.NEO.Proto.Transaction.Nep5Transfer;

                    /**
                     * Encodes the specified Nep5Transfer message. Does not implicitly {@link TW.NEO.Proto.Transaction.Nep5Transfer.verify|verify} messages.
                     * @param message Nep5Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.NEO.Proto.Transaction.INep5Transfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Nep5Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Nep5Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.Transaction.Nep5Transfer;

                    /**
                     * Verifies a Nep5Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Nep5Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Nep5Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.Transaction.Nep5Transfer;

                    /**
                     * Creates a plain object from a Nep5Transfer message. Also converts values to other types if specified.
                     * @param message Nep5Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.NEO.Proto.Transaction.Nep5Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Nep5Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an InvocationGeneric. */
                interface IInvocationGeneric {

                    /** InvocationGeneric gas */
                    gas?: (Long|null);

                    /** InvocationGeneric script */
                    script?: (Uint8Array|null);
                }

                /** Represents an InvocationGeneric. */
                class InvocationGeneric implements IInvocationGeneric {

                    /**
                     * Constructs a new InvocationGeneric.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.NEO.Proto.Transaction.IInvocationGeneric);

                    /** InvocationGeneric gas. */
                    public gas: Long;

                    /** InvocationGeneric script. */
                    public script: Uint8Array;

                    /**
                     * Creates a new InvocationGeneric instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns InvocationGeneric instance
                     */
                    public static create(properties?: TW.NEO.Proto.Transaction.IInvocationGeneric): TW.NEO.Proto.Transaction.InvocationGeneric;

                    /**
                     * Encodes the specified InvocationGeneric message. Does not implicitly {@link TW.NEO.Proto.Transaction.InvocationGeneric.verify|verify} messages.
                     * @param message InvocationGeneric message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.NEO.Proto.Transaction.IInvocationGeneric, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an InvocationGeneric message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns InvocationGeneric
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.Transaction.InvocationGeneric;

                    /**
                     * Verifies an InvocationGeneric message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an InvocationGeneric message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns InvocationGeneric
                     */
                    public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.Transaction.InvocationGeneric;

                    /**
                     * Creates a plain object from an InvocationGeneric message. Also converts values to other types if specified.
                     * @param message InvocationGeneric
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.NEO.Proto.Transaction.InvocationGeneric, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this InvocationGeneric to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput inputs */
                inputs?: (TW.NEO.Proto.ITransactionInput[]|null);

                /** SigningInput outputs */
                outputs?: (TW.NEO.Proto.ITransactionOutput[]|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput fee */
                fee?: (Long|null);

                /** SigningInput gasAssetId */
                gasAssetId?: (string|null);

                /** SigningInput gasChangeAddress */
                gasChangeAddress?: (string|null);

                /** SigningInput plan */
                plan?: (TW.NEO.Proto.ITransactionPlan|null);

                /** SigningInput transaction */
                transaction?: (TW.NEO.Proto.ITransaction|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ISigningInput);

                /** SigningInput inputs. */
                public inputs: TW.NEO.Proto.ITransactionInput[];

                /** SigningInput outputs. */
                public outputs: TW.NEO.Proto.ITransactionOutput[];

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput fee. */
                public fee: Long;

                /** SigningInput gasAssetId. */
                public gasAssetId: string;

                /** SigningInput gasChangeAddress. */
                public gasChangeAddress: string;

                /** SigningInput plan. */
                public plan?: (TW.NEO.Proto.ITransactionPlan|null);

                /** SigningInput transaction. */
                public transaction?: (TW.NEO.Proto.ITransaction|null);

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.NEO.Proto.ISigningInput): TW.NEO.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.NEO.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.NEO.Proto.ISigningOutput): TW.NEO.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NEO.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOutputPlan. */
            interface ITransactionOutputPlan {

                /** TransactionOutputPlan amount */
                amount?: (Long|null);

                /** TransactionOutputPlan availableAmount */
                availableAmount?: (Long|null);

                /** TransactionOutputPlan change */
                change?: (Long|null);

                /** TransactionOutputPlan assetId */
                assetId?: (string|null);

                /** TransactionOutputPlan toAddress */
                toAddress?: (string|null);

                /** TransactionOutputPlan changeAddress */
                changeAddress?: (string|null);

                /** TransactionOutputPlan extraOutputs */
                extraOutputs?: (TW.NEO.Proto.IOutputAddress[]|null);
            }

            /** Represents a TransactionOutputPlan. */
            class TransactionOutputPlan implements ITransactionOutputPlan {

                /**
                 * Constructs a new TransactionOutputPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransactionOutputPlan);

                /** TransactionOutputPlan amount. */
                public amount: Long;

                /** TransactionOutputPlan availableAmount. */
                public availableAmount: Long;

                /** TransactionOutputPlan change. */
                public change: Long;

                /** TransactionOutputPlan assetId. */
                public assetId: string;

                /** TransactionOutputPlan toAddress. */
                public toAddress: string;

                /** TransactionOutputPlan changeAddress. */
                public changeAddress: string;

                /** TransactionOutputPlan extraOutputs. */
                public extraOutputs: TW.NEO.Proto.IOutputAddress[];

                /**
                 * Creates a new TransactionOutputPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOutputPlan instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransactionOutputPlan): TW.NEO.Proto.TransactionOutputPlan;

                /**
                 * Encodes the specified TransactionOutputPlan message. Does not implicitly {@link TW.NEO.Proto.TransactionOutputPlan.verify|verify} messages.
                 * @param message TransactionOutputPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransactionOutputPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOutputPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOutputPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.TransactionOutputPlan;

                /**
                 * Verifies a TransactionOutputPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOutputPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOutputPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.TransactionOutputPlan;

                /**
                 * Creates a plain object from a TransactionOutputPlan message. Also converts values to other types if specified.
                 * @param message TransactionOutputPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.TransactionOutputPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOutputPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionAttributePlan. */
            interface ITransactionAttributePlan {

                /** TransactionAttributePlan usage */
                usage?: (number|null);

                /** TransactionAttributePlan data */
                data?: (Uint8Array|null);
            }

            /** Represents a TransactionAttributePlan. */
            class TransactionAttributePlan implements ITransactionAttributePlan {

                /**
                 * Constructs a new TransactionAttributePlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransactionAttributePlan);

                /** TransactionAttributePlan usage. */
                public usage: number;

                /** TransactionAttributePlan data. */
                public data: Uint8Array;

                /**
                 * Creates a new TransactionAttributePlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionAttributePlan instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransactionAttributePlan): TW.NEO.Proto.TransactionAttributePlan;

                /**
                 * Encodes the specified TransactionAttributePlan message. Does not implicitly {@link TW.NEO.Proto.TransactionAttributePlan.verify|verify} messages.
                 * @param message TransactionAttributePlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransactionAttributePlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionAttributePlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionAttributePlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.TransactionAttributePlan;

                /**
                 * Verifies a TransactionAttributePlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionAttributePlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionAttributePlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.TransactionAttributePlan;

                /**
                 * Creates a plain object from a TransactionAttributePlan message. Also converts values to other types if specified.
                 * @param message TransactionAttributePlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.TransactionAttributePlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionAttributePlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionPlan. */
            interface ITransactionPlan {

                /** TransactionPlan outputs */
                outputs?: (TW.NEO.Proto.ITransactionOutputPlan[]|null);

                /** TransactionPlan inputs */
                inputs?: (TW.NEO.Proto.ITransactionInput[]|null);

                /** TransactionPlan fee */
                fee?: (Long|null);

                /** TransactionPlan error */
                error?: (TW.Common.Proto.SigningError|null);

                /** TransactionPlan attributes */
                attributes?: (TW.NEO.Proto.ITransactionAttributePlan[]|null);
            }

            /** Represents a TransactionPlan. */
            class TransactionPlan implements ITransactionPlan {

                /**
                 * Constructs a new TransactionPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NEO.Proto.ITransactionPlan);

                /** TransactionPlan outputs. */
                public outputs: TW.NEO.Proto.ITransactionOutputPlan[];

                /** TransactionPlan inputs. */
                public inputs: TW.NEO.Proto.ITransactionInput[];

                /** TransactionPlan fee. */
                public fee: Long;

                /** TransactionPlan error. */
                public error: TW.Common.Proto.SigningError;

                /** TransactionPlan attributes. */
                public attributes: TW.NEO.Proto.ITransactionAttributePlan[];

                /**
                 * Creates a new TransactionPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionPlan instance
                 */
                public static create(properties?: TW.NEO.Proto.ITransactionPlan): TW.NEO.Proto.TransactionPlan;

                /**
                 * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.NEO.Proto.TransactionPlan.verify|verify} messages.
                 * @param message TransactionPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NEO.Proto.ITransactionPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NEO.Proto.TransactionPlan;

                /**
                 * Verifies a TransactionPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.NEO.Proto.TransactionPlan;

                /**
                 * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                 * @param message TransactionPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NEO.Proto.TransactionPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Nervos. */
    namespace Nervos {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransactionPlan. */
            interface ITransactionPlan {

                /** TransactionPlan cellDeps */
                cellDeps?: (TW.Nervos.Proto.ICellDep[]|null);

                /** TransactionPlan headerDeps */
                headerDeps?: (Uint8Array[]|null);

                /** TransactionPlan selectedCells */
                selectedCells?: (TW.Nervos.Proto.ICell[]|null);

                /** TransactionPlan outputs */
                outputs?: (TW.Nervos.Proto.ICellOutput[]|null);

                /** TransactionPlan outputsData */
                outputsData?: (Uint8Array[]|null);

                /** TransactionPlan error */
                error?: (TW.Common.Proto.SigningError|null);
            }

            /** Represents a TransactionPlan. */
            class TransactionPlan implements ITransactionPlan {

                /**
                 * Constructs a new TransactionPlan.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ITransactionPlan);

                /** TransactionPlan cellDeps. */
                public cellDeps: TW.Nervos.Proto.ICellDep[];

                /** TransactionPlan headerDeps. */
                public headerDeps: Uint8Array[];

                /** TransactionPlan selectedCells. */
                public selectedCells: TW.Nervos.Proto.ICell[];

                /** TransactionPlan outputs. */
                public outputs: TW.Nervos.Proto.ICellOutput[];

                /** TransactionPlan outputsData. */
                public outputsData: Uint8Array[];

                /** TransactionPlan error. */
                public error: TW.Common.Proto.SigningError;

                /**
                 * Creates a new TransactionPlan instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionPlan instance
                 */
                public static create(properties?: TW.Nervos.Proto.ITransactionPlan): TW.Nervos.Proto.TransactionPlan;

                /**
                 * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Nervos.Proto.TransactionPlan.verify|verify} messages.
                 * @param message TransactionPlan message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ITransactionPlan, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionPlan message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionPlan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.TransactionPlan;

                /**
                 * Verifies a TransactionPlan message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionPlan
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.TransactionPlan;

                /**
                 * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                 * @param message TransactionPlan
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.TransactionPlan, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionPlan to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CellDep. */
            interface ICellDep {

                /** CellDep depType */
                depType?: (string|null);

                /** CellDep outPoint */
                outPoint?: (TW.Nervos.Proto.IOutPoint|null);
            }

            /** Represents a CellDep. */
            class CellDep implements ICellDep {

                /**
                 * Constructs a new CellDep.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ICellDep);

                /** CellDep depType. */
                public depType: string;

                /** CellDep outPoint. */
                public outPoint?: (TW.Nervos.Proto.IOutPoint|null);

                /**
                 * Creates a new CellDep instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CellDep instance
                 */
                public static create(properties?: TW.Nervos.Proto.ICellDep): TW.Nervos.Proto.CellDep;

                /**
                 * Encodes the specified CellDep message. Does not implicitly {@link TW.Nervos.Proto.CellDep.verify|verify} messages.
                 * @param message CellDep message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ICellDep, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CellDep message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CellDep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.CellDep;

                /**
                 * Verifies a CellDep message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CellDep message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CellDep
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.CellDep;

                /**
                 * Creates a plain object from a CellDep message. Also converts values to other types if specified.
                 * @param message CellDep
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.CellDep, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CellDep to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OutPoint. */
            interface IOutPoint {

                /** OutPoint txHash */
                txHash?: (Uint8Array|null);

                /** OutPoint index */
                index?: (number|null);
            }

            /** Represents an OutPoint. */
            class OutPoint implements IOutPoint {

                /**
                 * Constructs a new OutPoint.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.IOutPoint);

                /** OutPoint txHash. */
                public txHash: Uint8Array;

                /** OutPoint index. */
                public index: number;

                /**
                 * Creates a new OutPoint instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OutPoint instance
                 */
                public static create(properties?: TW.Nervos.Proto.IOutPoint): TW.Nervos.Proto.OutPoint;

                /**
                 * Encodes the specified OutPoint message. Does not implicitly {@link TW.Nervos.Proto.OutPoint.verify|verify} messages.
                 * @param message OutPoint message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.IOutPoint, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OutPoint message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OutPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.OutPoint;

                /**
                 * Verifies an OutPoint message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OutPoint
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.OutPoint;

                /**
                 * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                 * @param message OutPoint
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.OutPoint, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OutPoint to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CellOutput. */
            interface ICellOutput {

                /** CellOutput capacity */
                capacity?: (Long|null);

                /** CellOutput lock */
                lock?: (TW.Nervos.Proto.IScript|null);

                /** CellOutput type */
                type?: (TW.Nervos.Proto.IScript|null);
            }

            /** Represents a CellOutput. */
            class CellOutput implements ICellOutput {

                /**
                 * Constructs a new CellOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ICellOutput);

                /** CellOutput capacity. */
                public capacity: Long;

                /** CellOutput lock. */
                public lock?: (TW.Nervos.Proto.IScript|null);

                /** CellOutput type. */
                public type?: (TW.Nervos.Proto.IScript|null);

                /**
                 * Creates a new CellOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CellOutput instance
                 */
                public static create(properties?: TW.Nervos.Proto.ICellOutput): TW.Nervos.Proto.CellOutput;

                /**
                 * Encodes the specified CellOutput message. Does not implicitly {@link TW.Nervos.Proto.CellOutput.verify|verify} messages.
                 * @param message CellOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ICellOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CellOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CellOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.CellOutput;

                /**
                 * Verifies a CellOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CellOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CellOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.CellOutput;

                /**
                 * Creates a plain object from a CellOutput message. Also converts values to other types if specified.
                 * @param message CellOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.CellOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CellOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Script. */
            interface IScript {

                /** Script codeHash */
                codeHash?: (Uint8Array|null);

                /** Script hashType */
                hashType?: (string|null);

                /** Script args */
                args?: (Uint8Array|null);
            }

            /** Represents a Script. */
            class Script implements IScript {

                /**
                 * Constructs a new Script.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.IScript);

                /** Script codeHash. */
                public codeHash: Uint8Array;

                /** Script hashType. */
                public hashType: string;

                /** Script args. */
                public args: Uint8Array;

                /**
                 * Creates a new Script instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Script instance
                 */
                public static create(properties?: TW.Nervos.Proto.IScript): TW.Nervos.Proto.Script;

                /**
                 * Encodes the specified Script message. Does not implicitly {@link TW.Nervos.Proto.Script.verify|verify} messages.
                 * @param message Script message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.IScript, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Script message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Script
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.Script;

                /**
                 * Verifies a Script message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Script message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Script
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.Script;

                /**
                 * Creates a plain object from a Script message. Also converts values to other types if specified.
                 * @param message Script
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.Script, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Script to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a NativeTransfer. */
            interface INativeTransfer {

                /** NativeTransfer toAddress */
                toAddress?: (string|null);

                /** NativeTransfer changeAddress */
                changeAddress?: (string|null);

                /** NativeTransfer amount */
                amount?: (Long|null);

                /** NativeTransfer useMaxAmount */
                useMaxAmount?: (boolean|null);
            }

            /** Represents a NativeTransfer. */
            class NativeTransfer implements INativeTransfer {

                /**
                 * Constructs a new NativeTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.INativeTransfer);

                /** NativeTransfer toAddress. */
                public toAddress: string;

                /** NativeTransfer changeAddress. */
                public changeAddress: string;

                /** NativeTransfer amount. */
                public amount: Long;

                /** NativeTransfer useMaxAmount. */
                public useMaxAmount: boolean;

                /**
                 * Creates a new NativeTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns NativeTransfer instance
                 */
                public static create(properties?: TW.Nervos.Proto.INativeTransfer): TW.Nervos.Proto.NativeTransfer;

                /**
                 * Encodes the specified NativeTransfer message. Does not implicitly {@link TW.Nervos.Proto.NativeTransfer.verify|verify} messages.
                 * @param message NativeTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.INativeTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NativeTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns NativeTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.NativeTransfer;

                /**
                 * Verifies a NativeTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a NativeTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns NativeTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.NativeTransfer;

                /**
                 * Creates a plain object from a NativeTransfer message. Also converts values to other types if specified.
                 * @param message NativeTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.NativeTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this NativeTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SudtTransfer. */
            interface ISudtTransfer {

                /** SudtTransfer toAddress */
                toAddress?: (string|null);

                /** SudtTransfer changeAddress */
                changeAddress?: (string|null);

                /** SudtTransfer sudtAddress */
                sudtAddress?: (Uint8Array|null);

                /** SudtTransfer amount */
                amount?: (string|null);

                /** SudtTransfer useMaxAmount */
                useMaxAmount?: (boolean|null);
            }

            /** Represents a SudtTransfer. */
            class SudtTransfer implements ISudtTransfer {

                /**
                 * Constructs a new SudtTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ISudtTransfer);

                /** SudtTransfer toAddress. */
                public toAddress: string;

                /** SudtTransfer changeAddress. */
                public changeAddress: string;

                /** SudtTransfer sudtAddress. */
                public sudtAddress: Uint8Array;

                /** SudtTransfer amount. */
                public amount: string;

                /** SudtTransfer useMaxAmount. */
                public useMaxAmount: boolean;

                /**
                 * Creates a new SudtTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SudtTransfer instance
                 */
                public static create(properties?: TW.Nervos.Proto.ISudtTransfer): TW.Nervos.Proto.SudtTransfer;

                /**
                 * Encodes the specified SudtTransfer message. Does not implicitly {@link TW.Nervos.Proto.SudtTransfer.verify|verify} messages.
                 * @param message SudtTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ISudtTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SudtTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SudtTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.SudtTransfer;

                /**
                 * Verifies a SudtTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SudtTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SudtTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.SudtTransfer;

                /**
                 * Creates a plain object from a SudtTransfer message. Also converts values to other types if specified.
                 * @param message SudtTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.SudtTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SudtTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DaoDeposit. */
            interface IDaoDeposit {

                /** DaoDeposit toAddress */
                toAddress?: (string|null);

                /** DaoDeposit changeAddress */
                changeAddress?: (string|null);

                /** DaoDeposit amount */
                amount?: (Long|null);
            }

            /** Represents a DaoDeposit. */
            class DaoDeposit implements IDaoDeposit {

                /**
                 * Constructs a new DaoDeposit.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.IDaoDeposit);

                /** DaoDeposit toAddress. */
                public toAddress: string;

                /** DaoDeposit changeAddress. */
                public changeAddress: string;

                /** DaoDeposit amount. */
                public amount: Long;

                /**
                 * Creates a new DaoDeposit instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DaoDeposit instance
                 */
                public static create(properties?: TW.Nervos.Proto.IDaoDeposit): TW.Nervos.Proto.DaoDeposit;

                /**
                 * Encodes the specified DaoDeposit message. Does not implicitly {@link TW.Nervos.Proto.DaoDeposit.verify|verify} messages.
                 * @param message DaoDeposit message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.IDaoDeposit, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DaoDeposit message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DaoDeposit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.DaoDeposit;

                /**
                 * Verifies a DaoDeposit message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DaoDeposit message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DaoDeposit
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.DaoDeposit;

                /**
                 * Creates a plain object from a DaoDeposit message. Also converts values to other types if specified.
                 * @param message DaoDeposit
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.DaoDeposit, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DaoDeposit to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DaoWithdrawPhase1. */
            interface IDaoWithdrawPhase1 {

                /** DaoWithdrawPhase1 depositCell */
                depositCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase1 changeAddress */
                changeAddress?: (string|null);
            }

            /** Represents a DaoWithdrawPhase1. */
            class DaoWithdrawPhase1 implements IDaoWithdrawPhase1 {

                /**
                 * Constructs a new DaoWithdrawPhase1.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.IDaoWithdrawPhase1);

                /** DaoWithdrawPhase1 depositCell. */
                public depositCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase1 changeAddress. */
                public changeAddress: string;

                /**
                 * Creates a new DaoWithdrawPhase1 instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DaoWithdrawPhase1 instance
                 */
                public static create(properties?: TW.Nervos.Proto.IDaoWithdrawPhase1): TW.Nervos.Proto.DaoWithdrawPhase1;

                /**
                 * Encodes the specified DaoWithdrawPhase1 message. Does not implicitly {@link TW.Nervos.Proto.DaoWithdrawPhase1.verify|verify} messages.
                 * @param message DaoWithdrawPhase1 message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.IDaoWithdrawPhase1, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DaoWithdrawPhase1 message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DaoWithdrawPhase1
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.DaoWithdrawPhase1;

                /**
                 * Verifies a DaoWithdrawPhase1 message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DaoWithdrawPhase1 message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DaoWithdrawPhase1
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.DaoWithdrawPhase1;

                /**
                 * Creates a plain object from a DaoWithdrawPhase1 message. Also converts values to other types if specified.
                 * @param message DaoWithdrawPhase1
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.DaoWithdrawPhase1, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DaoWithdrawPhase1 to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DaoWithdrawPhase2. */
            interface IDaoWithdrawPhase2 {

                /** DaoWithdrawPhase2 depositCell */
                depositCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase2 withdrawingCell */
                withdrawingCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase2 amount */
                amount?: (Long|null);
            }

            /** Represents a DaoWithdrawPhase2. */
            class DaoWithdrawPhase2 implements IDaoWithdrawPhase2 {

                /**
                 * Constructs a new DaoWithdrawPhase2.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.IDaoWithdrawPhase2);

                /** DaoWithdrawPhase2 depositCell. */
                public depositCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase2 withdrawingCell. */
                public withdrawingCell?: (TW.Nervos.Proto.ICell|null);

                /** DaoWithdrawPhase2 amount. */
                public amount: Long;

                /**
                 * Creates a new DaoWithdrawPhase2 instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DaoWithdrawPhase2 instance
                 */
                public static create(properties?: TW.Nervos.Proto.IDaoWithdrawPhase2): TW.Nervos.Proto.DaoWithdrawPhase2;

                /**
                 * Encodes the specified DaoWithdrawPhase2 message. Does not implicitly {@link TW.Nervos.Proto.DaoWithdrawPhase2.verify|verify} messages.
                 * @param message DaoWithdrawPhase2 message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.IDaoWithdrawPhase2, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DaoWithdrawPhase2 message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DaoWithdrawPhase2
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.DaoWithdrawPhase2;

                /**
                 * Verifies a DaoWithdrawPhase2 message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DaoWithdrawPhase2 message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DaoWithdrawPhase2
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.DaoWithdrawPhase2;

                /**
                 * Creates a plain object from a DaoWithdrawPhase2 message. Also converts values to other types if specified.
                 * @param message DaoWithdrawPhase2
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.DaoWithdrawPhase2, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DaoWithdrawPhase2 to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput byteFee */
                byteFee?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array[]|null);

                /** SigningInput cell */
                cell?: (TW.Nervos.Proto.ICell[]|null);

                /** SigningInput plan */
                plan?: (TW.Nervos.Proto.ITransactionPlan|null);

                /** SigningInput nativeTransfer */
                nativeTransfer?: (TW.Nervos.Proto.INativeTransfer|null);

                /** SigningInput sudtTransfer */
                sudtTransfer?: (TW.Nervos.Proto.ISudtTransfer|null);

                /** SigningInput daoDeposit */
                daoDeposit?: (TW.Nervos.Proto.IDaoDeposit|null);

                /** SigningInput daoWithdrawPhase1 */
                daoWithdrawPhase1?: (TW.Nervos.Proto.IDaoWithdrawPhase1|null);

                /** SigningInput daoWithdrawPhase2 */
                daoWithdrawPhase2?: (TW.Nervos.Proto.IDaoWithdrawPhase2|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ISigningInput);

                /** SigningInput byteFee. */
                public byteFee: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array[];

                /** SigningInput cell. */
                public cell: TW.Nervos.Proto.ICell[];

                /** SigningInput plan. */
                public plan?: (TW.Nervos.Proto.ITransactionPlan|null);

                /** SigningInput nativeTransfer. */
                public nativeTransfer?: (TW.Nervos.Proto.INativeTransfer|null);

                /** SigningInput sudtTransfer. */
                public sudtTransfer?: (TW.Nervos.Proto.ISudtTransfer|null);

                /** SigningInput daoDeposit. */
                public daoDeposit?: (TW.Nervos.Proto.IDaoDeposit|null);

                /** SigningInput daoWithdrawPhase1. */
                public daoWithdrawPhase1?: (TW.Nervos.Proto.IDaoWithdrawPhase1|null);

                /** SigningInput daoWithdrawPhase2. */
                public daoWithdrawPhase2?: (TW.Nervos.Proto.IDaoWithdrawPhase2|null);

                /** SigningInput operationOneof. */
                public operationOneof?: ("nativeTransfer"|"sudtTransfer"|"daoDeposit"|"daoWithdrawPhase1"|"daoWithdrawPhase2");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Nervos.Proto.ISigningInput): TW.Nervos.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nervos.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Cell. */
            interface ICell {

                /** Cell outPoint */
                outPoint?: (TW.Nervos.Proto.IOutPoint|null);

                /** Cell capacity */
                capacity?: (Long|null);

                /** Cell lock */
                lock?: (TW.Nervos.Proto.IScript|null);

                /** Cell type */
                type?: (TW.Nervos.Proto.IScript|null);

                /** Cell data */
                data?: (Uint8Array|null);

                /** Cell blockNumber */
                blockNumber?: (Long|null);

                /** Cell blockHash */
                blockHash?: (Uint8Array|null);

                /** Cell since */
                since?: (Long|null);

                /** Cell inputType */
                inputType?: (Uint8Array|null);

                /** Cell outputType */
                outputType?: (Uint8Array|null);
            }

            /** Represents a Cell. */
            class Cell implements ICell {

                /**
                 * Constructs a new Cell.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ICell);

                /** Cell outPoint. */
                public outPoint?: (TW.Nervos.Proto.IOutPoint|null);

                /** Cell capacity. */
                public capacity: Long;

                /** Cell lock. */
                public lock?: (TW.Nervos.Proto.IScript|null);

                /** Cell type. */
                public type?: (TW.Nervos.Proto.IScript|null);

                /** Cell data. */
                public data: Uint8Array;

                /** Cell blockNumber. */
                public blockNumber: Long;

                /** Cell blockHash. */
                public blockHash: Uint8Array;

                /** Cell since. */
                public since: Long;

                /** Cell inputType. */
                public inputType: Uint8Array;

                /** Cell outputType. */
                public outputType: Uint8Array;

                /**
                 * Creates a new Cell instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Cell instance
                 */
                public static create(properties?: TW.Nervos.Proto.ICell): TW.Nervos.Proto.Cell;

                /**
                 * Encodes the specified Cell message. Does not implicitly {@link TW.Nervos.Proto.Cell.verify|verify} messages.
                 * @param message Cell message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ICell, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Cell message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Cell
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.Cell;

                /**
                 * Verifies a Cell message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Cell message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Cell
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.Cell;

                /**
                 * Creates a plain object from a Cell message. Also converts values to other types if specified.
                 * @param message Cell
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.Cell, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Cell to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput transactionJson */
                transactionJson?: (string|null);

                /** SigningOutput transactionId */
                transactionId?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nervos.Proto.ISigningOutput);

                /** SigningOutput transactionJson. */
                public transactionJson: string;

                /** SigningOutput transactionId. */
                public transactionId: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Nervos.Proto.ISigningOutput): TW.Nervos.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nervos.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nervos.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nervos.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nervos.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nervos.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Nimiq. */
    namespace Nimiq {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput destination */
                destination?: (string|null);

                /** SigningInput value */
                value?: (Long|null);

                /** SigningInput fee */
                fee?: (Long|null);

                /** SigningInput validityStartHeight */
                validityStartHeight?: (number|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nimiq.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput destination. */
                public destination: string;

                /** SigningInput value. */
                public value: Long;

                /** SigningInput fee. */
                public fee: Long;

                /** SigningInput validityStartHeight. */
                public validityStartHeight: number;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Nimiq.Proto.ISigningInput): TW.Nimiq.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nimiq.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nimiq.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nimiq.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nimiq.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nimiq.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Nimiq.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Nimiq.Proto.ISigningOutput): TW.Nimiq.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nimiq.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Nimiq.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Nimiq.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Nimiq.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Nimiq.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace NULS. */
    namespace NULS {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransactionCoinFrom. */
            interface ITransactionCoinFrom {

                /** TransactionCoinFrom fromAddress */
                fromAddress?: (string|null);

                /** TransactionCoinFrom assetsChainid */
                assetsChainid?: (number|null);

                /** TransactionCoinFrom assetsId */
                assetsId?: (number|null);

                /** TransactionCoinFrom idAmount */
                idAmount?: (Uint8Array|null);

                /** TransactionCoinFrom nonce */
                nonce?: (Uint8Array|null);

                /** TransactionCoinFrom locked */
                locked?: (number|null);
            }

            /** Represents a TransactionCoinFrom. */
            class TransactionCoinFrom implements ITransactionCoinFrom {

                /**
                 * Constructs a new TransactionCoinFrom.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ITransactionCoinFrom);

                /** TransactionCoinFrom fromAddress. */
                public fromAddress: string;

                /** TransactionCoinFrom assetsChainid. */
                public assetsChainid: number;

                /** TransactionCoinFrom assetsId. */
                public assetsId: number;

                /** TransactionCoinFrom idAmount. */
                public idAmount: Uint8Array;

                /** TransactionCoinFrom nonce. */
                public nonce: Uint8Array;

                /** TransactionCoinFrom locked. */
                public locked: number;

                /**
                 * Creates a new TransactionCoinFrom instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionCoinFrom instance
                 */
                public static create(properties?: TW.NULS.Proto.ITransactionCoinFrom): TW.NULS.Proto.TransactionCoinFrom;

                /**
                 * Encodes the specified TransactionCoinFrom message. Does not implicitly {@link TW.NULS.Proto.TransactionCoinFrom.verify|verify} messages.
                 * @param message TransactionCoinFrom message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ITransactionCoinFrom, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionCoinFrom message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionCoinFrom
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.TransactionCoinFrom;

                /**
                 * Verifies a TransactionCoinFrom message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionCoinFrom message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionCoinFrom
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.TransactionCoinFrom;

                /**
                 * Creates a plain object from a TransactionCoinFrom message. Also converts values to other types if specified.
                 * @param message TransactionCoinFrom
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.TransactionCoinFrom, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionCoinFrom to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionCoinTo. */
            interface ITransactionCoinTo {

                /** TransactionCoinTo toAddress */
                toAddress?: (string|null);

                /** TransactionCoinTo assetsChainid */
                assetsChainid?: (number|null);

                /** TransactionCoinTo assetsId */
                assetsId?: (number|null);

                /** TransactionCoinTo idAmount */
                idAmount?: (Uint8Array|null);

                /** TransactionCoinTo lockTime */
                lockTime?: (number|null);
            }

            /** Represents a TransactionCoinTo. */
            class TransactionCoinTo implements ITransactionCoinTo {

                /**
                 * Constructs a new TransactionCoinTo.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ITransactionCoinTo);

                /** TransactionCoinTo toAddress. */
                public toAddress: string;

                /** TransactionCoinTo assetsChainid. */
                public assetsChainid: number;

                /** TransactionCoinTo assetsId. */
                public assetsId: number;

                /** TransactionCoinTo idAmount. */
                public idAmount: Uint8Array;

                /** TransactionCoinTo lockTime. */
                public lockTime: number;

                /**
                 * Creates a new TransactionCoinTo instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionCoinTo instance
                 */
                public static create(properties?: TW.NULS.Proto.ITransactionCoinTo): TW.NULS.Proto.TransactionCoinTo;

                /**
                 * Encodes the specified TransactionCoinTo message. Does not implicitly {@link TW.NULS.Proto.TransactionCoinTo.verify|verify} messages.
                 * @param message TransactionCoinTo message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ITransactionCoinTo, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionCoinTo message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionCoinTo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.TransactionCoinTo;

                /**
                 * Verifies a TransactionCoinTo message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionCoinTo message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionCoinTo
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.TransactionCoinTo;

                /**
                 * Creates a plain object from a TransactionCoinTo message. Also converts values to other types if specified.
                 * @param message TransactionCoinTo
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.TransactionCoinTo, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionCoinTo to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Signature. */
            interface ISignature {

                /** Signature pkeyLen */
                pkeyLen?: (number|null);

                /** Signature publicKey */
                publicKey?: (Uint8Array|null);

                /** Signature sigLen */
                sigLen?: (number|null);

                /** Signature signature */
                signature?: (Uint8Array|null);
            }

            /** Represents a Signature. */
            class Signature implements ISignature {

                /**
                 * Constructs a new Signature.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ISignature);

                /** Signature pkeyLen. */
                public pkeyLen: number;

                /** Signature publicKey. */
                public publicKey: Uint8Array;

                /** Signature sigLen. */
                public sigLen: number;

                /** Signature signature. */
                public signature: Uint8Array;

                /**
                 * Creates a new Signature instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Signature instance
                 */
                public static create(properties?: TW.NULS.Proto.ISignature): TW.NULS.Proto.Signature;

                /**
                 * Encodes the specified Signature message. Does not implicitly {@link TW.NULS.Proto.Signature.verify|verify} messages.
                 * @param message Signature message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ISignature, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Signature message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Signature
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.Signature;

                /**
                 * Verifies a Signature message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Signature
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.Signature;

                /**
                 * Creates a plain object from a Signature message. Also converts values to other types if specified.
                 * @param message Signature
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.Signature, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Signature to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction type */
                type?: (number|null);

                /** Transaction timestamp */
                timestamp?: (number|null);

                /** Transaction remark */
                remark?: (string|null);

                /** Transaction txData */
                txData?: (Uint8Array|null);

                /** Transaction input */
                input?: (TW.NULS.Proto.ITransactionCoinFrom[]|null);

                /** Transaction output */
                output?: (TW.NULS.Proto.ITransactionCoinTo[]|null);

                /** Transaction txSigs */
                txSigs?: (TW.NULS.Proto.ISignature|null);

                /** Transaction hash */
                hash?: (number|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ITransaction);

                /** Transaction type. */
                public type: number;

                /** Transaction timestamp. */
                public timestamp: number;

                /** Transaction remark. */
                public remark: string;

                /** Transaction txData. */
                public txData: Uint8Array;

                /** Transaction input. */
                public input: TW.NULS.Proto.ITransactionCoinFrom[];

                /** Transaction output. */
                public output: TW.NULS.Proto.ITransactionCoinTo[];

                /** Transaction txSigs. */
                public txSigs?: (TW.NULS.Proto.ISignature|null);

                /** Transaction hash. */
                public hash: number;

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.NULS.Proto.ITransaction): TW.NULS.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.NULS.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput from */
                from?: (string|null);

                /** SigningInput to */
                to?: (string|null);

                /** SigningInput amount */
                amount?: (Uint8Array|null);

                /** SigningInput chainId */
                chainId?: (number|null);

                /** SigningInput idassetsId */
                idassetsId?: (number|null);

                /** SigningInput nonce */
                nonce?: (Uint8Array|null);

                /** SigningInput remark */
                remark?: (string|null);

                /** SigningInput balance */
                balance?: (Uint8Array|null);

                /** SigningInput timestamp */
                timestamp?: (number|null);

                /** SigningInput feePayer */
                feePayer?: (string|null);

                /** SigningInput feePayerNonce */
                feePayerNonce?: (Uint8Array|null);

                /** SigningInput feePayerPrivateKey */
                feePayerPrivateKey?: (Uint8Array|null);

                /** SigningInput feePayerBalance */
                feePayerBalance?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput from. */
                public from: string;

                /** SigningInput to. */
                public to: string;

                /** SigningInput amount. */
                public amount: Uint8Array;

                /** SigningInput chainId. */
                public chainId: number;

                /** SigningInput idassetsId. */
                public idassetsId: number;

                /** SigningInput nonce. */
                public nonce: Uint8Array;

                /** SigningInput remark. */
                public remark: string;

                /** SigningInput balance. */
                public balance: Uint8Array;

                /** SigningInput timestamp. */
                public timestamp: number;

                /** SigningInput feePayer. */
                public feePayer: string;

                /** SigningInput feePayerNonce. */
                public feePayerNonce: Uint8Array;

                /** SigningInput feePayerPrivateKey. */
                public feePayerPrivateKey: Uint8Array;

                /** SigningInput feePayerBalance. */
                public feePayerBalance: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.NULS.Proto.ISigningInput): TW.NULS.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.NULS.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.NULS.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.NULS.Proto.ISigningOutput): TW.NULS.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NULS.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.NULS.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.NULS.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.NULS.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.NULS.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Oasis. */
    namespace Oasis {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransferMessage. */
            interface ITransferMessage {

                /** TransferMessage to */
                to?: (string|null);

                /** TransferMessage gasPrice */
                gasPrice?: (Long|null);

                /** TransferMessage gasAmount */
                gasAmount?: (string|null);

                /** TransferMessage amount */
                amount?: (string|null);

                /** TransferMessage nonce */
                nonce?: (Long|null);

                /** TransferMessage context */
                context?: (string|null);
            }

            /** Represents a TransferMessage. */
            class TransferMessage implements ITransferMessage {

                /**
                 * Constructs a new TransferMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Oasis.Proto.ITransferMessage);

                /** TransferMessage to. */
                public to: string;

                /** TransferMessage gasPrice. */
                public gasPrice: Long;

                /** TransferMessage gasAmount. */
                public gasAmount: string;

                /** TransferMessage amount. */
                public amount: string;

                /** TransferMessage nonce. */
                public nonce: Long;

                /** TransferMessage context. */
                public context: string;

                /**
                 * Creates a new TransferMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferMessage instance
                 */
                public static create(properties?: TW.Oasis.Proto.ITransferMessage): TW.Oasis.Proto.TransferMessage;

                /**
                 * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Oasis.Proto.TransferMessage.verify|verify} messages.
                 * @param message TransferMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Oasis.Proto.ITransferMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Oasis.Proto.TransferMessage;

                /**
                 * Verifies a TransferMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Oasis.Proto.TransferMessage;

                /**
                 * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                 * @param message TransferMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Oasis.Proto.TransferMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an EscrowMessage. */
            interface IEscrowMessage {

                /** EscrowMessage gasPrice */
                gasPrice?: (Long|null);

                /** EscrowMessage gasAmount */
                gasAmount?: (string|null);

                /** EscrowMessage nonce */
                nonce?: (Long|null);

                /** EscrowMessage account */
                account?: (string|null);

                /** EscrowMessage amount */
                amount?: (string|null);

                /** EscrowMessage context */
                context?: (string|null);
            }

            /** Represents an EscrowMessage. */
            class EscrowMessage implements IEscrowMessage {

                /**
                 * Constructs a new EscrowMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Oasis.Proto.IEscrowMessage);

                /** EscrowMessage gasPrice. */
                public gasPrice: Long;

                /** EscrowMessage gasAmount. */
                public gasAmount: string;

                /** EscrowMessage nonce. */
                public nonce: Long;

                /** EscrowMessage account. */
                public account: string;

                /** EscrowMessage amount. */
                public amount: string;

                /** EscrowMessage context. */
                public context: string;

                /**
                 * Creates a new EscrowMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns EscrowMessage instance
                 */
                public static create(properties?: TW.Oasis.Proto.IEscrowMessage): TW.Oasis.Proto.EscrowMessage;

                /**
                 * Encodes the specified EscrowMessage message. Does not implicitly {@link TW.Oasis.Proto.EscrowMessage.verify|verify} messages.
                 * @param message EscrowMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Oasis.Proto.IEscrowMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an EscrowMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns EscrowMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Oasis.Proto.EscrowMessage;

                /**
                 * Verifies an EscrowMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an EscrowMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns EscrowMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Oasis.Proto.EscrowMessage;

                /**
                 * Creates a plain object from an EscrowMessage message. Also converts values to other types if specified.
                 * @param message EscrowMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Oasis.Proto.EscrowMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this EscrowMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a ReclaimEscrowMessage. */
            interface IReclaimEscrowMessage {

                /** ReclaimEscrowMessage gasPrice */
                gasPrice?: (Long|null);

                /** ReclaimEscrowMessage gasAmount */
                gasAmount?: (string|null);

                /** ReclaimEscrowMessage nonce */
                nonce?: (Long|null);

                /** ReclaimEscrowMessage account */
                account?: (string|null);

                /** ReclaimEscrowMessage shares */
                shares?: (string|null);

                /** ReclaimEscrowMessage context */
                context?: (string|null);
            }

            /** Represents a ReclaimEscrowMessage. */
            class ReclaimEscrowMessage implements IReclaimEscrowMessage {

                /**
                 * Constructs a new ReclaimEscrowMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Oasis.Proto.IReclaimEscrowMessage);

                /** ReclaimEscrowMessage gasPrice. */
                public gasPrice: Long;

                /** ReclaimEscrowMessage gasAmount. */
                public gasAmount: string;

                /** ReclaimEscrowMessage nonce. */
                public nonce: Long;

                /** ReclaimEscrowMessage account. */
                public account: string;

                /** ReclaimEscrowMessage shares. */
                public shares: string;

                /** ReclaimEscrowMessage context. */
                public context: string;

                /**
                 * Creates a new ReclaimEscrowMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns ReclaimEscrowMessage instance
                 */
                public static create(properties?: TW.Oasis.Proto.IReclaimEscrowMessage): TW.Oasis.Proto.ReclaimEscrowMessage;

                /**
                 * Encodes the specified ReclaimEscrowMessage message. Does not implicitly {@link TW.Oasis.Proto.ReclaimEscrowMessage.verify|verify} messages.
                 * @param message ReclaimEscrowMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Oasis.Proto.IReclaimEscrowMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ReclaimEscrowMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns ReclaimEscrowMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Oasis.Proto.ReclaimEscrowMessage;

                /**
                 * Verifies a ReclaimEscrowMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a ReclaimEscrowMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns ReclaimEscrowMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Oasis.Proto.ReclaimEscrowMessage;

                /**
                 * Creates a plain object from a ReclaimEscrowMessage message. Also converts values to other types if specified.
                 * @param message ReclaimEscrowMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Oasis.Proto.ReclaimEscrowMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this ReclaimEscrowMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transfer */
                transfer?: (TW.Oasis.Proto.ITransferMessage|null);

                /** SigningInput escrow */
                escrow?: (TW.Oasis.Proto.IEscrowMessage|null);

                /** SigningInput reclaimEscrow */
                reclaimEscrow?: (TW.Oasis.Proto.IReclaimEscrowMessage|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Oasis.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transfer. */
                public transfer?: (TW.Oasis.Proto.ITransferMessage|null);

                /** SigningInput escrow. */
                public escrow?: (TW.Oasis.Proto.IEscrowMessage|null);

                /** SigningInput reclaimEscrow. */
                public reclaimEscrow?: (TW.Oasis.Proto.IReclaimEscrowMessage|null);

                /** SigningInput message. */
                public message?: ("transfer"|"escrow"|"reclaimEscrow");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Oasis.Proto.ISigningInput): TW.Oasis.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Oasis.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Oasis.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Oasis.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Oasis.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Oasis.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Oasis.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Oasis.Proto.ISigningOutput): TW.Oasis.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Oasis.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Oasis.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Oasis.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Oasis.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Oasis.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Ontology. */
    namespace Ontology {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput contract */
                contract?: (string|null);

                /** SigningInput method */
                method?: (string|null);

                /** SigningInput ownerPrivateKey */
                ownerPrivateKey?: (Uint8Array|null);

                /** SigningInput toAddress */
                toAddress?: (string|null);

                /** SigningInput amount */
                amount?: (Long|null);

                /** SigningInput payerPrivateKey */
                payerPrivateKey?: (Uint8Array|null);

                /** SigningInput gasPrice */
                gasPrice?: (Long|null);

                /** SigningInput gasLimit */
                gasLimit?: (Long|null);

                /** SigningInput queryAddress */
                queryAddress?: (string|null);

                /** SigningInput nonce */
                nonce?: (number|null);

                /** SigningInput ownerAddress */
                ownerAddress?: (string|null);

                /** SigningInput payerAddress */
                payerAddress?: (string|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ontology.Proto.ISigningInput);

                /** SigningInput contract. */
                public contract: string;

                /** SigningInput method. */
                public method: string;

                /** SigningInput ownerPrivateKey. */
                public ownerPrivateKey: Uint8Array;

                /** SigningInput toAddress. */
                public toAddress: string;

                /** SigningInput amount. */
                public amount: Long;

                /** SigningInput payerPrivateKey. */
                public payerPrivateKey: Uint8Array;

                /** SigningInput gasPrice. */
                public gasPrice: Long;

                /** SigningInput gasLimit. */
                public gasLimit: Long;

                /** SigningInput queryAddress. */
                public queryAddress: string;

                /** SigningInput nonce. */
                public nonce: number;

                /** SigningInput ownerAddress. */
                public ownerAddress: string;

                /** SigningInput payerAddress. */
                public payerAddress: string;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Ontology.Proto.ISigningInput): TW.Ontology.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ontology.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ontology.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ontology.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ontology.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ontology.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ontology.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Ontology.Proto.ISigningOutput): TW.Ontology.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ontology.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ontology.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ontology.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ontology.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ontology.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Polkadot. */
    namespace Polkadot {

        /** Namespace Proto. */
        namespace Proto {

            /** RewardDestination enum. */
            enum RewardDestination {
                STAKED = 0,
                STASH = 1,
                CONTROLLER = 2
            }

            /** Properties of an Era. */
            interface IEra {

                /** Era blockNumber */
                blockNumber?: (Long|null);

                /** Era period */
                period?: (Long|null);
            }

            /** Represents an Era. */
            class Era implements IEra {

                /**
                 * Constructs a new Era.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.IEra);

                /** Era blockNumber. */
                public blockNumber: Long;

                /** Era period. */
                public period: Long;

                /**
                 * Creates a new Era instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Era instance
                 */
                public static create(properties?: TW.Polkadot.Proto.IEra): TW.Polkadot.Proto.Era;

                /**
                 * Encodes the specified Era message. Does not implicitly {@link TW.Polkadot.Proto.Era.verify|verify} messages.
                 * @param message Era message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.IEra, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Era message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Era
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Era;

                /**
                 * Verifies an Era message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Era message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Era
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Era;

                /**
                 * Creates a plain object from an Era message. Also converts values to other types if specified.
                 * @param message Era
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.Era, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Era to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CustomCallIndices. */
            interface ICustomCallIndices {

                /** CustomCallIndices moduleIndex */
                moduleIndex?: (number|null);

                /** CustomCallIndices methodIndex */
                methodIndex?: (number|null);
            }

            /** Represents a CustomCallIndices. */
            class CustomCallIndices implements ICustomCallIndices {

                /**
                 * Constructs a new CustomCallIndices.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.ICustomCallIndices);

                /** CustomCallIndices moduleIndex. */
                public moduleIndex: number;

                /** CustomCallIndices methodIndex. */
                public methodIndex: number;

                /**
                 * Creates a new CustomCallIndices instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CustomCallIndices instance
                 */
                public static create(properties?: TW.Polkadot.Proto.ICustomCallIndices): TW.Polkadot.Proto.CustomCallIndices;

                /**
                 * Encodes the specified CustomCallIndices message. Does not implicitly {@link TW.Polkadot.Proto.CustomCallIndices.verify|verify} messages.
                 * @param message CustomCallIndices message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.ICustomCallIndices, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CustomCallIndices message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CustomCallIndices
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.CustomCallIndices;

                /**
                 * Verifies a CustomCallIndices message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CustomCallIndices message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CustomCallIndices
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.CustomCallIndices;

                /**
                 * Creates a plain object from a CustomCallIndices message. Also converts values to other types if specified.
                 * @param message CustomCallIndices
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.CustomCallIndices, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CustomCallIndices to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CallIndices. */
            interface ICallIndices {

                /** CallIndices custom */
                custom?: (TW.Polkadot.Proto.ICustomCallIndices|null);
            }

            /** Represents a CallIndices. */
            class CallIndices implements ICallIndices {

                /**
                 * Constructs a new CallIndices.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.ICallIndices);

                /** CallIndices custom. */
                public custom?: (TW.Polkadot.Proto.ICustomCallIndices|null);

                /** CallIndices variant. */
                public variant?: "custom";

                /**
                 * Creates a new CallIndices instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CallIndices instance
                 */
                public static create(properties?: TW.Polkadot.Proto.ICallIndices): TW.Polkadot.Proto.CallIndices;

                /**
                 * Encodes the specified CallIndices message. Does not implicitly {@link TW.Polkadot.Proto.CallIndices.verify|verify} messages.
                 * @param message CallIndices message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.ICallIndices, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CallIndices message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CallIndices
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.CallIndices;

                /**
                 * Verifies a CallIndices message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CallIndices message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CallIndices
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.CallIndices;

                /**
                 * Creates a plain object from a CallIndices message. Also converts values to other types if specified.
                 * @param message CallIndices
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.CallIndices, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CallIndices to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Balance. */
            interface IBalance {

                /** Balance transfer */
                transfer?: (TW.Polkadot.Proto.Balance.ITransfer|null);

                /** Balance batchTransfer */
                batchTransfer?: (TW.Polkadot.Proto.Balance.IBatchTransfer|null);

                /** Balance assetTransfer */
                assetTransfer?: (TW.Polkadot.Proto.Balance.IAssetTransfer|null);

                /** Balance batchAssetTransfer */
                batchAssetTransfer?: (TW.Polkadot.Proto.Balance.IBatchAssetTransfer|null);
            }

            /** Represents a Balance. */
            class Balance implements IBalance {

                /**
                 * Constructs a new Balance.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.IBalance);

                /** Balance transfer. */
                public transfer?: (TW.Polkadot.Proto.Balance.ITransfer|null);

                /** Balance batchTransfer. */
                public batchTransfer?: (TW.Polkadot.Proto.Balance.IBatchTransfer|null);

                /** Balance assetTransfer. */
                public assetTransfer?: (TW.Polkadot.Proto.Balance.IAssetTransfer|null);

                /** Balance batchAssetTransfer. */
                public batchAssetTransfer?: (TW.Polkadot.Proto.Balance.IBatchAssetTransfer|null);

                /** Balance messageOneof. */
                public messageOneof?: ("transfer"|"batchTransfer"|"assetTransfer"|"batchAssetTransfer");

                /**
                 * Creates a new Balance instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Balance instance
                 */
                public static create(properties?: TW.Polkadot.Proto.IBalance): TW.Polkadot.Proto.Balance;

                /**
                 * Encodes the specified Balance message. Does not implicitly {@link TW.Polkadot.Proto.Balance.verify|verify} messages.
                 * @param message Balance message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.IBalance, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Balance message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Balance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Balance;

                /**
                 * Verifies a Balance message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Balance message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Balance
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Balance;

                /**
                 * Creates a plain object from a Balance message. Also converts values to other types if specified.
                 * @param message Balance
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.Balance, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Balance to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Balance {

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer toAddress */
                    toAddress?: (string|null);

                    /** Transfer value */
                    value?: (Uint8Array|null);

                    /** Transfer memo */
                    memo?: (string|null);

                    /** Transfer callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Balance.ITransfer);

                    /** Transfer toAddress. */
                    public toAddress: string;

                    /** Transfer value. */
                    public value: Uint8Array;

                    /** Transfer memo. */
                    public memo: string;

                    /** Transfer callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Balance.ITransfer): TW.Polkadot.Proto.Balance.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Polkadot.Proto.Balance.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Balance.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Balance.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Balance.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Balance.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BatchTransfer. */
                interface IBatchTransfer {

                    /** BatchTransfer callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** BatchTransfer transfers */
                    transfers?: (TW.Polkadot.Proto.Balance.ITransfer[]|null);
                }

                /** Represents a BatchTransfer. */
                class BatchTransfer implements IBatchTransfer {

                    /**
                     * Constructs a new BatchTransfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Balance.IBatchTransfer);

                    /** BatchTransfer callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** BatchTransfer transfers. */
                    public transfers: TW.Polkadot.Proto.Balance.ITransfer[];

                    /**
                     * Creates a new BatchTransfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BatchTransfer instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Balance.IBatchTransfer): TW.Polkadot.Proto.Balance.BatchTransfer;

                    /**
                     * Encodes the specified BatchTransfer message. Does not implicitly {@link TW.Polkadot.Proto.Balance.BatchTransfer.verify|verify} messages.
                     * @param message BatchTransfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Balance.IBatchTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BatchTransfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BatchTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Balance.BatchTransfer;

                    /**
                     * Verifies a BatchTransfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BatchTransfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BatchTransfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Balance.BatchTransfer;

                    /**
                     * Creates a plain object from a BatchTransfer message. Also converts values to other types if specified.
                     * @param message BatchTransfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Balance.BatchTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BatchTransfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an AssetTransfer. */
                interface IAssetTransfer {

                    /** AssetTransfer callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** AssetTransfer toAddress */
                    toAddress?: (string|null);

                    /** AssetTransfer value */
                    value?: (Uint8Array|null);

                    /** AssetTransfer assetId */
                    assetId?: (number|null);

                    /** AssetTransfer feeAssetId */
                    feeAssetId?: (number|null);
                }

                /** Represents an AssetTransfer. */
                class AssetTransfer implements IAssetTransfer {

                    /**
                     * Constructs a new AssetTransfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Balance.IAssetTransfer);

                    /** AssetTransfer callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** AssetTransfer toAddress. */
                    public toAddress: string;

                    /** AssetTransfer value. */
                    public value: Uint8Array;

                    /** AssetTransfer assetId. */
                    public assetId: number;

                    /** AssetTransfer feeAssetId. */
                    public feeAssetId: number;

                    /**
                     * Creates a new AssetTransfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AssetTransfer instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Balance.IAssetTransfer): TW.Polkadot.Proto.Balance.AssetTransfer;

                    /**
                     * Encodes the specified AssetTransfer message. Does not implicitly {@link TW.Polkadot.Proto.Balance.AssetTransfer.verify|verify} messages.
                     * @param message AssetTransfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Balance.IAssetTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AssetTransfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AssetTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Balance.AssetTransfer;

                    /**
                     * Verifies an AssetTransfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AssetTransfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AssetTransfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Balance.AssetTransfer;

                    /**
                     * Creates a plain object from an AssetTransfer message. Also converts values to other types if specified.
                     * @param message AssetTransfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Balance.AssetTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AssetTransfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BatchAssetTransfer. */
                interface IBatchAssetTransfer {

                    /** BatchAssetTransfer callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** BatchAssetTransfer feeAssetId */
                    feeAssetId?: (number|null);

                    /** BatchAssetTransfer transfers */
                    transfers?: (TW.Polkadot.Proto.Balance.IAssetTransfer[]|null);
                }

                /** Represents a BatchAssetTransfer. */
                class BatchAssetTransfer implements IBatchAssetTransfer {

                    /**
                     * Constructs a new BatchAssetTransfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Balance.IBatchAssetTransfer);

                    /** BatchAssetTransfer callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** BatchAssetTransfer feeAssetId. */
                    public feeAssetId: number;

                    /** BatchAssetTransfer transfers. */
                    public transfers: TW.Polkadot.Proto.Balance.IAssetTransfer[];

                    /**
                     * Creates a new BatchAssetTransfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BatchAssetTransfer instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Balance.IBatchAssetTransfer): TW.Polkadot.Proto.Balance.BatchAssetTransfer;

                    /**
                     * Encodes the specified BatchAssetTransfer message. Does not implicitly {@link TW.Polkadot.Proto.Balance.BatchAssetTransfer.verify|verify} messages.
                     * @param message BatchAssetTransfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Balance.IBatchAssetTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BatchAssetTransfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BatchAssetTransfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Balance.BatchAssetTransfer;

                    /**
                     * Verifies a BatchAssetTransfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BatchAssetTransfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BatchAssetTransfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Balance.BatchAssetTransfer;

                    /**
                     * Creates a plain object from a BatchAssetTransfer message. Also converts values to other types if specified.
                     * @param message BatchAssetTransfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Balance.BatchAssetTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BatchAssetTransfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a Staking. */
            interface IStaking {

                /** Staking bond */
                bond?: (TW.Polkadot.Proto.Staking.IBond|null);

                /** Staking bondAndNominate */
                bondAndNominate?: (TW.Polkadot.Proto.Staking.IBondAndNominate|null);

                /** Staking bondExtra */
                bondExtra?: (TW.Polkadot.Proto.Staking.IBondExtra|null);

                /** Staking unbond */
                unbond?: (TW.Polkadot.Proto.Staking.IUnbond|null);

                /** Staking withdrawUnbonded */
                withdrawUnbonded?: (TW.Polkadot.Proto.Staking.IWithdrawUnbonded|null);

                /** Staking nominate */
                nominate?: (TW.Polkadot.Proto.Staking.INominate|null);

                /** Staking chill */
                chill?: (TW.Polkadot.Proto.Staking.IChill|null);

                /** Staking chillAndUnbond */
                chillAndUnbond?: (TW.Polkadot.Proto.Staking.IChillAndUnbond|null);

                /** Staking rebond */
                rebond?: (TW.Polkadot.Proto.Staking.IRebond|null);
            }

            /** Represents a Staking. */
            class Staking implements IStaking {

                /**
                 * Constructs a new Staking.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.IStaking);

                /** Staking bond. */
                public bond?: (TW.Polkadot.Proto.Staking.IBond|null);

                /** Staking bondAndNominate. */
                public bondAndNominate?: (TW.Polkadot.Proto.Staking.IBondAndNominate|null);

                /** Staking bondExtra. */
                public bondExtra?: (TW.Polkadot.Proto.Staking.IBondExtra|null);

                /** Staking unbond. */
                public unbond?: (TW.Polkadot.Proto.Staking.IUnbond|null);

                /** Staking withdrawUnbonded. */
                public withdrawUnbonded?: (TW.Polkadot.Proto.Staking.IWithdrawUnbonded|null);

                /** Staking nominate. */
                public nominate?: (TW.Polkadot.Proto.Staking.INominate|null);

                /** Staking chill. */
                public chill?: (TW.Polkadot.Proto.Staking.IChill|null);

                /** Staking chillAndUnbond. */
                public chillAndUnbond?: (TW.Polkadot.Proto.Staking.IChillAndUnbond|null);

                /** Staking rebond. */
                public rebond?: (TW.Polkadot.Proto.Staking.IRebond|null);

                /** Staking messageOneof. */
                public messageOneof?: ("bond"|"bondAndNominate"|"bondExtra"|"unbond"|"withdrawUnbonded"|"nominate"|"chill"|"chillAndUnbond"|"rebond");

                /**
                 * Creates a new Staking instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Staking instance
                 */
                public static create(properties?: TW.Polkadot.Proto.IStaking): TW.Polkadot.Proto.Staking;

                /**
                 * Encodes the specified Staking message. Does not implicitly {@link TW.Polkadot.Proto.Staking.verify|verify} messages.
                 * @param message Staking message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.IStaking, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Staking message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Staking
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking;

                /**
                 * Verifies a Staking message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Staking message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Staking
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking;

                /**
                 * Creates a plain object from a Staking message. Also converts values to other types if specified.
                 * @param message Staking
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.Staking, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Staking to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Staking {

                /** Properties of a Bond. */
                interface IBond {

                    /** Bond controller */
                    controller?: (string|null);

                    /** Bond value */
                    value?: (Uint8Array|null);

                    /** Bond rewardDestination */
                    rewardDestination?: (TW.Polkadot.Proto.RewardDestination|null);

                    /** Bond callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a Bond. */
                class Bond implements IBond {

                    /**
                     * Constructs a new Bond.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IBond);

                    /** Bond controller. */
                    public controller: string;

                    /** Bond value. */
                    public value: Uint8Array;

                    /** Bond rewardDestination. */
                    public rewardDestination: TW.Polkadot.Proto.RewardDestination;

                    /** Bond callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Bond instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Bond instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IBond): TW.Polkadot.Proto.Staking.Bond;

                    /**
                     * Encodes the specified Bond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Bond.verify|verify} messages.
                     * @param message Bond message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IBond, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Bond message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Bond
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.Bond;

                    /**
                     * Verifies a Bond message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Bond message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Bond
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.Bond;

                    /**
                     * Creates a plain object from a Bond message. Also converts values to other types if specified.
                     * @param message Bond
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.Bond, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Bond to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BondAndNominate. */
                interface IBondAndNominate {

                    /** BondAndNominate controller */
                    controller?: (string|null);

                    /** BondAndNominate value */
                    value?: (Uint8Array|null);

                    /** BondAndNominate rewardDestination */
                    rewardDestination?: (TW.Polkadot.Proto.RewardDestination|null);

                    /** BondAndNominate nominators */
                    nominators?: (string[]|null);

                    /** BondAndNominate callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a BondAndNominate. */
                class BondAndNominate implements IBondAndNominate {

                    /**
                     * Constructs a new BondAndNominate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IBondAndNominate);

                    /** BondAndNominate controller. */
                    public controller: string;

                    /** BondAndNominate value. */
                    public value: Uint8Array;

                    /** BondAndNominate rewardDestination. */
                    public rewardDestination: TW.Polkadot.Proto.RewardDestination;

                    /** BondAndNominate nominators. */
                    public nominators: string[];

                    /** BondAndNominate callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new BondAndNominate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BondAndNominate instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IBondAndNominate): TW.Polkadot.Proto.Staking.BondAndNominate;

                    /**
                     * Encodes the specified BondAndNominate message. Does not implicitly {@link TW.Polkadot.Proto.Staking.BondAndNominate.verify|verify} messages.
                     * @param message BondAndNominate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IBondAndNominate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BondAndNominate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BondAndNominate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.BondAndNominate;

                    /**
                     * Verifies a BondAndNominate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BondAndNominate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BondAndNominate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.BondAndNominate;

                    /**
                     * Creates a plain object from a BondAndNominate message. Also converts values to other types if specified.
                     * @param message BondAndNominate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.BondAndNominate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BondAndNominate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a BondExtra. */
                interface IBondExtra {

                    /** BondExtra value */
                    value?: (Uint8Array|null);

                    /** BondExtra callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a BondExtra. */
                class BondExtra implements IBondExtra {

                    /**
                     * Constructs a new BondExtra.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IBondExtra);

                    /** BondExtra value. */
                    public value: Uint8Array;

                    /** BondExtra callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new BondExtra instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns BondExtra instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IBondExtra): TW.Polkadot.Proto.Staking.BondExtra;

                    /**
                     * Encodes the specified BondExtra message. Does not implicitly {@link TW.Polkadot.Proto.Staking.BondExtra.verify|verify} messages.
                     * @param message BondExtra message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IBondExtra, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a BondExtra message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns BondExtra
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.BondExtra;

                    /**
                     * Verifies a BondExtra message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a BondExtra message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns BondExtra
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.BondExtra;

                    /**
                     * Creates a plain object from a BondExtra message. Also converts values to other types if specified.
                     * @param message BondExtra
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.BondExtra, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this BondExtra to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an Unbond. */
                interface IUnbond {

                    /** Unbond value */
                    value?: (Uint8Array|null);

                    /** Unbond callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents an Unbond. */
                class Unbond implements IUnbond {

                    /**
                     * Constructs a new Unbond.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IUnbond);

                    /** Unbond value. */
                    public value: Uint8Array;

                    /** Unbond callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Unbond instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Unbond instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IUnbond): TW.Polkadot.Proto.Staking.Unbond;

                    /**
                     * Encodes the specified Unbond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Unbond.verify|verify} messages.
                     * @param message Unbond message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IUnbond, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an Unbond message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Unbond
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.Unbond;

                    /**
                     * Verifies an Unbond message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an Unbond message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Unbond
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.Unbond;

                    /**
                     * Creates a plain object from an Unbond message. Also converts values to other types if specified.
                     * @param message Unbond
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.Unbond, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Unbond to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Rebond. */
                interface IRebond {

                    /** Rebond value */
                    value?: (Uint8Array|null);

                    /** Rebond callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a Rebond. */
                class Rebond implements IRebond {

                    /**
                     * Constructs a new Rebond.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IRebond);

                    /** Rebond value. */
                    public value: Uint8Array;

                    /** Rebond callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Rebond instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Rebond instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IRebond): TW.Polkadot.Proto.Staking.Rebond;

                    /**
                     * Encodes the specified Rebond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Rebond.verify|verify} messages.
                     * @param message Rebond message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IRebond, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Rebond message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Rebond
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.Rebond;

                    /**
                     * Verifies a Rebond message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Rebond message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Rebond
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.Rebond;

                    /**
                     * Creates a plain object from a Rebond message. Also converts values to other types if specified.
                     * @param message Rebond
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.Rebond, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Rebond to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a WithdrawUnbonded. */
                interface IWithdrawUnbonded {

                    /** WithdrawUnbonded slashingSpans */
                    slashingSpans?: (number|null);

                    /** WithdrawUnbonded callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a WithdrawUnbonded. */
                class WithdrawUnbonded implements IWithdrawUnbonded {

                    /**
                     * Constructs a new WithdrawUnbonded.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IWithdrawUnbonded);

                    /** WithdrawUnbonded slashingSpans. */
                    public slashingSpans: number;

                    /** WithdrawUnbonded callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new WithdrawUnbonded instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns WithdrawUnbonded instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IWithdrawUnbonded): TW.Polkadot.Proto.Staking.WithdrawUnbonded;

                    /**
                     * Encodes the specified WithdrawUnbonded message. Does not implicitly {@link TW.Polkadot.Proto.Staking.WithdrawUnbonded.verify|verify} messages.
                     * @param message WithdrawUnbonded message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IWithdrawUnbonded, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a WithdrawUnbonded message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns WithdrawUnbonded
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.WithdrawUnbonded;

                    /**
                     * Verifies a WithdrawUnbonded message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a WithdrawUnbonded message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns WithdrawUnbonded
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.WithdrawUnbonded;

                    /**
                     * Creates a plain object from a WithdrawUnbonded message. Also converts values to other types if specified.
                     * @param message WithdrawUnbonded
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.WithdrawUnbonded, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this WithdrawUnbonded to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Nominate. */
                interface INominate {

                    /** Nominate nominators */
                    nominators?: (string[]|null);

                    /** Nominate callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a Nominate. */
                class Nominate implements INominate {

                    /**
                     * Constructs a new Nominate.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.INominate);

                    /** Nominate nominators. */
                    public nominators: string[];

                    /** Nominate callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Nominate instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Nominate instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.INominate): TW.Polkadot.Proto.Staking.Nominate;

                    /**
                     * Encodes the specified Nominate message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Nominate.verify|verify} messages.
                     * @param message Nominate message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.INominate, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Nominate message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Nominate
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.Nominate;

                    /**
                     * Verifies a Nominate message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Nominate message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Nominate
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.Nominate;

                    /**
                     * Creates a plain object from a Nominate message. Also converts values to other types if specified.
                     * @param message Nominate
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.Nominate, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Nominate to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a ChillAndUnbond. */
                interface IChillAndUnbond {

                    /** ChillAndUnbond value */
                    value?: (Uint8Array|null);

                    /** ChillAndUnbond callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a ChillAndUnbond. */
                class ChillAndUnbond implements IChillAndUnbond {

                    /**
                     * Constructs a new ChillAndUnbond.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IChillAndUnbond);

                    /** ChillAndUnbond value. */
                    public value: Uint8Array;

                    /** ChillAndUnbond callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new ChillAndUnbond instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns ChillAndUnbond instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IChillAndUnbond): TW.Polkadot.Proto.Staking.ChillAndUnbond;

                    /**
                     * Encodes the specified ChillAndUnbond message. Does not implicitly {@link TW.Polkadot.Proto.Staking.ChillAndUnbond.verify|verify} messages.
                     * @param message ChillAndUnbond message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IChillAndUnbond, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a ChillAndUnbond message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns ChillAndUnbond
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.ChillAndUnbond;

                    /**
                     * Verifies a ChillAndUnbond message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a ChillAndUnbond message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns ChillAndUnbond
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.ChillAndUnbond;

                    /**
                     * Creates a plain object from a ChillAndUnbond message. Also converts values to other types if specified.
                     * @param message ChillAndUnbond
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.ChillAndUnbond, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this ChillAndUnbond to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Chill. */
                interface IChill {

                    /** Chill callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);
                }

                /** Represents a Chill. */
                class Chill implements IChill {

                    /**
                     * Constructs a new Chill.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Staking.IChill);

                    /** Chill callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /**
                     * Creates a new Chill instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Chill instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Staking.IChill): TW.Polkadot.Proto.Staking.Chill;

                    /**
                     * Encodes the specified Chill message. Does not implicitly {@link TW.Polkadot.Proto.Staking.Chill.verify|verify} messages.
                     * @param message Chill message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Staking.IChill, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Chill message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Chill
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Staking.Chill;

                    /**
                     * Verifies a Chill message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Chill message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Chill
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Staking.Chill;

                    /**
                     * Creates a plain object from a Chill message. Also converts values to other types if specified.
                     * @param message Chill
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Staking.Chill, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Chill to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of an Identity. */
            interface IIdentity {

                /** Identity joinIdentityAsKey */
                joinIdentityAsKey?: (TW.Polkadot.Proto.Identity.IJoinIdentityAsKey|null);

                /** Identity addAuthorization */
                addAuthorization?: (TW.Polkadot.Proto.Identity.IAddAuthorization|null);
            }

            /** Represents an Identity. */
            class Identity implements IIdentity {

                /**
                 * Constructs a new Identity.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.IIdentity);

                /** Identity joinIdentityAsKey. */
                public joinIdentityAsKey?: (TW.Polkadot.Proto.Identity.IJoinIdentityAsKey|null);

                /** Identity addAuthorization. */
                public addAuthorization?: (TW.Polkadot.Proto.Identity.IAddAuthorization|null);

                /** Identity messageOneof. */
                public messageOneof?: ("joinIdentityAsKey"|"addAuthorization");

                /**
                 * Creates a new Identity instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Identity instance
                 */
                public static create(properties?: TW.Polkadot.Proto.IIdentity): TW.Polkadot.Proto.Identity;

                /**
                 * Encodes the specified Identity message. Does not implicitly {@link TW.Polkadot.Proto.Identity.verify|verify} messages.
                 * @param message Identity message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.IIdentity, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Identity message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Identity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Identity;

                /**
                 * Verifies an Identity message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Identity message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Identity
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Identity;

                /**
                 * Creates a plain object from an Identity message. Also converts values to other types if specified.
                 * @param message Identity
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.Identity, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Identity to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Identity {

                /** Properties of a JoinIdentityAsKey. */
                interface IJoinIdentityAsKey {

                    /** JoinIdentityAsKey callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** JoinIdentityAsKey authId */
                    authId?: (Long|null);
                }

                /** Represents a JoinIdentityAsKey. */
                class JoinIdentityAsKey implements IJoinIdentityAsKey {

                    /**
                     * Constructs a new JoinIdentityAsKey.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Identity.IJoinIdentityAsKey);

                    /** JoinIdentityAsKey callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** JoinIdentityAsKey authId. */
                    public authId: Long;

                    /**
                     * Creates a new JoinIdentityAsKey instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns JoinIdentityAsKey instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Identity.IJoinIdentityAsKey): TW.Polkadot.Proto.Identity.JoinIdentityAsKey;

                    /**
                     * Encodes the specified JoinIdentityAsKey message. Does not implicitly {@link TW.Polkadot.Proto.Identity.JoinIdentityAsKey.verify|verify} messages.
                     * @param message JoinIdentityAsKey message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Identity.IJoinIdentityAsKey, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a JoinIdentityAsKey message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns JoinIdentityAsKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Identity.JoinIdentityAsKey;

                    /**
                     * Verifies a JoinIdentityAsKey message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a JoinIdentityAsKey message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns JoinIdentityAsKey
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Identity.JoinIdentityAsKey;

                    /**
                     * Creates a plain object from a JoinIdentityAsKey message. Also converts values to other types if specified.
                     * @param message JoinIdentityAsKey
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Identity.JoinIdentityAsKey, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this JoinIdentityAsKey to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of an AddAuthorization. */
                interface IAddAuthorization {

                    /** AddAuthorization callIndices */
                    callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** AddAuthorization target */
                    target?: (string|null);

                    /** AddAuthorization data */
                    data?: (TW.Polkadot.Proto.Identity.AddAuthorization.IAuthData|null);

                    /** AddAuthorization expiry */
                    expiry?: (Long|null);
                }

                /** Represents an AddAuthorization. */
                class AddAuthorization implements IAddAuthorization {

                    /**
                     * Constructs a new AddAuthorization.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Polkadot.Proto.Identity.IAddAuthorization);

                    /** AddAuthorization callIndices. */
                    public callIndices?: (TW.Polkadot.Proto.ICallIndices|null);

                    /** AddAuthorization target. */
                    public target: string;

                    /** AddAuthorization data. */
                    public data?: (TW.Polkadot.Proto.Identity.AddAuthorization.IAuthData|null);

                    /** AddAuthorization expiry. */
                    public expiry: Long;

                    /**
                     * Creates a new AddAuthorization instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns AddAuthorization instance
                     */
                    public static create(properties?: TW.Polkadot.Proto.Identity.IAddAuthorization): TW.Polkadot.Proto.Identity.AddAuthorization;

                    /**
                     * Encodes the specified AddAuthorization message. Does not implicitly {@link TW.Polkadot.Proto.Identity.AddAuthorization.verify|verify} messages.
                     * @param message AddAuthorization message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Polkadot.Proto.Identity.IAddAuthorization, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an AddAuthorization message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns AddAuthorization
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Identity.AddAuthorization;

                    /**
                     * Verifies an AddAuthorization message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates an AddAuthorization message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns AddAuthorization
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Identity.AddAuthorization;

                    /**
                     * Creates a plain object from an AddAuthorization message. Also converts values to other types if specified.
                     * @param message AddAuthorization
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Polkadot.Proto.Identity.AddAuthorization, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this AddAuthorization to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                namespace AddAuthorization {

                    /** Properties of a Data. */
                    interface IData {

                        /** Data data */
                        data?: (Uint8Array|null);
                    }

                    /** Represents a Data. */
                    class Data implements IData {

                        /**
                         * Constructs a new Data.
                         * @param [properties] Properties to set
                         */
                        constructor(properties?: TW.Polkadot.Proto.Identity.AddAuthorization.IData);

                        /** Data data. */
                        public data: Uint8Array;

                        /**
                         * Creates a new Data instance using the specified properties.
                         * @param [properties] Properties to set
                         * @returns Data instance
                         */
                        public static create(properties?: TW.Polkadot.Proto.Identity.AddAuthorization.IData): TW.Polkadot.Proto.Identity.AddAuthorization.Data;

                        /**
                         * Encodes the specified Data message. Does not implicitly {@link TW.Polkadot.Proto.Identity.AddAuthorization.Data.verify|verify} messages.
                         * @param message Data message or plain object to encode
                         * @param [writer] Writer to encode to
                         * @returns Writer
                         */
                        public static encode(message: TW.Polkadot.Proto.Identity.AddAuthorization.IData, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes a Data message from the specified reader or buffer.
                         * @param reader Reader or buffer to decode from
                         * @param [length] Message length if known beforehand
                         * @returns Data
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Identity.AddAuthorization.Data;

                        /**
                         * Verifies a Data message.
                         * @param message Plain object to verify
                         * @returns `null` if valid, otherwise the reason why it is not
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates a Data message from a plain object. Also converts values to their respective internal types.
                         * @param object Plain object
                         * @returns Data
                         */
                        public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Identity.AddAuthorization.Data;

                        /**
                         * Creates a plain object from a Data message. Also converts values to other types if specified.
                         * @param message Data
                         * @param [options] Conversion options
                         * @returns Plain object
                         */
                        public static toObject(message: TW.Polkadot.Proto.Identity.AddAuthorization.Data, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Converts this Data to JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }

                    /** Properties of an AuthData. */
                    interface IAuthData {

                        /** AuthData asset */
                        asset?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);

                        /** AuthData extrinsic */
                        extrinsic?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);

                        /** AuthData portfolio */
                        portfolio?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);
                    }

                    /** Represents an AuthData. */
                    class AuthData implements IAuthData {

                        /**
                         * Constructs a new AuthData.
                         * @param [properties] Properties to set
                         */
                        constructor(properties?: TW.Polkadot.Proto.Identity.AddAuthorization.IAuthData);

                        /** AuthData asset. */
                        public asset?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);

                        /** AuthData extrinsic. */
                        public extrinsic?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);

                        /** AuthData portfolio. */
                        public portfolio?: (TW.Polkadot.Proto.Identity.AddAuthorization.IData|null);

                        /**
                         * Creates a new AuthData instance using the specified properties.
                         * @param [properties] Properties to set
                         * @returns AuthData instance
                         */
                        public static create(properties?: TW.Polkadot.Proto.Identity.AddAuthorization.IAuthData): TW.Polkadot.Proto.Identity.AddAuthorization.AuthData;

                        /**
                         * Encodes the specified AuthData message. Does not implicitly {@link TW.Polkadot.Proto.Identity.AddAuthorization.AuthData.verify|verify} messages.
                         * @param message AuthData message or plain object to encode
                         * @param [writer] Writer to encode to
                         * @returns Writer
                         */
                        public static encode(message: TW.Polkadot.Proto.Identity.AddAuthorization.IAuthData, writer?: $protobuf.Writer): $protobuf.Writer;

                        /**
                         * Decodes an AuthData message from the specified reader or buffer.
                         * @param reader Reader or buffer to decode from
                         * @param [length] Message length if known beforehand
                         * @returns AuthData
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.Identity.AddAuthorization.AuthData;

                        /**
                         * Verifies an AuthData message.
                         * @param message Plain object to verify
                         * @returns `null` if valid, otherwise the reason why it is not
                         */
                        public static verify(message: { [k: string]: any }): (string|null);

                        /**
                         * Creates an AuthData message from a plain object. Also converts values to their respective internal types.
                         * @param object Plain object
                         * @returns AuthData
                         */
                        public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.Identity.AddAuthorization.AuthData;

                        /**
                         * Creates a plain object from an AuthData message. Also converts values to other types if specified.
                         * @param message AuthData
                         * @param [options] Conversion options
                         * @returns Plain object
                         */
                        public static toObject(message: TW.Polkadot.Proto.Identity.AddAuthorization.AuthData, options?: $protobuf.IConversionOptions): { [k: string]: any };

                        /**
                         * Converts this AuthData to JSON.
                         * @returns JSON object
                         */
                        public toJSON(): { [k: string]: any };
                    }
                }
            }

            /** Properties of a PolymeshCall. */
            interface IPolymeshCall {

                /** PolymeshCall identityCall */
                identityCall?: (TW.Polkadot.Proto.IIdentity|null);
            }

            /** Represents a PolymeshCall. */
            class PolymeshCall implements IPolymeshCall {

                /**
                 * Constructs a new PolymeshCall.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.IPolymeshCall);

                /** PolymeshCall identityCall. */
                public identityCall?: (TW.Polkadot.Proto.IIdentity|null);

                /** PolymeshCall messageOneof. */
                public messageOneof?: "identityCall";

                /**
                 * Creates a new PolymeshCall instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PolymeshCall instance
                 */
                public static create(properties?: TW.Polkadot.Proto.IPolymeshCall): TW.Polkadot.Proto.PolymeshCall;

                /**
                 * Encodes the specified PolymeshCall message. Does not implicitly {@link TW.Polkadot.Proto.PolymeshCall.verify|verify} messages.
                 * @param message PolymeshCall message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.IPolymeshCall, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PolymeshCall message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PolymeshCall
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.PolymeshCall;

                /**
                 * Verifies a PolymeshCall message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PolymeshCall message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PolymeshCall
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.PolymeshCall;

                /**
                 * Creates a plain object from a PolymeshCall message. Also converts values to other types if specified.
                 * @param message PolymeshCall
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.PolymeshCall, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PolymeshCall to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput blockHash */
                blockHash?: (Uint8Array|null);

                /** SigningInput genesisHash */
                genesisHash?: (Uint8Array|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput specVersion */
                specVersion?: (number|null);

                /** SigningInput transactionVersion */
                transactionVersion?: (number|null);

                /** SigningInput tip */
                tip?: (Uint8Array|null);

                /** SigningInput era */
                era?: (TW.Polkadot.Proto.IEra|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput network */
                network?: (number|null);

                /** SigningInput multiAddress */
                multiAddress?: (boolean|null);

                /** SigningInput balanceCall */
                balanceCall?: (TW.Polkadot.Proto.IBalance|null);

                /** SigningInput stakingCall */
                stakingCall?: (TW.Polkadot.Proto.IStaking|null);

                /** SigningInput polymeshCall */
                polymeshCall?: (TW.Polkadot.Proto.IPolymeshCall|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.ISigningInput);

                /** SigningInput blockHash. */
                public blockHash: Uint8Array;

                /** SigningInput genesisHash. */
                public genesisHash: Uint8Array;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput specVersion. */
                public specVersion: number;

                /** SigningInput transactionVersion. */
                public transactionVersion: number;

                /** SigningInput tip. */
                public tip: Uint8Array;

                /** SigningInput era. */
                public era?: (TW.Polkadot.Proto.IEra|null);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput network. */
                public network: number;

                /** SigningInput multiAddress. */
                public multiAddress: boolean;

                /** SigningInput balanceCall. */
                public balanceCall?: (TW.Polkadot.Proto.IBalance|null);

                /** SigningInput stakingCall. */
                public stakingCall?: (TW.Polkadot.Proto.IStaking|null);

                /** SigningInput polymeshCall. */
                public polymeshCall?: (TW.Polkadot.Proto.IPolymeshCall|null);

                /** SigningInput messageOneof. */
                public messageOneof?: ("balanceCall"|"stakingCall"|"polymeshCall");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Polkadot.Proto.ISigningInput): TW.Polkadot.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Polkadot.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Polkadot.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Polkadot.Proto.ISigningOutput): TW.Polkadot.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Polkadot.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Polkadot.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Polkadot.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Polkadot.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Polkadot.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Ripple. */
    namespace Ripple {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a CurrencyAmount. */
            interface ICurrencyAmount {

                /** CurrencyAmount currency */
                currency?: (string|null);

                /** CurrencyAmount value */
                value?: (string|null);

                /** CurrencyAmount issuer */
                issuer?: (string|null);
            }

            /** Represents a CurrencyAmount. */
            class CurrencyAmount implements ICurrencyAmount {

                /**
                 * Constructs a new CurrencyAmount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.ICurrencyAmount);

                /** CurrencyAmount currency. */
                public currency: string;

                /** CurrencyAmount value. */
                public value: string;

                /** CurrencyAmount issuer. */
                public issuer: string;

                /**
                 * Creates a new CurrencyAmount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CurrencyAmount instance
                 */
                public static create(properties?: TW.Ripple.Proto.ICurrencyAmount): TW.Ripple.Proto.CurrencyAmount;

                /**
                 * Encodes the specified CurrencyAmount message. Does not implicitly {@link TW.Ripple.Proto.CurrencyAmount.verify|verify} messages.
                 * @param message CurrencyAmount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.ICurrencyAmount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CurrencyAmount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CurrencyAmount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.CurrencyAmount;

                /**
                 * Verifies a CurrencyAmount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CurrencyAmount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CurrencyAmount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.CurrencyAmount;

                /**
                 * Creates a plain object from a CurrencyAmount message. Also converts values to other types if specified.
                 * @param message CurrencyAmount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.CurrencyAmount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CurrencyAmount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationTrustSet. */
            interface IOperationTrustSet {

                /** OperationTrustSet limitAmount */
                limitAmount?: (TW.Ripple.Proto.ICurrencyAmount|null);
            }

            /** Represents an OperationTrustSet. */
            class OperationTrustSet implements IOperationTrustSet {

                /**
                 * Constructs a new OperationTrustSet.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationTrustSet);

                /** OperationTrustSet limitAmount. */
                public limitAmount?: (TW.Ripple.Proto.ICurrencyAmount|null);

                /**
                 * Creates a new OperationTrustSet instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationTrustSet instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationTrustSet): TW.Ripple.Proto.OperationTrustSet;

                /**
                 * Encodes the specified OperationTrustSet message. Does not implicitly {@link TW.Ripple.Proto.OperationTrustSet.verify|verify} messages.
                 * @param message OperationTrustSet message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationTrustSet, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationTrustSet message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationTrustSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationTrustSet;

                /**
                 * Verifies an OperationTrustSet message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationTrustSet message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationTrustSet
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationTrustSet;

                /**
                 * Creates a plain object from an OperationTrustSet message. Also converts values to other types if specified.
                 * @param message OperationTrustSet
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationTrustSet, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationTrustSet to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationPayment. */
            interface IOperationPayment {

                /** OperationPayment amount */
                amount?: (Long|null);

                /** OperationPayment currencyAmount */
                currencyAmount?: (TW.Ripple.Proto.ICurrencyAmount|null);

                /** OperationPayment destination */
                destination?: (string|null);

                /** OperationPayment destinationTag */
                destinationTag?: (Long|null);
            }

            /** Represents an OperationPayment. */
            class OperationPayment implements IOperationPayment {

                /**
                 * Constructs a new OperationPayment.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationPayment);

                /** OperationPayment amount. */
                public amount?: (Long|null);

                /** OperationPayment currencyAmount. */
                public currencyAmount?: (TW.Ripple.Proto.ICurrencyAmount|null);

                /** OperationPayment destination. */
                public destination: string;

                /** OperationPayment destinationTag. */
                public destinationTag: Long;

                /** OperationPayment amountOneof. */
                public amountOneof?: ("amount"|"currencyAmount");

                /**
                 * Creates a new OperationPayment instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationPayment instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationPayment): TW.Ripple.Proto.OperationPayment;

                /**
                 * Encodes the specified OperationPayment message. Does not implicitly {@link TW.Ripple.Proto.OperationPayment.verify|verify} messages.
                 * @param message OperationPayment message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationPayment, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationPayment message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationPayment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationPayment;

                /**
                 * Verifies an OperationPayment message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationPayment message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationPayment
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationPayment;

                /**
                 * Creates a plain object from an OperationPayment message. Also converts values to other types if specified.
                 * @param message OperationPayment
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationPayment, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationPayment to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationNFTokenBurn. */
            interface IOperationNFTokenBurn {

                /** OperationNFTokenBurn nftokenId */
                nftokenId?: (Uint8Array|null);
            }

            /** Represents an OperationNFTokenBurn. */
            class OperationNFTokenBurn implements IOperationNFTokenBurn {

                /**
                 * Constructs a new OperationNFTokenBurn.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationNFTokenBurn);

                /** OperationNFTokenBurn nftokenId. */
                public nftokenId: Uint8Array;

                /**
                 * Creates a new OperationNFTokenBurn instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationNFTokenBurn instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationNFTokenBurn): TW.Ripple.Proto.OperationNFTokenBurn;

                /**
                 * Encodes the specified OperationNFTokenBurn message. Does not implicitly {@link TW.Ripple.Proto.OperationNFTokenBurn.verify|verify} messages.
                 * @param message OperationNFTokenBurn message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationNFTokenBurn, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationNFTokenBurn message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationNFTokenBurn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationNFTokenBurn;

                /**
                 * Verifies an OperationNFTokenBurn message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationNFTokenBurn message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationNFTokenBurn
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationNFTokenBurn;

                /**
                 * Creates a plain object from an OperationNFTokenBurn message. Also converts values to other types if specified.
                 * @param message OperationNFTokenBurn
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationNFTokenBurn, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationNFTokenBurn to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationNFTokenCreateOffer. */
            interface IOperationNFTokenCreateOffer {

                /** OperationNFTokenCreateOffer nftokenId */
                nftokenId?: (Uint8Array|null);

                /** OperationNFTokenCreateOffer destination */
                destination?: (string|null);
            }

            /** Represents an OperationNFTokenCreateOffer. */
            class OperationNFTokenCreateOffer implements IOperationNFTokenCreateOffer {

                /**
                 * Constructs a new OperationNFTokenCreateOffer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationNFTokenCreateOffer);

                /** OperationNFTokenCreateOffer nftokenId. */
                public nftokenId: Uint8Array;

                /** OperationNFTokenCreateOffer destination. */
                public destination: string;

                /**
                 * Creates a new OperationNFTokenCreateOffer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationNFTokenCreateOffer instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationNFTokenCreateOffer): TW.Ripple.Proto.OperationNFTokenCreateOffer;

                /**
                 * Encodes the specified OperationNFTokenCreateOffer message. Does not implicitly {@link TW.Ripple.Proto.OperationNFTokenCreateOffer.verify|verify} messages.
                 * @param message OperationNFTokenCreateOffer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationNFTokenCreateOffer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationNFTokenCreateOffer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationNFTokenCreateOffer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationNFTokenCreateOffer;

                /**
                 * Verifies an OperationNFTokenCreateOffer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationNFTokenCreateOffer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationNFTokenCreateOffer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationNFTokenCreateOffer;

                /**
                 * Creates a plain object from an OperationNFTokenCreateOffer message. Also converts values to other types if specified.
                 * @param message OperationNFTokenCreateOffer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationNFTokenCreateOffer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationNFTokenCreateOffer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationNFTokenAcceptOffer. */
            interface IOperationNFTokenAcceptOffer {

                /** OperationNFTokenAcceptOffer sellOffer */
                sellOffer?: (Uint8Array|null);
            }

            /** Represents an OperationNFTokenAcceptOffer. */
            class OperationNFTokenAcceptOffer implements IOperationNFTokenAcceptOffer {

                /**
                 * Constructs a new OperationNFTokenAcceptOffer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationNFTokenAcceptOffer);

                /** OperationNFTokenAcceptOffer sellOffer. */
                public sellOffer: Uint8Array;

                /**
                 * Creates a new OperationNFTokenAcceptOffer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationNFTokenAcceptOffer instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationNFTokenAcceptOffer): TW.Ripple.Proto.OperationNFTokenAcceptOffer;

                /**
                 * Encodes the specified OperationNFTokenAcceptOffer message. Does not implicitly {@link TW.Ripple.Proto.OperationNFTokenAcceptOffer.verify|verify} messages.
                 * @param message OperationNFTokenAcceptOffer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationNFTokenAcceptOffer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationNFTokenAcceptOffer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationNFTokenAcceptOffer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationNFTokenAcceptOffer;

                /**
                 * Verifies an OperationNFTokenAcceptOffer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationNFTokenAcceptOffer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationNFTokenAcceptOffer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationNFTokenAcceptOffer;

                /**
                 * Creates a plain object from an OperationNFTokenAcceptOffer message. Also converts values to other types if specified.
                 * @param message OperationNFTokenAcceptOffer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationNFTokenAcceptOffer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationNFTokenAcceptOffer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationNFTokenCancelOffer. */
            interface IOperationNFTokenCancelOffer {

                /** OperationNFTokenCancelOffer tokenOffers */
                tokenOffers?: (Uint8Array[]|null);
            }

            /** Represents an OperationNFTokenCancelOffer. */
            class OperationNFTokenCancelOffer implements IOperationNFTokenCancelOffer {

                /**
                 * Constructs a new OperationNFTokenCancelOffer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.IOperationNFTokenCancelOffer);

                /** OperationNFTokenCancelOffer tokenOffers. */
                public tokenOffers: Uint8Array[];

                /**
                 * Creates a new OperationNFTokenCancelOffer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationNFTokenCancelOffer instance
                 */
                public static create(properties?: TW.Ripple.Proto.IOperationNFTokenCancelOffer): TW.Ripple.Proto.OperationNFTokenCancelOffer;

                /**
                 * Encodes the specified OperationNFTokenCancelOffer message. Does not implicitly {@link TW.Ripple.Proto.OperationNFTokenCancelOffer.verify|verify} messages.
                 * @param message OperationNFTokenCancelOffer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.IOperationNFTokenCancelOffer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationNFTokenCancelOffer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationNFTokenCancelOffer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.OperationNFTokenCancelOffer;

                /**
                 * Verifies an OperationNFTokenCancelOffer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationNFTokenCancelOffer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationNFTokenCancelOffer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.OperationNFTokenCancelOffer;

                /**
                 * Creates a plain object from an OperationNFTokenCancelOffer message. Also converts values to other types if specified.
                 * @param message OperationNFTokenCancelOffer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.OperationNFTokenCancelOffer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationNFTokenCancelOffer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput fee */
                fee?: (Long|null);

                /** SigningInput sequence */
                sequence?: (number|null);

                /** SigningInput lastLedgerSequence */
                lastLedgerSequence?: (number|null);

                /** SigningInput account */
                account?: (string|null);

                /** SigningInput flags */
                flags?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput opTrustSet */
                opTrustSet?: (TW.Ripple.Proto.IOperationTrustSet|null);

                /** SigningInput opPayment */
                opPayment?: (TW.Ripple.Proto.IOperationPayment|null);

                /** SigningInput opNftokenBurn */
                opNftokenBurn?: (TW.Ripple.Proto.IOperationNFTokenBurn|null);

                /** SigningInput opNftokenCreateOffer */
                opNftokenCreateOffer?: (TW.Ripple.Proto.IOperationNFTokenCreateOffer|null);

                /** SigningInput opNftokenAcceptOffer */
                opNftokenAcceptOffer?: (TW.Ripple.Proto.IOperationNFTokenAcceptOffer|null);

                /** SigningInput opNftokenCancelOffer */
                opNftokenCancelOffer?: (TW.Ripple.Proto.IOperationNFTokenCancelOffer|null);

                /** SigningInput publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.ISigningInput);

                /** SigningInput fee. */
                public fee: Long;

                /** SigningInput sequence. */
                public sequence: number;

                /** SigningInput lastLedgerSequence. */
                public lastLedgerSequence: number;

                /** SigningInput account. */
                public account: string;

                /** SigningInput flags. */
                public flags: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput opTrustSet. */
                public opTrustSet?: (TW.Ripple.Proto.IOperationTrustSet|null);

                /** SigningInput opPayment. */
                public opPayment?: (TW.Ripple.Proto.IOperationPayment|null);

                /** SigningInput opNftokenBurn. */
                public opNftokenBurn?: (TW.Ripple.Proto.IOperationNFTokenBurn|null);

                /** SigningInput opNftokenCreateOffer. */
                public opNftokenCreateOffer?: (TW.Ripple.Proto.IOperationNFTokenCreateOffer|null);

                /** SigningInput opNftokenAcceptOffer. */
                public opNftokenAcceptOffer?: (TW.Ripple.Proto.IOperationNFTokenAcceptOffer|null);

                /** SigningInput opNftokenCancelOffer. */
                public opNftokenCancelOffer?: (TW.Ripple.Proto.IOperationNFTokenCancelOffer|null);

                /** SigningInput publicKey. */
                public publicKey: Uint8Array;

                /** SigningInput operationOneof. */
                public operationOneof?: ("opTrustSet"|"opPayment"|"opNftokenBurn"|"opNftokenCreateOffer"|"opNftokenAcceptOffer"|"opNftokenCancelOffer");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Ripple.Proto.ISigningInput): TW.Ripple.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ripple.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Ripple.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Ripple.Proto.ISigningOutput): TW.Ripple.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ripple.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Ripple.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Ripple.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Ripple.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Ripple.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Solana. */
    namespace Solana {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer recipient */
                recipient?: (string|null);

                /** Transfer value */
                value?: (Long|null);

                /** Transfer memo */
                memo?: (string|null);

                /** Transfer references */
                references?: (string[]|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ITransfer);

                /** Transfer recipient. */
                public recipient: string;

                /** Transfer value. */
                public value: Long;

                /** Transfer memo. */
                public memo: string;

                /** Transfer references. */
                public references: string[];

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.Solana.Proto.ITransfer): TW.Solana.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.Solana.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DelegateStake. */
            interface IDelegateStake {

                /** DelegateStake validatorPubkey */
                validatorPubkey?: (string|null);

                /** DelegateStake value */
                value?: (Long|null);

                /** DelegateStake stakeAccount */
                stakeAccount?: (string|null);
            }

            /** Represents a DelegateStake. */
            class DelegateStake implements IDelegateStake {

                /**
                 * Constructs a new DelegateStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IDelegateStake);

                /** DelegateStake validatorPubkey. */
                public validatorPubkey: string;

                /** DelegateStake value. */
                public value: Long;

                /** DelegateStake stakeAccount. */
                public stakeAccount: string;

                /**
                 * Creates a new DelegateStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DelegateStake instance
                 */
                public static create(properties?: TW.Solana.Proto.IDelegateStake): TW.Solana.Proto.DelegateStake;

                /**
                 * Encodes the specified DelegateStake message. Does not implicitly {@link TW.Solana.Proto.DelegateStake.verify|verify} messages.
                 * @param message DelegateStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IDelegateStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DelegateStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DelegateStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.DelegateStake;

                /**
                 * Verifies a DelegateStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DelegateStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DelegateStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.DelegateStake;

                /**
                 * Creates a plain object from a DelegateStake message. Also converts values to other types if specified.
                 * @param message DelegateStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.DelegateStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DelegateStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeactivateStake. */
            interface IDeactivateStake {

                /** DeactivateStake stakeAccount */
                stakeAccount?: (string|null);
            }

            /** Represents a DeactivateStake. */
            class DeactivateStake implements IDeactivateStake {

                /**
                 * Constructs a new DeactivateStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IDeactivateStake);

                /** DeactivateStake stakeAccount. */
                public stakeAccount: string;

                /**
                 * Creates a new DeactivateStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeactivateStake instance
                 */
                public static create(properties?: TW.Solana.Proto.IDeactivateStake): TW.Solana.Proto.DeactivateStake;

                /**
                 * Encodes the specified DeactivateStake message. Does not implicitly {@link TW.Solana.Proto.DeactivateStake.verify|verify} messages.
                 * @param message DeactivateStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IDeactivateStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeactivateStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeactivateStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.DeactivateStake;

                /**
                 * Verifies a DeactivateStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeactivateStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeactivateStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.DeactivateStake;

                /**
                 * Creates a plain object from a DeactivateStake message. Also converts values to other types if specified.
                 * @param message DeactivateStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.DeactivateStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeactivateStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DeactivateAllStake. */
            interface IDeactivateAllStake {

                /** DeactivateAllStake stakeAccounts */
                stakeAccounts?: (string[]|null);
            }

            /** Represents a DeactivateAllStake. */
            class DeactivateAllStake implements IDeactivateAllStake {

                /**
                 * Constructs a new DeactivateAllStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IDeactivateAllStake);

                /** DeactivateAllStake stakeAccounts. */
                public stakeAccounts: string[];

                /**
                 * Creates a new DeactivateAllStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DeactivateAllStake instance
                 */
                public static create(properties?: TW.Solana.Proto.IDeactivateAllStake): TW.Solana.Proto.DeactivateAllStake;

                /**
                 * Encodes the specified DeactivateAllStake message. Does not implicitly {@link TW.Solana.Proto.DeactivateAllStake.verify|verify} messages.
                 * @param message DeactivateAllStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IDeactivateAllStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DeactivateAllStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DeactivateAllStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.DeactivateAllStake;

                /**
                 * Verifies a DeactivateAllStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DeactivateAllStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DeactivateAllStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.DeactivateAllStake;

                /**
                 * Creates a plain object from a DeactivateAllStake message. Also converts values to other types if specified.
                 * @param message DeactivateAllStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.DeactivateAllStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DeactivateAllStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a WithdrawStake. */
            interface IWithdrawStake {

                /** WithdrawStake stakeAccount */
                stakeAccount?: (string|null);

                /** WithdrawStake value */
                value?: (Long|null);
            }

            /** Represents a WithdrawStake. */
            class WithdrawStake implements IWithdrawStake {

                /**
                 * Constructs a new WithdrawStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IWithdrawStake);

                /** WithdrawStake stakeAccount. */
                public stakeAccount: string;

                /** WithdrawStake value. */
                public value: Long;

                /**
                 * Creates a new WithdrawStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns WithdrawStake instance
                 */
                public static create(properties?: TW.Solana.Proto.IWithdrawStake): TW.Solana.Proto.WithdrawStake;

                /**
                 * Encodes the specified WithdrawStake message. Does not implicitly {@link TW.Solana.Proto.WithdrawStake.verify|verify} messages.
                 * @param message WithdrawStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IWithdrawStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WithdrawStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns WithdrawStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.WithdrawStake;

                /**
                 * Verifies a WithdrawStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WithdrawStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns WithdrawStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.WithdrawStake;

                /**
                 * Creates a plain object from a WithdrawStake message. Also converts values to other types if specified.
                 * @param message WithdrawStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.WithdrawStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this WithdrawStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a StakeAccountValue. */
            interface IStakeAccountValue {

                /** StakeAccountValue stakeAccount */
                stakeAccount?: (string|null);

                /** StakeAccountValue value */
                value?: (Long|null);
            }

            /** Represents a StakeAccountValue. */
            class StakeAccountValue implements IStakeAccountValue {

                /**
                 * Constructs a new StakeAccountValue.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IStakeAccountValue);

                /** StakeAccountValue stakeAccount. */
                public stakeAccount: string;

                /** StakeAccountValue value. */
                public value: Long;

                /**
                 * Creates a new StakeAccountValue instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StakeAccountValue instance
                 */
                public static create(properties?: TW.Solana.Proto.IStakeAccountValue): TW.Solana.Proto.StakeAccountValue;

                /**
                 * Encodes the specified StakeAccountValue message. Does not implicitly {@link TW.Solana.Proto.StakeAccountValue.verify|verify} messages.
                 * @param message StakeAccountValue message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IStakeAccountValue, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StakeAccountValue message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns StakeAccountValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.StakeAccountValue;

                /**
                 * Verifies a StakeAccountValue message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a StakeAccountValue message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns StakeAccountValue
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.StakeAccountValue;

                /**
                 * Creates a plain object from a StakeAccountValue message. Also converts values to other types if specified.
                 * @param message StakeAccountValue
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.StakeAccountValue, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this StakeAccountValue to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a WithdrawAllStake. */
            interface IWithdrawAllStake {

                /** WithdrawAllStake stakeAccounts */
                stakeAccounts?: (TW.Solana.Proto.IStakeAccountValue[]|null);
            }

            /** Represents a WithdrawAllStake. */
            class WithdrawAllStake implements IWithdrawAllStake {

                /**
                 * Constructs a new WithdrawAllStake.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IWithdrawAllStake);

                /** WithdrawAllStake stakeAccounts. */
                public stakeAccounts: TW.Solana.Proto.IStakeAccountValue[];

                /**
                 * Creates a new WithdrawAllStake instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns WithdrawAllStake instance
                 */
                public static create(properties?: TW.Solana.Proto.IWithdrawAllStake): TW.Solana.Proto.WithdrawAllStake;

                /**
                 * Encodes the specified WithdrawAllStake message. Does not implicitly {@link TW.Solana.Proto.WithdrawAllStake.verify|verify} messages.
                 * @param message WithdrawAllStake message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IWithdrawAllStake, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WithdrawAllStake message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns WithdrawAllStake
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.WithdrawAllStake;

                /**
                 * Verifies a WithdrawAllStake message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WithdrawAllStake message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns WithdrawAllStake
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.WithdrawAllStake;

                /**
                 * Creates a plain object from a WithdrawAllStake message. Also converts values to other types if specified.
                 * @param message WithdrawAllStake
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.WithdrawAllStake, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this WithdrawAllStake to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CreateTokenAccount. */
            interface ICreateTokenAccount {

                /** CreateTokenAccount mainAddress */
                mainAddress?: (string|null);

                /** CreateTokenAccount tokenMintAddress */
                tokenMintAddress?: (string|null);

                /** CreateTokenAccount tokenAddress */
                tokenAddress?: (string|null);
            }

            /** Represents a CreateTokenAccount. */
            class CreateTokenAccount implements ICreateTokenAccount {

                /**
                 * Constructs a new CreateTokenAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ICreateTokenAccount);

                /** CreateTokenAccount mainAddress. */
                public mainAddress: string;

                /** CreateTokenAccount tokenMintAddress. */
                public tokenMintAddress: string;

                /** CreateTokenAccount tokenAddress. */
                public tokenAddress: string;

                /**
                 * Creates a new CreateTokenAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CreateTokenAccount instance
                 */
                public static create(properties?: TW.Solana.Proto.ICreateTokenAccount): TW.Solana.Proto.CreateTokenAccount;

                /**
                 * Encodes the specified CreateTokenAccount message. Does not implicitly {@link TW.Solana.Proto.CreateTokenAccount.verify|verify} messages.
                 * @param message CreateTokenAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ICreateTokenAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CreateTokenAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CreateTokenAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.CreateTokenAccount;

                /**
                 * Verifies a CreateTokenAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CreateTokenAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CreateTokenAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.CreateTokenAccount;

                /**
                 * Creates a plain object from a CreateTokenAccount message. Also converts values to other types if specified.
                 * @param message CreateTokenAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.CreateTokenAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CreateTokenAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TokenTransfer. */
            interface ITokenTransfer {

                /** TokenTransfer tokenMintAddress */
                tokenMintAddress?: (string|null);

                /** TokenTransfer senderTokenAddress */
                senderTokenAddress?: (string|null);

                /** TokenTransfer recipientTokenAddress */
                recipientTokenAddress?: (string|null);

                /** TokenTransfer amount */
                amount?: (Long|null);

                /** TokenTransfer decimals */
                decimals?: (number|null);

                /** TokenTransfer memo */
                memo?: (string|null);

                /** TokenTransfer references */
                references?: (string[]|null);
            }

            /** Represents a TokenTransfer. */
            class TokenTransfer implements ITokenTransfer {

                /**
                 * Constructs a new TokenTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ITokenTransfer);

                /** TokenTransfer tokenMintAddress. */
                public tokenMintAddress: string;

                /** TokenTransfer senderTokenAddress. */
                public senderTokenAddress: string;

                /** TokenTransfer recipientTokenAddress. */
                public recipientTokenAddress: string;

                /** TokenTransfer amount. */
                public amount: Long;

                /** TokenTransfer decimals. */
                public decimals: number;

                /** TokenTransfer memo. */
                public memo: string;

                /** TokenTransfer references. */
                public references: string[];

                /**
                 * Creates a new TokenTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TokenTransfer instance
                 */
                public static create(properties?: TW.Solana.Proto.ITokenTransfer): TW.Solana.Proto.TokenTransfer;

                /**
                 * Encodes the specified TokenTransfer message. Does not implicitly {@link TW.Solana.Proto.TokenTransfer.verify|verify} messages.
                 * @param message TokenTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ITokenTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TokenTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TokenTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.TokenTransfer;

                /**
                 * Verifies a TokenTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TokenTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TokenTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.TokenTransfer;

                /**
                 * Creates a plain object from a TokenTransfer message. Also converts values to other types if specified.
                 * @param message TokenTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.TokenTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TokenTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CreateAndTransferToken. */
            interface ICreateAndTransferToken {

                /** CreateAndTransferToken recipientMainAddress */
                recipientMainAddress?: (string|null);

                /** CreateAndTransferToken tokenMintAddress */
                tokenMintAddress?: (string|null);

                /** CreateAndTransferToken recipientTokenAddress */
                recipientTokenAddress?: (string|null);

                /** CreateAndTransferToken senderTokenAddress */
                senderTokenAddress?: (string|null);

                /** CreateAndTransferToken amount */
                amount?: (Long|null);

                /** CreateAndTransferToken decimals */
                decimals?: (number|null);

                /** CreateAndTransferToken memo */
                memo?: (string|null);

                /** CreateAndTransferToken references */
                references?: (string[]|null);
            }

            /** Represents a CreateAndTransferToken. */
            class CreateAndTransferToken implements ICreateAndTransferToken {

                /**
                 * Constructs a new CreateAndTransferToken.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ICreateAndTransferToken);

                /** CreateAndTransferToken recipientMainAddress. */
                public recipientMainAddress: string;

                /** CreateAndTransferToken tokenMintAddress. */
                public tokenMintAddress: string;

                /** CreateAndTransferToken recipientTokenAddress. */
                public recipientTokenAddress: string;

                /** CreateAndTransferToken senderTokenAddress. */
                public senderTokenAddress: string;

                /** CreateAndTransferToken amount. */
                public amount: Long;

                /** CreateAndTransferToken decimals. */
                public decimals: number;

                /** CreateAndTransferToken memo. */
                public memo: string;

                /** CreateAndTransferToken references. */
                public references: string[];

                /**
                 * Creates a new CreateAndTransferToken instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CreateAndTransferToken instance
                 */
                public static create(properties?: TW.Solana.Proto.ICreateAndTransferToken): TW.Solana.Proto.CreateAndTransferToken;

                /**
                 * Encodes the specified CreateAndTransferToken message. Does not implicitly {@link TW.Solana.Proto.CreateAndTransferToken.verify|verify} messages.
                 * @param message CreateAndTransferToken message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ICreateAndTransferToken, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CreateAndTransferToken message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CreateAndTransferToken
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.CreateAndTransferToken;

                /**
                 * Verifies a CreateAndTransferToken message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CreateAndTransferToken message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CreateAndTransferToken
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.CreateAndTransferToken;

                /**
                 * Creates a plain object from a CreateAndTransferToken message. Also converts values to other types if specified.
                 * @param message CreateAndTransferToken
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.CreateAndTransferToken, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CreateAndTransferToken to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CreateNonceAccount. */
            interface ICreateNonceAccount {

                /** CreateNonceAccount nonceAccount */
                nonceAccount?: (string|null);

                /** CreateNonceAccount rent */
                rent?: (Long|null);

                /** CreateNonceAccount nonceAccountPrivateKey */
                nonceAccountPrivateKey?: (Uint8Array|null);
            }

            /** Represents a CreateNonceAccount. */
            class CreateNonceAccount implements ICreateNonceAccount {

                /**
                 * Constructs a new CreateNonceAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ICreateNonceAccount);

                /** CreateNonceAccount nonceAccount. */
                public nonceAccount: string;

                /** CreateNonceAccount rent. */
                public rent: Long;

                /** CreateNonceAccount nonceAccountPrivateKey. */
                public nonceAccountPrivateKey: Uint8Array;

                /**
                 * Creates a new CreateNonceAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CreateNonceAccount instance
                 */
                public static create(properties?: TW.Solana.Proto.ICreateNonceAccount): TW.Solana.Proto.CreateNonceAccount;

                /**
                 * Encodes the specified CreateNonceAccount message. Does not implicitly {@link TW.Solana.Proto.CreateNonceAccount.verify|verify} messages.
                 * @param message CreateNonceAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ICreateNonceAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CreateNonceAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CreateNonceAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.CreateNonceAccount;

                /**
                 * Verifies a CreateNonceAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CreateNonceAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CreateNonceAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.CreateNonceAccount;

                /**
                 * Creates a plain object from a CreateNonceAccount message. Also converts values to other types if specified.
                 * @param message CreateNonceAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.CreateNonceAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CreateNonceAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a WithdrawNonceAccount. */
            interface IWithdrawNonceAccount {

                /** WithdrawNonceAccount nonceAccount */
                nonceAccount?: (string|null);

                /** WithdrawNonceAccount recipient */
                recipient?: (string|null);

                /** WithdrawNonceAccount value */
                value?: (Long|null);
            }

            /** Represents a WithdrawNonceAccount. */
            class WithdrawNonceAccount implements IWithdrawNonceAccount {

                /**
                 * Constructs a new WithdrawNonceAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IWithdrawNonceAccount);

                /** WithdrawNonceAccount nonceAccount. */
                public nonceAccount: string;

                /** WithdrawNonceAccount recipient. */
                public recipient: string;

                /** WithdrawNonceAccount value. */
                public value: Long;

                /**
                 * Creates a new WithdrawNonceAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns WithdrawNonceAccount instance
                 */
                public static create(properties?: TW.Solana.Proto.IWithdrawNonceAccount): TW.Solana.Proto.WithdrawNonceAccount;

                /**
                 * Encodes the specified WithdrawNonceAccount message. Does not implicitly {@link TW.Solana.Proto.WithdrawNonceAccount.verify|verify} messages.
                 * @param message WithdrawNonceAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IWithdrawNonceAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WithdrawNonceAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns WithdrawNonceAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.WithdrawNonceAccount;

                /**
                 * Verifies a WithdrawNonceAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WithdrawNonceAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns WithdrawNonceAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.WithdrawNonceAccount;

                /**
                 * Creates a plain object from a WithdrawNonceAccount message. Also converts values to other types if specified.
                 * @param message WithdrawNonceAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.WithdrawNonceAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this WithdrawNonceAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an AdvanceNonceAccount. */
            interface IAdvanceNonceAccount {

                /** AdvanceNonceAccount nonceAccount */
                nonceAccount?: (string|null);
            }

            /** Represents an AdvanceNonceAccount. */
            class AdvanceNonceAccount implements IAdvanceNonceAccount {

                /**
                 * Constructs a new AdvanceNonceAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IAdvanceNonceAccount);

                /** AdvanceNonceAccount nonceAccount. */
                public nonceAccount: string;

                /**
                 * Creates a new AdvanceNonceAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns AdvanceNonceAccount instance
                 */
                public static create(properties?: TW.Solana.Proto.IAdvanceNonceAccount): TW.Solana.Proto.AdvanceNonceAccount;

                /**
                 * Encodes the specified AdvanceNonceAccount message. Does not implicitly {@link TW.Solana.Proto.AdvanceNonceAccount.verify|verify} messages.
                 * @param message AdvanceNonceAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IAdvanceNonceAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an AdvanceNonceAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns AdvanceNonceAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.AdvanceNonceAccount;

                /**
                 * Verifies an AdvanceNonceAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an AdvanceNonceAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns AdvanceNonceAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.AdvanceNonceAccount;

                /**
                 * Creates a plain object from an AdvanceNonceAccount message. Also converts values to other types if specified.
                 * @param message AdvanceNonceAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.AdvanceNonceAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this AdvanceNonceAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput recentBlockhash */
                recentBlockhash?: (string|null);

                /** SigningInput v0Msg */
                v0Msg?: (boolean|null);

                /** SigningInput transferTransaction */
                transferTransaction?: (TW.Solana.Proto.ITransfer|null);

                /** SigningInput delegateStakeTransaction */
                delegateStakeTransaction?: (TW.Solana.Proto.IDelegateStake|null);

                /** SigningInput deactivateStakeTransaction */
                deactivateStakeTransaction?: (TW.Solana.Proto.IDeactivateStake|null);

                /** SigningInput deactivateAllStakeTransaction */
                deactivateAllStakeTransaction?: (TW.Solana.Proto.IDeactivateAllStake|null);

                /** SigningInput withdrawTransaction */
                withdrawTransaction?: (TW.Solana.Proto.IWithdrawStake|null);

                /** SigningInput withdrawAllTransaction */
                withdrawAllTransaction?: (TW.Solana.Proto.IWithdrawAllStake|null);

                /** SigningInput createTokenAccountTransaction */
                createTokenAccountTransaction?: (TW.Solana.Proto.ICreateTokenAccount|null);

                /** SigningInput tokenTransferTransaction */
                tokenTransferTransaction?: (TW.Solana.Proto.ITokenTransfer|null);

                /** SigningInput createAndTransferTokenTransaction */
                createAndTransferTokenTransaction?: (TW.Solana.Proto.ICreateAndTransferToken|null);

                /** SigningInput createNonceAccount */
                createNonceAccount?: (TW.Solana.Proto.ICreateNonceAccount|null);

                /** SigningInput withdrawNonceAccount */
                withdrawNonceAccount?: (TW.Solana.Proto.IWithdrawNonceAccount|null);

                /** SigningInput advanceNonceAccount */
                advanceNonceAccount?: (TW.Solana.Proto.IAdvanceNonceAccount|null);

                /** SigningInput sender */
                sender?: (string|null);

                /** SigningInput nonceAccount */
                nonceAccount?: (string|null);

                /** SigningInput feePayerPrivateKey */
                feePayerPrivateKey?: (Uint8Array|null);

                /** SigningInput feePayer */
                feePayer?: (string|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput recentBlockhash. */
                public recentBlockhash: string;

                /** SigningInput v0Msg. */
                public v0Msg: boolean;

                /** SigningInput transferTransaction. */
                public transferTransaction?: (TW.Solana.Proto.ITransfer|null);

                /** SigningInput delegateStakeTransaction. */
                public delegateStakeTransaction?: (TW.Solana.Proto.IDelegateStake|null);

                /** SigningInput deactivateStakeTransaction. */
                public deactivateStakeTransaction?: (TW.Solana.Proto.IDeactivateStake|null);

                /** SigningInput deactivateAllStakeTransaction. */
                public deactivateAllStakeTransaction?: (TW.Solana.Proto.IDeactivateAllStake|null);

                /** SigningInput withdrawTransaction. */
                public withdrawTransaction?: (TW.Solana.Proto.IWithdrawStake|null);

                /** SigningInput withdrawAllTransaction. */
                public withdrawAllTransaction?: (TW.Solana.Proto.IWithdrawAllStake|null);

                /** SigningInput createTokenAccountTransaction. */
                public createTokenAccountTransaction?: (TW.Solana.Proto.ICreateTokenAccount|null);

                /** SigningInput tokenTransferTransaction. */
                public tokenTransferTransaction?: (TW.Solana.Proto.ITokenTransfer|null);

                /** SigningInput createAndTransferTokenTransaction. */
                public createAndTransferTokenTransaction?: (TW.Solana.Proto.ICreateAndTransferToken|null);

                /** SigningInput createNonceAccount. */
                public createNonceAccount?: (TW.Solana.Proto.ICreateNonceAccount|null);

                /** SigningInput withdrawNonceAccount. */
                public withdrawNonceAccount?: (TW.Solana.Proto.IWithdrawNonceAccount|null);

                /** SigningInput advanceNonceAccount. */
                public advanceNonceAccount?: (TW.Solana.Proto.IAdvanceNonceAccount|null);

                /** SigningInput sender. */
                public sender: string;

                /** SigningInput nonceAccount. */
                public nonceAccount: string;

                /** SigningInput feePayerPrivateKey. */
                public feePayerPrivateKey: Uint8Array;

                /** SigningInput feePayer. */
                public feePayer: string;

                /** SigningInput transactionType. */
                public transactionType?: ("transferTransaction"|"delegateStakeTransaction"|"deactivateStakeTransaction"|"deactivateAllStakeTransaction"|"withdrawTransaction"|"withdrawAllTransaction"|"createTokenAccountTransaction"|"tokenTransferTransaction"|"createAndTransferTokenTransaction"|"createNonceAccount"|"withdrawNonceAccount"|"advanceNonceAccount");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Solana.Proto.ISigningInput): TW.Solana.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Solana.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);

                /** SigningOutput unsignedTx */
                unsignedTx?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /** SigningOutput unsignedTx. */
                public unsignedTx: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Solana.Proto.ISigningOutput): TW.Solana.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Solana.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a PreSigningOutput. */
            interface IPreSigningOutput {

                /** Signer list */
                signers?: (Uint8Array[]|null);

                /** Pre-image data. There is no hashing for Solana presign image */
                data?: (Uint8Array|null);

                /** PreSigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** PreSigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Transaction pre-signing output */
            class PreSigningOutput implements IPreSigningOutput {

                /**
                 * Constructs a new PreSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Solana.Proto.IPreSigningOutput);

                /** Signer list */
                public signers: Uint8Array[];

                /** Pre-image data. There is no hashing for Solana presign image */
                public data: Uint8Array;

                /** PreSigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** PreSigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new PreSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSigningOutput instance
                 */
                public static create(properties?: TW.Solana.Proto.IPreSigningOutput): TW.Solana.Proto.PreSigningOutput;

                /**
                 * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.Solana.Proto.PreSigningOutput.verify|verify} messages.
                 * @param message PreSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Solana.Proto.IPreSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Solana.Proto.PreSigningOutput;

                /**
                 * Verifies a PreSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Solana.Proto.PreSigningOutput;

                /**
                 * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                 * @param message PreSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Solana.Proto.PreSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Stellar. */
    namespace Stellar {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of an Asset. */
            interface IAsset {

                /** Asset issuer */
                issuer?: (string|null);

                /** Asset alphanum4 */
                alphanum4?: (string|null);
            }

            /** Represents an Asset. */
            class Asset implements IAsset {

                /**
                 * Constructs a new Asset.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IAsset);

                /** Asset issuer. */
                public issuer: string;

                /** Asset alphanum4. */
                public alphanum4: string;

                /**
                 * Creates a new Asset instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Asset instance
                 */
                public static create(properties?: TW.Stellar.Proto.IAsset): TW.Stellar.Proto.Asset;

                /**
                 * Encodes the specified Asset message. Does not implicitly {@link TW.Stellar.Proto.Asset.verify|verify} messages.
                 * @param message Asset message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IAsset, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Asset message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Asset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.Asset;

                /**
                 * Verifies an Asset message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Asset
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.Asset;

                /**
                 * Creates a plain object from an Asset message. Also converts values to other types if specified.
                 * @param message Asset
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.Asset, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Asset to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationCreateAccount. */
            interface IOperationCreateAccount {

                /** OperationCreateAccount destination */
                destination?: (string|null);

                /** OperationCreateAccount amount */
                amount?: (Long|null);
            }

            /** Represents an OperationCreateAccount. */
            class OperationCreateAccount implements IOperationCreateAccount {

                /**
                 * Constructs a new OperationCreateAccount.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IOperationCreateAccount);

                /** OperationCreateAccount destination. */
                public destination: string;

                /** OperationCreateAccount amount. */
                public amount: Long;

                /**
                 * Creates a new OperationCreateAccount instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationCreateAccount instance
                 */
                public static create(properties?: TW.Stellar.Proto.IOperationCreateAccount): TW.Stellar.Proto.OperationCreateAccount;

                /**
                 * Encodes the specified OperationCreateAccount message. Does not implicitly {@link TW.Stellar.Proto.OperationCreateAccount.verify|verify} messages.
                 * @param message OperationCreateAccount message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IOperationCreateAccount, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationCreateAccount message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationCreateAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.OperationCreateAccount;

                /**
                 * Verifies an OperationCreateAccount message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationCreateAccount message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationCreateAccount
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.OperationCreateAccount;

                /**
                 * Creates a plain object from an OperationCreateAccount message. Also converts values to other types if specified.
                 * @param message OperationCreateAccount
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.OperationCreateAccount, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationCreateAccount to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationPayment. */
            interface IOperationPayment {

                /** OperationPayment destination */
                destination?: (string|null);

                /** OperationPayment asset */
                asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationPayment amount */
                amount?: (Long|null);
            }

            /** Represents an OperationPayment. */
            class OperationPayment implements IOperationPayment {

                /**
                 * Constructs a new OperationPayment.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IOperationPayment);

                /** OperationPayment destination. */
                public destination: string;

                /** OperationPayment asset. */
                public asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationPayment amount. */
                public amount: Long;

                /**
                 * Creates a new OperationPayment instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationPayment instance
                 */
                public static create(properties?: TW.Stellar.Proto.IOperationPayment): TW.Stellar.Proto.OperationPayment;

                /**
                 * Encodes the specified OperationPayment message. Does not implicitly {@link TW.Stellar.Proto.OperationPayment.verify|verify} messages.
                 * @param message OperationPayment message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IOperationPayment, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationPayment message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationPayment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.OperationPayment;

                /**
                 * Verifies an OperationPayment message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationPayment message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationPayment
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.OperationPayment;

                /**
                 * Creates a plain object from an OperationPayment message. Also converts values to other types if specified.
                 * @param message OperationPayment
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.OperationPayment, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationPayment to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationChangeTrust. */
            interface IOperationChangeTrust {

                /** OperationChangeTrust asset */
                asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationChangeTrust validBefore */
                validBefore?: (Long|null);
            }

            /** Represents an OperationChangeTrust. */
            class OperationChangeTrust implements IOperationChangeTrust {

                /**
                 * Constructs a new OperationChangeTrust.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IOperationChangeTrust);

                /** OperationChangeTrust asset. */
                public asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationChangeTrust validBefore. */
                public validBefore: Long;

                /**
                 * Creates a new OperationChangeTrust instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationChangeTrust instance
                 */
                public static create(properties?: TW.Stellar.Proto.IOperationChangeTrust): TW.Stellar.Proto.OperationChangeTrust;

                /**
                 * Encodes the specified OperationChangeTrust message. Does not implicitly {@link TW.Stellar.Proto.OperationChangeTrust.verify|verify} messages.
                 * @param message OperationChangeTrust message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IOperationChangeTrust, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationChangeTrust message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationChangeTrust
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.OperationChangeTrust;

                /**
                 * Verifies an OperationChangeTrust message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationChangeTrust message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationChangeTrust
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.OperationChangeTrust;

                /**
                 * Creates a plain object from an OperationChangeTrust message. Also converts values to other types if specified.
                 * @param message OperationChangeTrust
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.OperationChangeTrust, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationChangeTrust to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** ClaimPredicate enum. */
            enum ClaimPredicate {
                Predicate_unconditional = 0
            }

            /** Properties of a Claimant. */
            interface IClaimant {

                /** Claimant account */
                account?: (string|null);

                /** Claimant predicate */
                predicate?: (TW.Stellar.Proto.ClaimPredicate|null);
            }

            /** Represents a Claimant. */
            class Claimant implements IClaimant {

                /**
                 * Constructs a new Claimant.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IClaimant);

                /** Claimant account. */
                public account: string;

                /** Claimant predicate. */
                public predicate: TW.Stellar.Proto.ClaimPredicate;

                /**
                 * Creates a new Claimant instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Claimant instance
                 */
                public static create(properties?: TW.Stellar.Proto.IClaimant): TW.Stellar.Proto.Claimant;

                /**
                 * Encodes the specified Claimant message. Does not implicitly {@link TW.Stellar.Proto.Claimant.verify|verify} messages.
                 * @param message Claimant message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IClaimant, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Claimant message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Claimant
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.Claimant;

                /**
                 * Verifies a Claimant message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Claimant message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Claimant
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.Claimant;

                /**
                 * Creates a plain object from a Claimant message. Also converts values to other types if specified.
                 * @param message Claimant
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.Claimant, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Claimant to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationCreateClaimableBalance. */
            interface IOperationCreateClaimableBalance {

                /** OperationCreateClaimableBalance asset */
                asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationCreateClaimableBalance amount */
                amount?: (Long|null);

                /** OperationCreateClaimableBalance claimants */
                claimants?: (TW.Stellar.Proto.IClaimant[]|null);
            }

            /** Represents an OperationCreateClaimableBalance. */
            class OperationCreateClaimableBalance implements IOperationCreateClaimableBalance {

                /**
                 * Constructs a new OperationCreateClaimableBalance.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IOperationCreateClaimableBalance);

                /** OperationCreateClaimableBalance asset. */
                public asset?: (TW.Stellar.Proto.IAsset|null);

                /** OperationCreateClaimableBalance amount. */
                public amount: Long;

                /** OperationCreateClaimableBalance claimants. */
                public claimants: TW.Stellar.Proto.IClaimant[];

                /**
                 * Creates a new OperationCreateClaimableBalance instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationCreateClaimableBalance instance
                 */
                public static create(properties?: TW.Stellar.Proto.IOperationCreateClaimableBalance): TW.Stellar.Proto.OperationCreateClaimableBalance;

                /**
                 * Encodes the specified OperationCreateClaimableBalance message. Does not implicitly {@link TW.Stellar.Proto.OperationCreateClaimableBalance.verify|verify} messages.
                 * @param message OperationCreateClaimableBalance message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IOperationCreateClaimableBalance, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationCreateClaimableBalance message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationCreateClaimableBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.OperationCreateClaimableBalance;

                /**
                 * Verifies an OperationCreateClaimableBalance message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationCreateClaimableBalance message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationCreateClaimableBalance
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.OperationCreateClaimableBalance;

                /**
                 * Creates a plain object from an OperationCreateClaimableBalance message. Also converts values to other types if specified.
                 * @param message OperationCreateClaimableBalance
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.OperationCreateClaimableBalance, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationCreateClaimableBalance to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationClaimClaimableBalance. */
            interface IOperationClaimClaimableBalance {

                /** OperationClaimClaimableBalance balanceId */
                balanceId?: (Uint8Array|null);
            }

            /** Represents an OperationClaimClaimableBalance. */
            class OperationClaimClaimableBalance implements IOperationClaimClaimableBalance {

                /**
                 * Constructs a new OperationClaimClaimableBalance.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IOperationClaimClaimableBalance);

                /** OperationClaimClaimableBalance balanceId. */
                public balanceId: Uint8Array;

                /**
                 * Creates a new OperationClaimClaimableBalance instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationClaimClaimableBalance instance
                 */
                public static create(properties?: TW.Stellar.Proto.IOperationClaimClaimableBalance): TW.Stellar.Proto.OperationClaimClaimableBalance;

                /**
                 * Encodes the specified OperationClaimClaimableBalance message. Does not implicitly {@link TW.Stellar.Proto.OperationClaimClaimableBalance.verify|verify} messages.
                 * @param message OperationClaimClaimableBalance message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IOperationClaimClaimableBalance, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationClaimClaimableBalance message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationClaimClaimableBalance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.OperationClaimClaimableBalance;

                /**
                 * Verifies an OperationClaimClaimableBalance message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationClaimClaimableBalance message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationClaimClaimableBalance
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.OperationClaimClaimableBalance;

                /**
                 * Creates a plain object from an OperationClaimClaimableBalance message. Also converts values to other types if specified.
                 * @param message OperationClaimClaimableBalance
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.OperationClaimClaimableBalance, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationClaimClaimableBalance to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MemoVoid. */
            interface IMemoVoid {
            }

            /** Represents a MemoVoid. */
            class MemoVoid implements IMemoVoid {

                /**
                 * Constructs a new MemoVoid.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IMemoVoid);

                /**
                 * Creates a new MemoVoid instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MemoVoid instance
                 */
                public static create(properties?: TW.Stellar.Proto.IMemoVoid): TW.Stellar.Proto.MemoVoid;

                /**
                 * Encodes the specified MemoVoid message. Does not implicitly {@link TW.Stellar.Proto.MemoVoid.verify|verify} messages.
                 * @param message MemoVoid message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IMemoVoid, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MemoVoid message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MemoVoid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.MemoVoid;

                /**
                 * Verifies a MemoVoid message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MemoVoid message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MemoVoid
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.MemoVoid;

                /**
                 * Creates a plain object from a MemoVoid message. Also converts values to other types if specified.
                 * @param message MemoVoid
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.MemoVoid, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MemoVoid to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MemoText. */
            interface IMemoText {

                /** MemoText text */
                text?: (string|null);
            }

            /** Represents a MemoText. */
            class MemoText implements IMemoText {

                /**
                 * Constructs a new MemoText.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IMemoText);

                /** MemoText text. */
                public text: string;

                /**
                 * Creates a new MemoText instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MemoText instance
                 */
                public static create(properties?: TW.Stellar.Proto.IMemoText): TW.Stellar.Proto.MemoText;

                /**
                 * Encodes the specified MemoText message. Does not implicitly {@link TW.Stellar.Proto.MemoText.verify|verify} messages.
                 * @param message MemoText message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IMemoText, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MemoText message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MemoText
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.MemoText;

                /**
                 * Verifies a MemoText message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MemoText message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MemoText
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.MemoText;

                /**
                 * Creates a plain object from a MemoText message. Also converts values to other types if specified.
                 * @param message MemoText
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.MemoText, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MemoText to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MemoId. */
            interface IMemoId {

                /** MemoId id */
                id?: (Long|null);
            }

            /** Represents a MemoId. */
            class MemoId implements IMemoId {

                /**
                 * Constructs a new MemoId.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IMemoId);

                /** MemoId id. */
                public id: Long;

                /**
                 * Creates a new MemoId instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MemoId instance
                 */
                public static create(properties?: TW.Stellar.Proto.IMemoId): TW.Stellar.Proto.MemoId;

                /**
                 * Encodes the specified MemoId message. Does not implicitly {@link TW.Stellar.Proto.MemoId.verify|verify} messages.
                 * @param message MemoId message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IMemoId, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MemoId message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MemoId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.MemoId;

                /**
                 * Verifies a MemoId message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MemoId message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MemoId
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.MemoId;

                /**
                 * Creates a plain object from a MemoId message. Also converts values to other types if specified.
                 * @param message MemoId
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.MemoId, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MemoId to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a MemoHash. */
            interface IMemoHash {

                /** MemoHash hash */
                hash?: (Uint8Array|null);
            }

            /** Represents a MemoHash. */
            class MemoHash implements IMemoHash {

                /**
                 * Constructs a new MemoHash.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.IMemoHash);

                /** MemoHash hash. */
                public hash: Uint8Array;

                /**
                 * Creates a new MemoHash instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns MemoHash instance
                 */
                public static create(properties?: TW.Stellar.Proto.IMemoHash): TW.Stellar.Proto.MemoHash;

                /**
                 * Encodes the specified MemoHash message. Does not implicitly {@link TW.Stellar.Proto.MemoHash.verify|verify} messages.
                 * @param message MemoHash message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.IMemoHash, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MemoHash message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns MemoHash
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.MemoHash;

                /**
                 * Verifies a MemoHash message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a MemoHash message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns MemoHash
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.MemoHash;

                /**
                 * Creates a plain object from a MemoHash message. Also converts values to other types if specified.
                 * @param message MemoHash
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.MemoHash, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this MemoHash to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput fee */
                fee?: (number|null);

                /** SigningInput sequence */
                sequence?: (Long|null);

                /** SigningInput account */
                account?: (string|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput passphrase */
                passphrase?: (string|null);

                /** SigningInput opCreateAccount */
                opCreateAccount?: (TW.Stellar.Proto.IOperationCreateAccount|null);

                /** SigningInput opPayment */
                opPayment?: (TW.Stellar.Proto.IOperationPayment|null);

                /** SigningInput opChangeTrust */
                opChangeTrust?: (TW.Stellar.Proto.IOperationChangeTrust|null);

                /** SigningInput opCreateClaimableBalance */
                opCreateClaimableBalance?: (TW.Stellar.Proto.IOperationCreateClaimableBalance|null);

                /** SigningInput opClaimClaimableBalance */
                opClaimClaimableBalance?: (TW.Stellar.Proto.IOperationClaimClaimableBalance|null);

                /** SigningInput memoVoid */
                memoVoid?: (TW.Stellar.Proto.IMemoVoid|null);

                /** SigningInput memoText */
                memoText?: (TW.Stellar.Proto.IMemoText|null);

                /** SigningInput memoId */
                memoId?: (TW.Stellar.Proto.IMemoId|null);

                /** SigningInput memoHash */
                memoHash?: (TW.Stellar.Proto.IMemoHash|null);

                /** SigningInput memoReturnHash */
                memoReturnHash?: (TW.Stellar.Proto.IMemoHash|null);

                /** SigningInput timeBounds */
                timeBounds?: (Long|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.ISigningInput);

                /** SigningInput fee. */
                public fee: number;

                /** SigningInput sequence. */
                public sequence: Long;

                /** SigningInput account. */
                public account: string;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput passphrase. */
                public passphrase: string;

                /** SigningInput opCreateAccount. */
                public opCreateAccount?: (TW.Stellar.Proto.IOperationCreateAccount|null);

                /** SigningInput opPayment. */
                public opPayment?: (TW.Stellar.Proto.IOperationPayment|null);

                /** SigningInput opChangeTrust. */
                public opChangeTrust?: (TW.Stellar.Proto.IOperationChangeTrust|null);

                /** SigningInput opCreateClaimableBalance. */
                public opCreateClaimableBalance?: (TW.Stellar.Proto.IOperationCreateClaimableBalance|null);

                /** SigningInput opClaimClaimableBalance. */
                public opClaimClaimableBalance?: (TW.Stellar.Proto.IOperationClaimClaimableBalance|null);

                /** SigningInput memoVoid. */
                public memoVoid?: (TW.Stellar.Proto.IMemoVoid|null);

                /** SigningInput memoText. */
                public memoText?: (TW.Stellar.Proto.IMemoText|null);

                /** SigningInput memoId. */
                public memoId?: (TW.Stellar.Proto.IMemoId|null);

                /** SigningInput memoHash. */
                public memoHash?: (TW.Stellar.Proto.IMemoHash|null);

                /** SigningInput memoReturnHash. */
                public memoReturnHash?: (TW.Stellar.Proto.IMemoHash|null);

                /** SigningInput timeBounds. */
                public timeBounds: Long;

                /** SigningInput operationOneof. */
                public operationOneof?: ("opCreateAccount"|"opPayment"|"opChangeTrust"|"opCreateClaimableBalance"|"opClaimClaimableBalance");

                /** SigningInput memoTypeOneof. */
                public memoTypeOneof?: ("memoVoid"|"memoText"|"memoId"|"memoHash"|"memoReturnHash");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Stellar.Proto.ISigningInput): TW.Stellar.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Stellar.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Stellar.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Stellar.Proto.ISigningOutput): TW.Stellar.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Stellar.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Stellar.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Stellar.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Stellar.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Stellar.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Sui. */
    namespace Sui {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SignDirect. */
            interface ISignDirect {

                /** SignDirect unsignedTxMsg */
                unsignedTxMsg?: (string|null);
            }

            /** Represents a SignDirect. */
            class SignDirect implements ISignDirect {

                /**
                 * Constructs a new SignDirect.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Sui.Proto.ISignDirect);

                /** SignDirect unsignedTxMsg. */
                public unsignedTxMsg: string;

                /**
                 * Creates a new SignDirect instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SignDirect instance
                 */
                public static create(properties?: TW.Sui.Proto.ISignDirect): TW.Sui.Proto.SignDirect;

                /**
                 * Encodes the specified SignDirect message. Does not implicitly {@link TW.Sui.Proto.SignDirect.verify|verify} messages.
                 * @param message SignDirect message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Sui.Proto.ISignDirect, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SignDirect message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SignDirect
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Sui.Proto.SignDirect;

                /**
                 * Verifies a SignDirect message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SignDirect message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SignDirect
                 */
                public static fromObject(object: { [k: string]: any }): TW.Sui.Proto.SignDirect;

                /**
                 * Creates a plain object from a SignDirect message. Also converts values to other types if specified.
                 * @param message SignDirect
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Sui.Proto.SignDirect, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SignDirect to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput signDirectMessage */
                signDirectMessage?: (TW.Sui.Proto.ISignDirect|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Sui.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput signDirectMessage. */
                public signDirectMessage?: (TW.Sui.Proto.ISignDirect|null);

                /** SigningInput transactionPayload. */
                public transactionPayload?: "signDirectMessage";

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Sui.Proto.ISigningInput): TW.Sui.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Sui.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Sui.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Sui.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Sui.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Sui.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** The raw transaction without indent in base64 */
                unsignedTx?: (string|null);

                /** The signature encoded in base64 */
                signature?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Sui.Proto.ISigningOutput);

                /** The raw transaction without indent in base64 */
                public unsignedTx: string;

                /** The signature encoded in base64 */
                public signature: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Sui.Proto.ISigningOutput): TW.Sui.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Sui.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Sui.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Sui.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Sui.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Sui.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Tezos. */
    namespace Tezos {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput operationList */
                operationList?: (TW.Tezos.Proto.IOperationList|null);

                /** SigningInput encodedOperations */
                encodedOperations?: (Uint8Array|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.ISigningInput);

                /** SigningInput operationList. */
                public operationList?: (TW.Tezos.Proto.IOperationList|null);

                /** SigningInput encodedOperations. */
                public encodedOperations: Uint8Array;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Tezos.Proto.ISigningInput): TW.Tezos.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tezos.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Tezos.Proto.ISigningOutput): TW.Tezos.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tezos.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationList. */
            interface IOperationList {

                /** OperationList branch */
                branch?: (string|null);

                /** OperationList operations */
                operations?: (TW.Tezos.Proto.IOperation[]|null);
            }

            /** Represents an OperationList. */
            class OperationList implements IOperationList {

                /**
                 * Constructs a new OperationList.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IOperationList);

                /** OperationList branch. */
                public branch: string;

                /** OperationList operations. */
                public operations: TW.Tezos.Proto.IOperation[];

                /**
                 * Creates a new OperationList instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationList instance
                 */
                public static create(properties?: TW.Tezos.Proto.IOperationList): TW.Tezos.Proto.OperationList;

                /**
                 * Encodes the specified OperationList message. Does not implicitly {@link TW.Tezos.Proto.OperationList.verify|verify} messages.
                 * @param message OperationList message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IOperationList, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationList message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.OperationList;

                /**
                 * Verifies an OperationList message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationList message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationList
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.OperationList;

                /**
                 * Creates a plain object from an OperationList message. Also converts values to other types if specified.
                 * @param message OperationList
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.OperationList, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationList to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Operation. */
            interface IOperation {

                /** Operation counter */
                counter?: (Long|null);

                /** Operation source */
                source?: (string|null);

                /** Operation fee */
                fee?: (Long|null);

                /** Operation gasLimit */
                gasLimit?: (Long|null);

                /** Operation storageLimit */
                storageLimit?: (Long|null);

                /** Operation kind */
                kind?: (TW.Tezos.Proto.Operation.OperationKind|null);

                /** Operation revealOperationData */
                revealOperationData?: (TW.Tezos.Proto.IRevealOperationData|null);

                /** Operation transactionOperationData */
                transactionOperationData?: (TW.Tezos.Proto.ITransactionOperationData|null);

                /** Operation delegationOperationData */
                delegationOperationData?: (TW.Tezos.Proto.IDelegationOperationData|null);
            }

            /** Represents an Operation. */
            class Operation implements IOperation {

                /**
                 * Constructs a new Operation.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IOperation);

                /** Operation counter. */
                public counter: Long;

                /** Operation source. */
                public source: string;

                /** Operation fee. */
                public fee: Long;

                /** Operation gasLimit. */
                public gasLimit: Long;

                /** Operation storageLimit. */
                public storageLimit: Long;

                /** Operation kind. */
                public kind: TW.Tezos.Proto.Operation.OperationKind;

                /** Operation revealOperationData. */
                public revealOperationData?: (TW.Tezos.Proto.IRevealOperationData|null);

                /** Operation transactionOperationData. */
                public transactionOperationData?: (TW.Tezos.Proto.ITransactionOperationData|null);

                /** Operation delegationOperationData. */
                public delegationOperationData?: (TW.Tezos.Proto.IDelegationOperationData|null);

                /** Operation operationData. */
                public operationData?: ("revealOperationData"|"transactionOperationData"|"delegationOperationData");

                /**
                 * Creates a new Operation instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Operation instance
                 */
                public static create(properties?: TW.Tezos.Proto.IOperation): TW.Tezos.Proto.Operation;

                /**
                 * Encodes the specified Operation message. Does not implicitly {@link TW.Tezos.Proto.Operation.verify|verify} messages.
                 * @param message Operation message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IOperation, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Operation message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.Operation;

                /**
                 * Verifies an Operation message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Operation message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Operation
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.Operation;

                /**
                 * Creates a plain object from an Operation message. Also converts values to other types if specified.
                 * @param message Operation
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.Operation, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Operation to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Operation {

                /** OperationKind enum. */
                enum OperationKind {
                    ENDORSEMENT = 0,
                    REVEAL = 107,
                    TRANSACTION = 108,
                    DELEGATION = 110
                }
            }

            /** Properties of a FA12Parameters. */
            interface IFA12Parameters {

                /** FA12Parameters entrypoint */
                entrypoint?: (string|null);

                /** FA12Parameters from */
                from?: (string|null);

                /** FA12Parameters to */
                to?: (string|null);

                /** FA12Parameters value */
                value?: (string|null);
            }

            /** Represents a FA12Parameters. */
            class FA12Parameters implements IFA12Parameters {

                /**
                 * Constructs a new FA12Parameters.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IFA12Parameters);

                /** FA12Parameters entrypoint. */
                public entrypoint: string;

                /** FA12Parameters from. */
                public from: string;

                /** FA12Parameters to. */
                public to: string;

                /** FA12Parameters value. */
                public value: string;

                /**
                 * Creates a new FA12Parameters instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FA12Parameters instance
                 */
                public static create(properties?: TW.Tezos.Proto.IFA12Parameters): TW.Tezos.Proto.FA12Parameters;

                /**
                 * Encodes the specified FA12Parameters message. Does not implicitly {@link TW.Tezos.Proto.FA12Parameters.verify|verify} messages.
                 * @param message FA12Parameters message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IFA12Parameters, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FA12Parameters message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FA12Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.FA12Parameters;

                /**
                 * Verifies a FA12Parameters message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FA12Parameters message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FA12Parameters
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.FA12Parameters;

                /**
                 * Creates a plain object from a FA12Parameters message. Also converts values to other types if specified.
                 * @param message FA12Parameters
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.FA12Parameters, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FA12Parameters to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Txs. */
            interface ITxs {

                /** Txs to */
                to?: (string|null);

                /** Txs tokenId */
                tokenId?: (string|null);

                /** Txs amount */
                amount?: (string|null);
            }

            /** Represents a Txs. */
            class Txs implements ITxs {

                /**
                 * Constructs a new Txs.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.ITxs);

                /** Txs to. */
                public to: string;

                /** Txs tokenId. */
                public tokenId: string;

                /** Txs amount. */
                public amount: string;

                /**
                 * Creates a new Txs instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Txs instance
                 */
                public static create(properties?: TW.Tezos.Proto.ITxs): TW.Tezos.Proto.Txs;

                /**
                 * Encodes the specified Txs message. Does not implicitly {@link TW.Tezos.Proto.Txs.verify|verify} messages.
                 * @param message Txs message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.ITxs, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Txs message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Txs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.Txs;

                /**
                 * Verifies a Txs message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Txs message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Txs
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.Txs;

                /**
                 * Creates a plain object from a Txs message. Also converts values to other types if specified.
                 * @param message Txs
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.Txs, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Txs to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TxObject. */
            interface ITxObject {

                /** TxObject from */
                from?: (string|null);

                /** TxObject txs */
                txs?: (TW.Tezos.Proto.ITxs[]|null);
            }

            /** Represents a TxObject. */
            class TxObject implements ITxObject {

                /**
                 * Constructs a new TxObject.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.ITxObject);

                /** TxObject from. */
                public from: string;

                /** TxObject txs. */
                public txs: TW.Tezos.Proto.ITxs[];

                /**
                 * Creates a new TxObject instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TxObject instance
                 */
                public static create(properties?: TW.Tezos.Proto.ITxObject): TW.Tezos.Proto.TxObject;

                /**
                 * Encodes the specified TxObject message. Does not implicitly {@link TW.Tezos.Proto.TxObject.verify|verify} messages.
                 * @param message TxObject message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.ITxObject, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TxObject message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TxObject
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.TxObject;

                /**
                 * Verifies a TxObject message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TxObject message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TxObject
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.TxObject;

                /**
                 * Creates a plain object from a TxObject message. Also converts values to other types if specified.
                 * @param message TxObject
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.TxObject, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TxObject to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FA2Parameters. */
            interface IFA2Parameters {

                /** FA2Parameters entrypoint */
                entrypoint?: (string|null);

                /** FA2Parameters txsObject */
                txsObject?: (TW.Tezos.Proto.ITxObject[]|null);
            }

            /** Represents a FA2Parameters. */
            class FA2Parameters implements IFA2Parameters {

                /**
                 * Constructs a new FA2Parameters.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IFA2Parameters);

                /** FA2Parameters entrypoint. */
                public entrypoint: string;

                /** FA2Parameters txsObject. */
                public txsObject: TW.Tezos.Proto.ITxObject[];

                /**
                 * Creates a new FA2Parameters instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FA2Parameters instance
                 */
                public static create(properties?: TW.Tezos.Proto.IFA2Parameters): TW.Tezos.Proto.FA2Parameters;

                /**
                 * Encodes the specified FA2Parameters message. Does not implicitly {@link TW.Tezos.Proto.FA2Parameters.verify|verify} messages.
                 * @param message FA2Parameters message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IFA2Parameters, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FA2Parameters message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FA2Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.FA2Parameters;

                /**
                 * Verifies a FA2Parameters message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FA2Parameters message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FA2Parameters
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.FA2Parameters;

                /**
                 * Creates a plain object from a FA2Parameters message. Also converts values to other types if specified.
                 * @param message FA2Parameters
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.FA2Parameters, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FA2Parameters to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an OperationParameters. */
            interface IOperationParameters {

                /** OperationParameters fa12Parameters */
                fa12Parameters?: (TW.Tezos.Proto.IFA12Parameters|null);

                /** OperationParameters fa2Parameters */
                fa2Parameters?: (TW.Tezos.Proto.IFA2Parameters|null);
            }

            /** Represents an OperationParameters. */
            class OperationParameters implements IOperationParameters {

                /**
                 * Constructs a new OperationParameters.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IOperationParameters);

                /** OperationParameters fa12Parameters. */
                public fa12Parameters?: (TW.Tezos.Proto.IFA12Parameters|null);

                /** OperationParameters fa2Parameters. */
                public fa2Parameters?: (TW.Tezos.Proto.IFA2Parameters|null);

                /** OperationParameters parameters. */
                public parameters?: ("fa12Parameters"|"fa2Parameters");

                /**
                 * Creates a new OperationParameters instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns OperationParameters instance
                 */
                public static create(properties?: TW.Tezos.Proto.IOperationParameters): TW.Tezos.Proto.OperationParameters;

                /**
                 * Encodes the specified OperationParameters message. Does not implicitly {@link TW.Tezos.Proto.OperationParameters.verify|verify} messages.
                 * @param message OperationParameters message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IOperationParameters, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OperationParameters message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns OperationParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.OperationParameters;

                /**
                 * Verifies an OperationParameters message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an OperationParameters message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns OperationParameters
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.OperationParameters;

                /**
                 * Creates a plain object from an OperationParameters message. Also converts values to other types if specified.
                 * @param message OperationParameters
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.OperationParameters, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this OperationParameters to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransactionOperationData. */
            interface ITransactionOperationData {

                /** TransactionOperationData destination */
                destination?: (string|null);

                /** TransactionOperationData amount */
                amount?: (Long|null);

                /** TransactionOperationData encodedParameter */
                encodedParameter?: (Uint8Array|null);

                /** TransactionOperationData parameters */
                parameters?: (TW.Tezos.Proto.IOperationParameters|null);
            }

            /** Represents a TransactionOperationData. */
            class TransactionOperationData implements ITransactionOperationData {

                /**
                 * Constructs a new TransactionOperationData.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.ITransactionOperationData);

                /** TransactionOperationData destination. */
                public destination: string;

                /** TransactionOperationData amount. */
                public amount: Long;

                /** TransactionOperationData encodedParameter. */
                public encodedParameter: Uint8Array;

                /** TransactionOperationData parameters. */
                public parameters?: (TW.Tezos.Proto.IOperationParameters|null);

                /**
                 * Creates a new TransactionOperationData instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransactionOperationData instance
                 */
                public static create(properties?: TW.Tezos.Proto.ITransactionOperationData): TW.Tezos.Proto.TransactionOperationData;

                /**
                 * Encodes the specified TransactionOperationData message. Does not implicitly {@link TW.Tezos.Proto.TransactionOperationData.verify|verify} messages.
                 * @param message TransactionOperationData message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.ITransactionOperationData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransactionOperationData message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransactionOperationData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.TransactionOperationData;

                /**
                 * Verifies a TransactionOperationData message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransactionOperationData message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransactionOperationData
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.TransactionOperationData;

                /**
                 * Creates a plain object from a TransactionOperationData message. Also converts values to other types if specified.
                 * @param message TransactionOperationData
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.TransactionOperationData, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransactionOperationData to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a RevealOperationData. */
            interface IRevealOperationData {

                /** RevealOperationData publicKey */
                publicKey?: (Uint8Array|null);
            }

            /** Represents a RevealOperationData. */
            class RevealOperationData implements IRevealOperationData {

                /**
                 * Constructs a new RevealOperationData.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IRevealOperationData);

                /** RevealOperationData publicKey. */
                public publicKey: Uint8Array;

                /**
                 * Creates a new RevealOperationData instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns RevealOperationData instance
                 */
                public static create(properties?: TW.Tezos.Proto.IRevealOperationData): TW.Tezos.Proto.RevealOperationData;

                /**
                 * Encodes the specified RevealOperationData message. Does not implicitly {@link TW.Tezos.Proto.RevealOperationData.verify|verify} messages.
                 * @param message RevealOperationData message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IRevealOperationData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RevealOperationData message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns RevealOperationData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.RevealOperationData;

                /**
                 * Verifies a RevealOperationData message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a RevealOperationData message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns RevealOperationData
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.RevealOperationData;

                /**
                 * Creates a plain object from a RevealOperationData message. Also converts values to other types if specified.
                 * @param message RevealOperationData
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.RevealOperationData, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this RevealOperationData to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DelegationOperationData. */
            interface IDelegationOperationData {

                /** DelegationOperationData delegate */
                delegate?: (string|null);
            }

            /** Represents a DelegationOperationData. */
            class DelegationOperationData implements IDelegationOperationData {

                /**
                 * Constructs a new DelegationOperationData.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tezos.Proto.IDelegationOperationData);

                /** DelegationOperationData delegate. */
                public delegate: string;

                /**
                 * Creates a new DelegationOperationData instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DelegationOperationData instance
                 */
                public static create(properties?: TW.Tezos.Proto.IDelegationOperationData): TW.Tezos.Proto.DelegationOperationData;

                /**
                 * Encodes the specified DelegationOperationData message. Does not implicitly {@link TW.Tezos.Proto.DelegationOperationData.verify|verify} messages.
                 * @param message DelegationOperationData message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tezos.Proto.IDelegationOperationData, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DelegationOperationData message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DelegationOperationData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tezos.Proto.DelegationOperationData;

                /**
                 * Verifies a DelegationOperationData message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DelegationOperationData message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DelegationOperationData
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tezos.Proto.DelegationOperationData;

                /**
                 * Creates a plain object from a DelegationOperationData message. Also converts values to other types if specified.
                 * @param message DelegationOperationData
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tezos.Proto.DelegationOperationData, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DelegationOperationData to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace TheOpenNetwork. */
    namespace TheOpenNetwork {

        /** Namespace Proto. */
        namespace Proto {

            /** WalletVersion enum. */
            enum WalletVersion {
                WALLET_V3_R1 = 0,
                WALLET_V3_R2 = 1,
                WALLET_V4_R2 = 2
            }

            /** SendMode enum. */
            enum SendMode {
                DEFAULT = 0,
                PAY_FEES_SEPARATELY = 1,
                IGNORE_ACTION_PHASE_ERRORS = 2,
                DESTROY_ON_ZERO_BALANCE = 32,
                ATTACH_ALL_INBOUND_MESSAGE_VALUE = 64,
                ATTACH_ALL_CONTRACT_BALANCE = 128
            }

            /** Properties of a Transfer. */
            interface ITransfer {

                /** Transfer walletVersion */
                walletVersion?: (TW.TheOpenNetwork.Proto.WalletVersion|null);

                /** Transfer dest */
                dest?: (string|null);

                /** Transfer amount */
                amount?: (Long|null);

                /** Transfer sequenceNumber */
                sequenceNumber?: (number|null);

                /** Transfer mode */
                mode?: (number|null);

                /** Transfer expireAt */
                expireAt?: (number|null);

                /** Transfer comment */
                comment?: (string|null);

                /** Transfer bounceable */
                bounceable?: (boolean|null);
            }

            /** Represents a Transfer. */
            class Transfer implements ITransfer {

                /**
                 * Constructs a new Transfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.TheOpenNetwork.Proto.ITransfer);

                /** Transfer walletVersion. */
                public walletVersion: TW.TheOpenNetwork.Proto.WalletVersion;

                /** Transfer dest. */
                public dest: string;

                /** Transfer amount. */
                public amount: Long;

                /** Transfer sequenceNumber. */
                public sequenceNumber: number;

                /** Transfer mode. */
                public mode: number;

                /** Transfer expireAt. */
                public expireAt: number;

                /** Transfer comment. */
                public comment: string;

                /** Transfer bounceable. */
                public bounceable: boolean;

                /**
                 * Creates a new Transfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transfer instance
                 */
                public static create(properties?: TW.TheOpenNetwork.Proto.ITransfer): TW.TheOpenNetwork.Proto.Transfer;

                /**
                 * Encodes the specified Transfer message. Does not implicitly {@link TW.TheOpenNetwork.Proto.Transfer.verify|verify} messages.
                 * @param message Transfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.TheOpenNetwork.Proto.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.TheOpenNetwork.Proto.Transfer;

                /**
                 * Verifies a Transfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.TheOpenNetwork.Proto.Transfer;

                /**
                 * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                 * @param message Transfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.TheOpenNetwork.Proto.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a JettonTransfer. */
            interface IJettonTransfer {

                /** JettonTransfer transfer */
                transfer?: (TW.TheOpenNetwork.Proto.ITransfer|null);

                /** JettonTransfer queryId */
                queryId?: (Long|null);

                /** JettonTransfer jettonAmount */
                jettonAmount?: (Long|null);

                /** JettonTransfer toOwner */
                toOwner?: (string|null);

                /** JettonTransfer responseAddress */
                responseAddress?: (string|null);

                /** JettonTransfer forwardAmount */
                forwardAmount?: (Long|null);
            }

            /** Represents a JettonTransfer. */
            class JettonTransfer implements IJettonTransfer {

                /**
                 * Constructs a new JettonTransfer.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.TheOpenNetwork.Proto.IJettonTransfer);

                /** JettonTransfer transfer. */
                public transfer?: (TW.TheOpenNetwork.Proto.ITransfer|null);

                /** JettonTransfer queryId. */
                public queryId: Long;

                /** JettonTransfer jettonAmount. */
                public jettonAmount: Long;

                /** JettonTransfer toOwner. */
                public toOwner: string;

                /** JettonTransfer responseAddress. */
                public responseAddress: string;

                /** JettonTransfer forwardAmount. */
                public forwardAmount: Long;

                /**
                 * Creates a new JettonTransfer instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns JettonTransfer instance
                 */
                public static create(properties?: TW.TheOpenNetwork.Proto.IJettonTransfer): TW.TheOpenNetwork.Proto.JettonTransfer;

                /**
                 * Encodes the specified JettonTransfer message. Does not implicitly {@link TW.TheOpenNetwork.Proto.JettonTransfer.verify|verify} messages.
                 * @param message JettonTransfer message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.TheOpenNetwork.Proto.IJettonTransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a JettonTransfer message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns JettonTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.TheOpenNetwork.Proto.JettonTransfer;

                /**
                 * Verifies a JettonTransfer message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a JettonTransfer message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns JettonTransfer
                 */
                public static fromObject(object: { [k: string]: any }): TW.TheOpenNetwork.Proto.JettonTransfer;

                /**
                 * Creates a plain object from a JettonTransfer message. Also converts values to other types if specified.
                 * @param message JettonTransfer
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.TheOpenNetwork.Proto.JettonTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this JettonTransfer to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transfer */
                transfer?: (TW.TheOpenNetwork.Proto.ITransfer|null);

                /** SigningInput jettonTransfer */
                jettonTransfer?: (TW.TheOpenNetwork.Proto.IJettonTransfer|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.TheOpenNetwork.Proto.ISigningInput);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transfer. */
                public transfer?: (TW.TheOpenNetwork.Proto.ITransfer|null);

                /** SigningInput jettonTransfer. */
                public jettonTransfer?: (TW.TheOpenNetwork.Proto.IJettonTransfer|null);

                /** SigningInput actionOneof. */
                public actionOneof?: ("transfer"|"jettonTransfer");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.TheOpenNetwork.Proto.ISigningInput): TW.TheOpenNetwork.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.TheOpenNetwork.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.TheOpenNetwork.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.TheOpenNetwork.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.TheOpenNetwork.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.TheOpenNetwork.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.TheOpenNetwork.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.TheOpenNetwork.Proto.ISigningOutput): TW.TheOpenNetwork.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.TheOpenNetwork.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.TheOpenNetwork.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.TheOpenNetwork.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.TheOpenNetwork.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.TheOpenNetwork.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Theta. */
    namespace Theta {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** Chain ID string, mainnet, testnet and privatenet */
                chainId?: (string|null);

                /** Recipient address */
                toAddress?: (string|null);

                /** Theta token amount to send in wei (uint256, serialized little endian) */
                thetaAmount?: (Uint8Array|null);

                /** TFuel token amount to send in wei (uint256, serialized little endian) */
                tfuelAmount?: (Uint8Array|null);

                /** Sequence number of the transaction for the sender address */
                sequence?: (Long|null);

                /** Fee amount in TFuel wei for the transaction (uint256, serialized little endian) */
                fee?: (Uint8Array|null);

                /** The secret private key used for signing (32 bytes). */
                privateKey?: (Uint8Array|null);

                /** Public key */
                publicKey?: (Uint8Array|null);
            }

            /** Input data necessary to create a signed transaction */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Theta.Proto.ISigningInput);

                /** Chain ID string, mainnet, testnet and privatenet */
                public chainId: string;

                /** Recipient address */
                public toAddress: string;

                /** Theta token amount to send in wei (uint256, serialized little endian) */
                public thetaAmount: Uint8Array;

                /** TFuel token amount to send in wei (uint256, serialized little endian) */
                public tfuelAmount: Uint8Array;

                /** Sequence number of the transaction for the sender address */
                public sequence: Long;

                /** Fee amount in TFuel wei for the transaction (uint256, serialized little endian) */
                public fee: Uint8Array;

                /** The secret private key used for signing (32 bytes). */
                public privateKey: Uint8Array;

                /** Public key */
                public publicKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Theta.Proto.ISigningInput): TW.Theta.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Theta.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Theta.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Theta.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Theta.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Theta.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** Signed and encoded transaction bytes */
                encoded?: (Uint8Array|null);

                /** Signature */
                signature?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Theta.Proto.ISigningOutput);

                /** Signed and encoded transaction bytes */
                public encoded: Uint8Array;

                /** Signature */
                public signature: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Theta.Proto.ISigningOutput): TW.Theta.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Theta.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Theta.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Theta.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Theta.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Theta.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace THORChainSwap. */
    namespace THORChainSwap {

        /** Namespace Proto. */
        namespace Proto {

            /** Chain enum. */
            enum Chain {
                THOR = 0,
                BTC = 1,
                ETH = 2,
                BNB = 3,
                DOGE = 4,
                BCH = 5,
                LTC = 6,
                ATOM = 7,
                AVAX = 8,
                BSC = 9
            }

            /** ErrorCode enum. */
            enum ErrorCode {
                OK = 0,
                Error_general = 1,
                Error_Input_proto_deserialization = 2,
                Error_Unsupported_from_chain = 13,
                Error_Unsupported_to_chain = 14,
                Error_Invalid_from_address = 15,
                Error_Invalid_to_address = 16,
                Error_Invalid_vault_address = 21,
                Error_Invalid_router_address = 22
            }

            /** Properties of an Error. */
            interface IError {

                /** Error code */
                code?: (TW.THORChainSwap.Proto.ErrorCode|null);

                /** Error message */
                message?: (string|null);
            }

            /** Represents an Error. */
            class Error implements IError {

                /**
                 * Constructs a new Error.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.THORChainSwap.Proto.IError);

                /** Error code. */
                public code: TW.THORChainSwap.Proto.ErrorCode;

                /** Error message. */
                public message: string;

                /**
                 * Creates a new Error instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Error instance
                 */
                public static create(properties?: TW.THORChainSwap.Proto.IError): TW.THORChainSwap.Proto.Error;

                /**
                 * Encodes the specified Error message. Does not implicitly {@link TW.THORChainSwap.Proto.Error.verify|verify} messages.
                 * @param message Error message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.THORChainSwap.Proto.IError, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.THORChainSwap.Proto.Error;

                /**
                 * Verifies an Error message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Error
                 */
                public static fromObject(object: { [k: string]: any }): TW.THORChainSwap.Proto.Error;

                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @param message Error
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.THORChainSwap.Proto.Error, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Error to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an Asset. */
            interface IAsset {

                /** Asset chain */
                chain?: (TW.THORChainSwap.Proto.Chain|null);

                /** Asset symbol */
                symbol?: (string|null);

                /** Asset tokenId */
                tokenId?: (string|null);
            }

            /** Represents an Asset. */
            class Asset implements IAsset {

                /**
                 * Constructs a new Asset.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.THORChainSwap.Proto.IAsset);

                /** Asset chain. */
                public chain: TW.THORChainSwap.Proto.Chain;

                /** Asset symbol. */
                public symbol: string;

                /** Asset tokenId. */
                public tokenId: string;

                /**
                 * Creates a new Asset instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Asset instance
                 */
                public static create(properties?: TW.THORChainSwap.Proto.IAsset): TW.THORChainSwap.Proto.Asset;

                /**
                 * Encodes the specified Asset message. Does not implicitly {@link TW.THORChainSwap.Proto.Asset.verify|verify} messages.
                 * @param message Asset message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.THORChainSwap.Proto.IAsset, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Asset message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Asset
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.THORChainSwap.Proto.Asset;

                /**
                 * Verifies an Asset message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Asset
                 */
                public static fromObject(object: { [k: string]: any }): TW.THORChainSwap.Proto.Asset;

                /**
                 * Creates a plain object from an Asset message. Also converts values to other types if specified.
                 * @param message Asset
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.THORChainSwap.Proto.Asset, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Asset to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a StreamParams. */
            interface IStreamParams {

                /** StreamParams interval */
                interval?: (string|null);

                /** StreamParams quantity */
                quantity?: (string|null);
            }

            /** Represents a StreamParams. */
            class StreamParams implements IStreamParams {

                /**
                 * Constructs a new StreamParams.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.THORChainSwap.Proto.IStreamParams);

                /** StreamParams interval. */
                public interval: string;

                /** StreamParams quantity. */
                public quantity: string;

                /**
                 * Creates a new StreamParams instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns StreamParams instance
                 */
                public static create(properties?: TW.THORChainSwap.Proto.IStreamParams): TW.THORChainSwap.Proto.StreamParams;

                /**
                 * Encodes the specified StreamParams message. Does not implicitly {@link TW.THORChainSwap.Proto.StreamParams.verify|verify} messages.
                 * @param message StreamParams message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.THORChainSwap.Proto.IStreamParams, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a StreamParams message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns StreamParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.THORChainSwap.Proto.StreamParams;

                /**
                 * Verifies a StreamParams message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a StreamParams message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns StreamParams
                 */
                public static fromObject(object: { [k: string]: any }): TW.THORChainSwap.Proto.StreamParams;

                /**
                 * Creates a plain object from a StreamParams message. Also converts values to other types if specified.
                 * @param message StreamParams
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.THORChainSwap.Proto.StreamParams, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this StreamParams to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SwapInput. */
            interface ISwapInput {

                /** SwapInput fromAsset */
                fromAsset?: (TW.THORChainSwap.Proto.IAsset|null);

                /** SwapInput fromAddress */
                fromAddress?: (string|null);

                /** SwapInput toAsset */
                toAsset?: (TW.THORChainSwap.Proto.IAsset|null);

                /** SwapInput toAddress */
                toAddress?: (string|null);

                /** SwapInput vaultAddress */
                vaultAddress?: (string|null);

                /** SwapInput routerAddress */
                routerAddress?: (string|null);

                /** SwapInput fromAmount */
                fromAmount?: (string|null);

                /** SwapInput toAmountLimit */
                toAmountLimit?: (string|null);

                /** SwapInput affiliateFeeAddress */
                affiliateFeeAddress?: (string|null);

                /** SwapInput affiliateFeeRateBp */
                affiliateFeeRateBp?: (string|null);

                /** SwapInput extraMemo */
                extraMemo?: (string|null);

                /** SwapInput expirationTime */
                expirationTime?: (Long|null);

                /** SwapInput streamParams */
                streamParams?: (TW.THORChainSwap.Proto.IStreamParams|null);
            }

            /** Represents a SwapInput. */
            class SwapInput implements ISwapInput {

                /**
                 * Constructs a new SwapInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.THORChainSwap.Proto.ISwapInput);

                /** SwapInput fromAsset. */
                public fromAsset?: (TW.THORChainSwap.Proto.IAsset|null);

                /** SwapInput fromAddress. */
                public fromAddress: string;

                /** SwapInput toAsset. */
                public toAsset?: (TW.THORChainSwap.Proto.IAsset|null);

                /** SwapInput toAddress. */
                public toAddress: string;

                /** SwapInput vaultAddress. */
                public vaultAddress: string;

                /** SwapInput routerAddress. */
                public routerAddress: string;

                /** SwapInput fromAmount. */
                public fromAmount: string;

                /** SwapInput toAmountLimit. */
                public toAmountLimit: string;

                /** SwapInput affiliateFeeAddress. */
                public affiliateFeeAddress: string;

                /** SwapInput affiliateFeeRateBp. */
                public affiliateFeeRateBp: string;

                /** SwapInput extraMemo. */
                public extraMemo: string;

                /** SwapInput expirationTime. */
                public expirationTime: Long;

                /** SwapInput streamParams. */
                public streamParams?: (TW.THORChainSwap.Proto.IStreamParams|null);

                /**
                 * Creates a new SwapInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SwapInput instance
                 */
                public static create(properties?: TW.THORChainSwap.Proto.ISwapInput): TW.THORChainSwap.Proto.SwapInput;

                /**
                 * Encodes the specified SwapInput message. Does not implicitly {@link TW.THORChainSwap.Proto.SwapInput.verify|verify} messages.
                 * @param message SwapInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.THORChainSwap.Proto.ISwapInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SwapInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SwapInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.THORChainSwap.Proto.SwapInput;

                /**
                 * Verifies a SwapInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SwapInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SwapInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.THORChainSwap.Proto.SwapInput;

                /**
                 * Creates a plain object from a SwapInput message. Also converts values to other types if specified.
                 * @param message SwapInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.THORChainSwap.Proto.SwapInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SwapInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SwapOutput. */
            interface ISwapOutput {

                /** SwapOutput fromChain */
                fromChain?: (TW.THORChainSwap.Proto.Chain|null);

                /** SwapOutput toChain */
                toChain?: (TW.THORChainSwap.Proto.Chain|null);

                /** SwapOutput error */
                error?: (TW.THORChainSwap.Proto.IError|null);

                /** SwapOutput bitcoin */
                bitcoin?: (TW.Bitcoin.Proto.ISigningInput|null);

                /** SwapOutput ethereum */
                ethereum?: (TW.Ethereum.Proto.ISigningInput|null);

                /** SwapOutput binance */
                binance?: (TW.Binance.Proto.ISigningInput|null);

                /** SwapOutput cosmos */
                cosmos?: (TW.Cosmos.Proto.ISigningInput|null);
            }

            /** Represents a SwapOutput. */
            class SwapOutput implements ISwapOutput {

                /**
                 * Constructs a new SwapOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.THORChainSwap.Proto.ISwapOutput);

                /** SwapOutput fromChain. */
                public fromChain: TW.THORChainSwap.Proto.Chain;

                /** SwapOutput toChain. */
                public toChain: TW.THORChainSwap.Proto.Chain;

                /** SwapOutput error. */
                public error?: (TW.THORChainSwap.Proto.IError|null);

                /** SwapOutput bitcoin. */
                public bitcoin?: (TW.Bitcoin.Proto.ISigningInput|null);

                /** SwapOutput ethereum. */
                public ethereum?: (TW.Ethereum.Proto.ISigningInput|null);

                /** SwapOutput binance. */
                public binance?: (TW.Binance.Proto.ISigningInput|null);

                /** SwapOutput cosmos. */
                public cosmos?: (TW.Cosmos.Proto.ISigningInput|null);

                /** SwapOutput signingInputOneof. */
                public signingInputOneof?: ("bitcoin"|"ethereum"|"binance"|"cosmos");

                /**
                 * Creates a new SwapOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SwapOutput instance
                 */
                public static create(properties?: TW.THORChainSwap.Proto.ISwapOutput): TW.THORChainSwap.Proto.SwapOutput;

                /**
                 * Encodes the specified SwapOutput message. Does not implicitly {@link TW.THORChainSwap.Proto.SwapOutput.verify|verify} messages.
                 * @param message SwapOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.THORChainSwap.Proto.ISwapOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SwapOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SwapOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.THORChainSwap.Proto.SwapOutput;

                /**
                 * Verifies a SwapOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SwapOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SwapOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.THORChainSwap.Proto.SwapOutput;

                /**
                 * Creates a plain object from a SwapOutput message. Also converts values to other types if specified.
                 * @param message SwapOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.THORChainSwap.Proto.SwapOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SwapOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace TxCompiler. */
    namespace TxCompiler {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a PreSigningOutput. */
            interface IPreSigningOutput {

                /** Pre-image data hash that will be used for signing */
                dataHash?: (Uint8Array|null);

                /** Pre-image data */
                data?: (Uint8Array|null);

                /** error code, 0 is ok, other codes will be treated as errors */
                error?: (TW.Common.Proto.SigningError|null);

                /** error code description */
                errorMessage?: (string|null);
            }

            /** Transaction pre-signing output */
            class PreSigningOutput implements IPreSigningOutput {

                /**
                 * Constructs a new PreSigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.TxCompiler.Proto.IPreSigningOutput);

                /** Pre-image data hash that will be used for signing */
                public dataHash: Uint8Array;

                /** Pre-image data */
                public data: Uint8Array;

                /** error code, 0 is ok, other codes will be treated as errors */
                public error: TW.Common.Proto.SigningError;

                /** error code description */
                public errorMessage: string;

                /**
                 * Creates a new PreSigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns PreSigningOutput instance
                 */
                public static create(properties?: TW.TxCompiler.Proto.IPreSigningOutput): TW.TxCompiler.Proto.PreSigningOutput;

                /**
                 * Encodes the specified PreSigningOutput message. Does not implicitly {@link TW.TxCompiler.Proto.PreSigningOutput.verify|verify} messages.
                 * @param message PreSigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.TxCompiler.Proto.IPreSigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PreSigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns PreSigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.TxCompiler.Proto.PreSigningOutput;

                /**
                 * Verifies a PreSigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a PreSigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns PreSigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.TxCompiler.Proto.PreSigningOutput;

                /**
                 * Creates a plain object from a PreSigningOutput message. Also converts values to other types if specified.
                 * @param message PreSigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.TxCompiler.Proto.PreSigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this PreSigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Tron. */
    namespace Tron {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransferContract. */
            interface ITransferContract {

                /** TransferContract ownerAddress */
                ownerAddress?: (string|null);

                /** TransferContract toAddress */
                toAddress?: (string|null);

                /** TransferContract amount */
                amount?: (Long|null);
            }

            /** Represents a TransferContract. */
            class TransferContract implements ITransferContract {

                /**
                 * Constructs a new TransferContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ITransferContract);

                /** TransferContract ownerAddress. */
                public ownerAddress: string;

                /** TransferContract toAddress. */
                public toAddress: string;

                /** TransferContract amount. */
                public amount: Long;

                /**
                 * Creates a new TransferContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferContract instance
                 */
                public static create(properties?: TW.Tron.Proto.ITransferContract): TW.Tron.Proto.TransferContract;

                /**
                 * Encodes the specified TransferContract message. Does not implicitly {@link TW.Tron.Proto.TransferContract.verify|verify} messages.
                 * @param message TransferContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ITransferContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.TransferContract;

                /**
                 * Verifies a TransferContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.TransferContract;

                /**
                 * Creates a plain object from a TransferContract message. Also converts values to other types if specified.
                 * @param message TransferContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.TransferContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransferAssetContract. */
            interface ITransferAssetContract {

                /** TransferAssetContract assetName */
                assetName?: (string|null);

                /** TransferAssetContract ownerAddress */
                ownerAddress?: (string|null);

                /** TransferAssetContract toAddress */
                toAddress?: (string|null);

                /** TransferAssetContract amount */
                amount?: (Long|null);
            }

            /** Represents a TransferAssetContract. */
            class TransferAssetContract implements ITransferAssetContract {

                /**
                 * Constructs a new TransferAssetContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ITransferAssetContract);

                /** TransferAssetContract assetName. */
                public assetName: string;

                /** TransferAssetContract ownerAddress. */
                public ownerAddress: string;

                /** TransferAssetContract toAddress. */
                public toAddress: string;

                /** TransferAssetContract amount. */
                public amount: Long;

                /**
                 * Creates a new TransferAssetContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferAssetContract instance
                 */
                public static create(properties?: TW.Tron.Proto.ITransferAssetContract): TW.Tron.Proto.TransferAssetContract;

                /**
                 * Encodes the specified TransferAssetContract message. Does not implicitly {@link TW.Tron.Proto.TransferAssetContract.verify|verify} messages.
                 * @param message TransferAssetContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ITransferAssetContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferAssetContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferAssetContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.TransferAssetContract;

                /**
                 * Verifies a TransferAssetContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferAssetContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferAssetContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.TransferAssetContract;

                /**
                 * Creates a plain object from a TransferAssetContract message. Also converts values to other types if specified.
                 * @param message TransferAssetContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.TransferAssetContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferAssetContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TransferTRC20Contract. */
            interface ITransferTRC20Contract {

                /** TransferTRC20Contract contractAddress */
                contractAddress?: (string|null);

                /** TransferTRC20Contract ownerAddress */
                ownerAddress?: (string|null);

                /** TransferTRC20Contract toAddress */
                toAddress?: (string|null);

                /** TransferTRC20Contract amount */
                amount?: (Uint8Array|null);
            }

            /** Represents a TransferTRC20Contract. */
            class TransferTRC20Contract implements ITransferTRC20Contract {

                /**
                 * Constructs a new TransferTRC20Contract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ITransferTRC20Contract);

                /** TransferTRC20Contract contractAddress. */
                public contractAddress: string;

                /** TransferTRC20Contract ownerAddress. */
                public ownerAddress: string;

                /** TransferTRC20Contract toAddress. */
                public toAddress: string;

                /** TransferTRC20Contract amount. */
                public amount: Uint8Array;

                /**
                 * Creates a new TransferTRC20Contract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferTRC20Contract instance
                 */
                public static create(properties?: TW.Tron.Proto.ITransferTRC20Contract): TW.Tron.Proto.TransferTRC20Contract;

                /**
                 * Encodes the specified TransferTRC20Contract message. Does not implicitly {@link TW.Tron.Proto.TransferTRC20Contract.verify|verify} messages.
                 * @param message TransferTRC20Contract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ITransferTRC20Contract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferTRC20Contract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferTRC20Contract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.TransferTRC20Contract;

                /**
                 * Verifies a TransferTRC20Contract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferTRC20Contract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferTRC20Contract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.TransferTRC20Contract;

                /**
                 * Creates a plain object from a TransferTRC20Contract message. Also converts values to other types if specified.
                 * @param message TransferTRC20Contract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.TransferTRC20Contract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferTRC20Contract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FreezeBalanceContract. */
            interface IFreezeBalanceContract {

                /** FreezeBalanceContract ownerAddress */
                ownerAddress?: (string|null);

                /** FreezeBalanceContract frozenBalance */
                frozenBalance?: (Long|null);

                /** FreezeBalanceContract frozenDuration */
                frozenDuration?: (Long|null);

                /** FreezeBalanceContract resource */
                resource?: (string|null);

                /** FreezeBalanceContract receiverAddress */
                receiverAddress?: (string|null);
            }

            /** Represents a FreezeBalanceContract. */
            class FreezeBalanceContract implements IFreezeBalanceContract {

                /**
                 * Constructs a new FreezeBalanceContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IFreezeBalanceContract);

                /** FreezeBalanceContract ownerAddress. */
                public ownerAddress: string;

                /** FreezeBalanceContract frozenBalance. */
                public frozenBalance: Long;

                /** FreezeBalanceContract frozenDuration. */
                public frozenDuration: Long;

                /** FreezeBalanceContract resource. */
                public resource: string;

                /** FreezeBalanceContract receiverAddress. */
                public receiverAddress: string;

                /**
                 * Creates a new FreezeBalanceContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FreezeBalanceContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IFreezeBalanceContract): TW.Tron.Proto.FreezeBalanceContract;

                /**
                 * Encodes the specified FreezeBalanceContract message. Does not implicitly {@link TW.Tron.Proto.FreezeBalanceContract.verify|verify} messages.
                 * @param message FreezeBalanceContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IFreezeBalanceContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FreezeBalanceContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FreezeBalanceContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.FreezeBalanceContract;

                /**
                 * Verifies a FreezeBalanceContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FreezeBalanceContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.FreezeBalanceContract;

                /**
                 * Creates a plain object from a FreezeBalanceContract message. Also converts values to other types if specified.
                 * @param message FreezeBalanceContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.FreezeBalanceContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FreezeBalanceContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a FreezeBalanceV2Contract. */
            interface IFreezeBalanceV2Contract {

                /** FreezeBalanceV2Contract ownerAddress */
                ownerAddress?: (string|null);

                /** FreezeBalanceV2Contract frozenBalance */
                frozenBalance?: (Long|null);

                /** FreezeBalanceV2Contract resource */
                resource?: (string|null);
            }

            /** Represents a FreezeBalanceV2Contract. */
            class FreezeBalanceV2Contract implements IFreezeBalanceV2Contract {

                /**
                 * Constructs a new FreezeBalanceV2Contract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IFreezeBalanceV2Contract);

                /** FreezeBalanceV2Contract ownerAddress. */
                public ownerAddress: string;

                /** FreezeBalanceV2Contract frozenBalance. */
                public frozenBalance: Long;

                /** FreezeBalanceV2Contract resource. */
                public resource: string;

                /**
                 * Creates a new FreezeBalanceV2Contract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns FreezeBalanceV2Contract instance
                 */
                public static create(properties?: TW.Tron.Proto.IFreezeBalanceV2Contract): TW.Tron.Proto.FreezeBalanceV2Contract;

                /**
                 * Encodes the specified FreezeBalanceV2Contract message. Does not implicitly {@link TW.Tron.Proto.FreezeBalanceV2Contract.verify|verify} messages.
                 * @param message FreezeBalanceV2Contract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IFreezeBalanceV2Contract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FreezeBalanceV2Contract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns FreezeBalanceV2Contract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.FreezeBalanceV2Contract;

                /**
                 * Verifies a FreezeBalanceV2Contract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a FreezeBalanceV2Contract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns FreezeBalanceV2Contract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.FreezeBalanceV2Contract;

                /**
                 * Creates a plain object from a FreezeBalanceV2Contract message. Also converts values to other types if specified.
                 * @param message FreezeBalanceV2Contract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.FreezeBalanceV2Contract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this FreezeBalanceV2Contract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an UnfreezeBalanceV2Contract. */
            interface IUnfreezeBalanceV2Contract {

                /** UnfreezeBalanceV2Contract ownerAddress */
                ownerAddress?: (string|null);

                /** UnfreezeBalanceV2Contract unfreezeBalance */
                unfreezeBalance?: (Long|null);

                /** UnfreezeBalanceV2Contract resource */
                resource?: (string|null);
            }

            /** Represents an UnfreezeBalanceV2Contract. */
            class UnfreezeBalanceV2Contract implements IUnfreezeBalanceV2Contract {

                /**
                 * Constructs a new UnfreezeBalanceV2Contract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IUnfreezeBalanceV2Contract);

                /** UnfreezeBalanceV2Contract ownerAddress. */
                public ownerAddress: string;

                /** UnfreezeBalanceV2Contract unfreezeBalance. */
                public unfreezeBalance: Long;

                /** UnfreezeBalanceV2Contract resource. */
                public resource: string;

                /**
                 * Creates a new UnfreezeBalanceV2Contract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnfreezeBalanceV2Contract instance
                 */
                public static create(properties?: TW.Tron.Proto.IUnfreezeBalanceV2Contract): TW.Tron.Proto.UnfreezeBalanceV2Contract;

                /**
                 * Encodes the specified UnfreezeBalanceV2Contract message. Does not implicitly {@link TW.Tron.Proto.UnfreezeBalanceV2Contract.verify|verify} messages.
                 * @param message UnfreezeBalanceV2Contract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IUnfreezeBalanceV2Contract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnfreezeBalanceV2Contract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnfreezeBalanceV2Contract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.UnfreezeBalanceV2Contract;

                /**
                 * Verifies an UnfreezeBalanceV2Contract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnfreezeBalanceV2Contract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnfreezeBalanceV2Contract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.UnfreezeBalanceV2Contract;

                /**
                 * Creates a plain object from an UnfreezeBalanceV2Contract message. Also converts values to other types if specified.
                 * @param message UnfreezeBalanceV2Contract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.UnfreezeBalanceV2Contract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnfreezeBalanceV2Contract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a WithdrawExpireUnfreezeContract. */
            interface IWithdrawExpireUnfreezeContract {

                /** WithdrawExpireUnfreezeContract ownerAddress */
                ownerAddress?: (string|null);
            }

            /** Represents a WithdrawExpireUnfreezeContract. */
            class WithdrawExpireUnfreezeContract implements IWithdrawExpireUnfreezeContract {

                /**
                 * Constructs a new WithdrawExpireUnfreezeContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IWithdrawExpireUnfreezeContract);

                /** WithdrawExpireUnfreezeContract ownerAddress. */
                public ownerAddress: string;

                /**
                 * Creates a new WithdrawExpireUnfreezeContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns WithdrawExpireUnfreezeContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IWithdrawExpireUnfreezeContract): TW.Tron.Proto.WithdrawExpireUnfreezeContract;

                /**
                 * Encodes the specified WithdrawExpireUnfreezeContract message. Does not implicitly {@link TW.Tron.Proto.WithdrawExpireUnfreezeContract.verify|verify} messages.
                 * @param message WithdrawExpireUnfreezeContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IWithdrawExpireUnfreezeContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WithdrawExpireUnfreezeContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns WithdrawExpireUnfreezeContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.WithdrawExpireUnfreezeContract;

                /**
                 * Verifies a WithdrawExpireUnfreezeContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WithdrawExpireUnfreezeContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns WithdrawExpireUnfreezeContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.WithdrawExpireUnfreezeContract;

                /**
                 * Creates a plain object from a WithdrawExpireUnfreezeContract message. Also converts values to other types if specified.
                 * @param message WithdrawExpireUnfreezeContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.WithdrawExpireUnfreezeContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this WithdrawExpireUnfreezeContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a DelegateResourceContract. */
            interface IDelegateResourceContract {

                /** DelegateResourceContract ownerAddress */
                ownerAddress?: (string|null);

                /** DelegateResourceContract resource */
                resource?: (string|null);

                /** DelegateResourceContract balance */
                balance?: (Long|null);

                /** DelegateResourceContract receiverAddress */
                receiverAddress?: (string|null);

                /** DelegateResourceContract lock */
                lock?: (boolean|null);
            }

            /** Represents a DelegateResourceContract. */
            class DelegateResourceContract implements IDelegateResourceContract {

                /**
                 * Constructs a new DelegateResourceContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IDelegateResourceContract);

                /** DelegateResourceContract ownerAddress. */
                public ownerAddress: string;

                /** DelegateResourceContract resource. */
                public resource: string;

                /** DelegateResourceContract balance. */
                public balance: Long;

                /** DelegateResourceContract receiverAddress. */
                public receiverAddress: string;

                /** DelegateResourceContract lock. */
                public lock: boolean;

                /**
                 * Creates a new DelegateResourceContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns DelegateResourceContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IDelegateResourceContract): TW.Tron.Proto.DelegateResourceContract;

                /**
                 * Encodes the specified DelegateResourceContract message. Does not implicitly {@link TW.Tron.Proto.DelegateResourceContract.verify|verify} messages.
                 * @param message DelegateResourceContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IDelegateResourceContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DelegateResourceContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns DelegateResourceContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.DelegateResourceContract;

                /**
                 * Verifies a DelegateResourceContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a DelegateResourceContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns DelegateResourceContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.DelegateResourceContract;

                /**
                 * Creates a plain object from a DelegateResourceContract message. Also converts values to other types if specified.
                 * @param message DelegateResourceContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.DelegateResourceContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this DelegateResourceContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an UnDelegateResourceContract. */
            interface IUnDelegateResourceContract {

                /** UnDelegateResourceContract ownerAddress */
                ownerAddress?: (string|null);

                /** UnDelegateResourceContract resource */
                resource?: (string|null);

                /** UnDelegateResourceContract balance */
                balance?: (Long|null);

                /** UnDelegateResourceContract receiverAddress */
                receiverAddress?: (string|null);
            }

            /** Represents an UnDelegateResourceContract. */
            class UnDelegateResourceContract implements IUnDelegateResourceContract {

                /**
                 * Constructs a new UnDelegateResourceContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IUnDelegateResourceContract);

                /** UnDelegateResourceContract ownerAddress. */
                public ownerAddress: string;

                /** UnDelegateResourceContract resource. */
                public resource: string;

                /** UnDelegateResourceContract balance. */
                public balance: Long;

                /** UnDelegateResourceContract receiverAddress. */
                public receiverAddress: string;

                /**
                 * Creates a new UnDelegateResourceContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnDelegateResourceContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IUnDelegateResourceContract): TW.Tron.Proto.UnDelegateResourceContract;

                /**
                 * Encodes the specified UnDelegateResourceContract message. Does not implicitly {@link TW.Tron.Proto.UnDelegateResourceContract.verify|verify} messages.
                 * @param message UnDelegateResourceContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IUnDelegateResourceContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnDelegateResourceContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnDelegateResourceContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.UnDelegateResourceContract;

                /**
                 * Verifies an UnDelegateResourceContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnDelegateResourceContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnDelegateResourceContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.UnDelegateResourceContract;

                /**
                 * Creates a plain object from an UnDelegateResourceContract message. Also converts values to other types if specified.
                 * @param message UnDelegateResourceContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.UnDelegateResourceContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnDelegateResourceContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an UnfreezeBalanceContract. */
            interface IUnfreezeBalanceContract {

                /** UnfreezeBalanceContract ownerAddress */
                ownerAddress?: (string|null);

                /** UnfreezeBalanceContract resource */
                resource?: (string|null);

                /** UnfreezeBalanceContract receiverAddress */
                receiverAddress?: (string|null);
            }

            /** Represents an UnfreezeBalanceContract. */
            class UnfreezeBalanceContract implements IUnfreezeBalanceContract {

                /**
                 * Constructs a new UnfreezeBalanceContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IUnfreezeBalanceContract);

                /** UnfreezeBalanceContract ownerAddress. */
                public ownerAddress: string;

                /** UnfreezeBalanceContract resource. */
                public resource: string;

                /** UnfreezeBalanceContract receiverAddress. */
                public receiverAddress: string;

                /**
                 * Creates a new UnfreezeBalanceContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnfreezeBalanceContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IUnfreezeBalanceContract): TW.Tron.Proto.UnfreezeBalanceContract;

                /**
                 * Encodes the specified UnfreezeBalanceContract message. Does not implicitly {@link TW.Tron.Proto.UnfreezeBalanceContract.verify|verify} messages.
                 * @param message UnfreezeBalanceContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IUnfreezeBalanceContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnfreezeBalanceContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnfreezeBalanceContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.UnfreezeBalanceContract;

                /**
                 * Verifies an UnfreezeBalanceContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnfreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnfreezeBalanceContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.UnfreezeBalanceContract;

                /**
                 * Creates a plain object from an UnfreezeBalanceContract message. Also converts values to other types if specified.
                 * @param message UnfreezeBalanceContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.UnfreezeBalanceContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnfreezeBalanceContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of an UnfreezeAssetContract. */
            interface IUnfreezeAssetContract {

                /** UnfreezeAssetContract ownerAddress */
                ownerAddress?: (string|null);
            }

            /** Represents an UnfreezeAssetContract. */
            class UnfreezeAssetContract implements IUnfreezeAssetContract {

                /**
                 * Constructs a new UnfreezeAssetContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IUnfreezeAssetContract);

                /** UnfreezeAssetContract ownerAddress. */
                public ownerAddress: string;

                /**
                 * Creates a new UnfreezeAssetContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns UnfreezeAssetContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IUnfreezeAssetContract): TW.Tron.Proto.UnfreezeAssetContract;

                /**
                 * Encodes the specified UnfreezeAssetContract message. Does not implicitly {@link TW.Tron.Proto.UnfreezeAssetContract.verify|verify} messages.
                 * @param message UnfreezeAssetContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IUnfreezeAssetContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an UnfreezeAssetContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns UnfreezeAssetContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.UnfreezeAssetContract;

                /**
                 * Verifies an UnfreezeAssetContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates an UnfreezeAssetContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns UnfreezeAssetContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.UnfreezeAssetContract;

                /**
                 * Creates a plain object from an UnfreezeAssetContract message. Also converts values to other types if specified.
                 * @param message UnfreezeAssetContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.UnfreezeAssetContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this UnfreezeAssetContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a VoteAssetContract. */
            interface IVoteAssetContract {

                /** VoteAssetContract ownerAddress */
                ownerAddress?: (string|null);

                /** VoteAssetContract voteAddress */
                voteAddress?: (string[]|null);

                /** VoteAssetContract support */
                support?: (boolean|null);

                /** VoteAssetContract count */
                count?: (number|null);
            }

            /** Represents a VoteAssetContract. */
            class VoteAssetContract implements IVoteAssetContract {

                /**
                 * Constructs a new VoteAssetContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IVoteAssetContract);

                /** VoteAssetContract ownerAddress. */
                public ownerAddress: string;

                /** VoteAssetContract voteAddress. */
                public voteAddress: string[];

                /** VoteAssetContract support. */
                public support: boolean;

                /** VoteAssetContract count. */
                public count: number;

                /**
                 * Creates a new VoteAssetContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns VoteAssetContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IVoteAssetContract): TW.Tron.Proto.VoteAssetContract;

                /**
                 * Encodes the specified VoteAssetContract message. Does not implicitly {@link TW.Tron.Proto.VoteAssetContract.verify|verify} messages.
                 * @param message VoteAssetContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IVoteAssetContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a VoteAssetContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns VoteAssetContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.VoteAssetContract;

                /**
                 * Verifies a VoteAssetContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a VoteAssetContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns VoteAssetContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.VoteAssetContract;

                /**
                 * Creates a plain object from a VoteAssetContract message. Also converts values to other types if specified.
                 * @param message VoteAssetContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.VoteAssetContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this VoteAssetContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a VoteWitnessContract. */
            interface IVoteWitnessContract {

                /** VoteWitnessContract ownerAddress */
                ownerAddress?: (string|null);

                /** VoteWitnessContract votes */
                votes?: (TW.Tron.Proto.VoteWitnessContract.IVote[]|null);

                /** VoteWitnessContract support */
                support?: (boolean|null);
            }

            /** Represents a VoteWitnessContract. */
            class VoteWitnessContract implements IVoteWitnessContract {

                /**
                 * Constructs a new VoteWitnessContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IVoteWitnessContract);

                /** VoteWitnessContract ownerAddress. */
                public ownerAddress: string;

                /** VoteWitnessContract votes. */
                public votes: TW.Tron.Proto.VoteWitnessContract.IVote[];

                /** VoteWitnessContract support. */
                public support: boolean;

                /**
                 * Creates a new VoteWitnessContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns VoteWitnessContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IVoteWitnessContract): TW.Tron.Proto.VoteWitnessContract;

                /**
                 * Encodes the specified VoteWitnessContract message. Does not implicitly {@link TW.Tron.Proto.VoteWitnessContract.verify|verify} messages.
                 * @param message VoteWitnessContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IVoteWitnessContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a VoteWitnessContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns VoteWitnessContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.VoteWitnessContract;

                /**
                 * Verifies a VoteWitnessContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a VoteWitnessContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns VoteWitnessContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.VoteWitnessContract;

                /**
                 * Creates a plain object from a VoteWitnessContract message. Also converts values to other types if specified.
                 * @param message VoteWitnessContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.VoteWitnessContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this VoteWitnessContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace VoteWitnessContract {

                /** Properties of a Vote. */
                interface IVote {

                    /** Vote voteAddress */
                    voteAddress?: (string|null);

                    /** Vote voteCount */
                    voteCount?: (Long|null);
                }

                /** Represents a Vote. */
                class Vote implements IVote {

                    /**
                     * Constructs a new Vote.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Tron.Proto.VoteWitnessContract.IVote);

                    /** Vote voteAddress. */
                    public voteAddress: string;

                    /** Vote voteCount. */
                    public voteCount: Long;

                    /**
                     * Creates a new Vote instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Vote instance
                     */
                    public static create(properties?: TW.Tron.Proto.VoteWitnessContract.IVote): TW.Tron.Proto.VoteWitnessContract.Vote;

                    /**
                     * Encodes the specified Vote message. Does not implicitly {@link TW.Tron.Proto.VoteWitnessContract.Vote.verify|verify} messages.
                     * @param message Vote message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Tron.Proto.VoteWitnessContract.IVote, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Vote message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Vote
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.VoteWitnessContract.Vote;

                    /**
                     * Verifies a Vote message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Vote message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Vote
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.VoteWitnessContract.Vote;

                    /**
                     * Creates a plain object from a Vote message. Also converts values to other types if specified.
                     * @param message Vote
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Tron.Proto.VoteWitnessContract.Vote, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Vote to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a WithdrawBalanceContract. */
            interface IWithdrawBalanceContract {

                /** WithdrawBalanceContract ownerAddress */
                ownerAddress?: (string|null);
            }

            /** Represents a WithdrawBalanceContract. */
            class WithdrawBalanceContract implements IWithdrawBalanceContract {

                /**
                 * Constructs a new WithdrawBalanceContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IWithdrawBalanceContract);

                /** WithdrawBalanceContract ownerAddress. */
                public ownerAddress: string;

                /**
                 * Creates a new WithdrawBalanceContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns WithdrawBalanceContract instance
                 */
                public static create(properties?: TW.Tron.Proto.IWithdrawBalanceContract): TW.Tron.Proto.WithdrawBalanceContract;

                /**
                 * Encodes the specified WithdrawBalanceContract message. Does not implicitly {@link TW.Tron.Proto.WithdrawBalanceContract.verify|verify} messages.
                 * @param message WithdrawBalanceContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IWithdrawBalanceContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WithdrawBalanceContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns WithdrawBalanceContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.WithdrawBalanceContract;

                /**
                 * Verifies a WithdrawBalanceContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a WithdrawBalanceContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns WithdrawBalanceContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.WithdrawBalanceContract;

                /**
                 * Creates a plain object from a WithdrawBalanceContract message. Also converts values to other types if specified.
                 * @param message WithdrawBalanceContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.WithdrawBalanceContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this WithdrawBalanceContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a TriggerSmartContract. */
            interface ITriggerSmartContract {

                /** TriggerSmartContract ownerAddress */
                ownerAddress?: (string|null);

                /** TriggerSmartContract contractAddress */
                contractAddress?: (string|null);

                /** TriggerSmartContract callValue */
                callValue?: (Long|null);

                /** TriggerSmartContract data */
                data?: (Uint8Array|null);

                /** TriggerSmartContract callTokenValue */
                callTokenValue?: (Long|null);

                /** TriggerSmartContract tokenId */
                tokenId?: (Long|null);
            }

            /** Represents a TriggerSmartContract. */
            class TriggerSmartContract implements ITriggerSmartContract {

                /**
                 * Constructs a new TriggerSmartContract.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ITriggerSmartContract);

                /** TriggerSmartContract ownerAddress. */
                public ownerAddress: string;

                /** TriggerSmartContract contractAddress. */
                public contractAddress: string;

                /** TriggerSmartContract callValue. */
                public callValue: Long;

                /** TriggerSmartContract data. */
                public data: Uint8Array;

                /** TriggerSmartContract callTokenValue. */
                public callTokenValue: Long;

                /** TriggerSmartContract tokenId. */
                public tokenId: Long;

                /**
                 * Creates a new TriggerSmartContract instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TriggerSmartContract instance
                 */
                public static create(properties?: TW.Tron.Proto.ITriggerSmartContract): TW.Tron.Proto.TriggerSmartContract;

                /**
                 * Encodes the specified TriggerSmartContract message. Does not implicitly {@link TW.Tron.Proto.TriggerSmartContract.verify|verify} messages.
                 * @param message TriggerSmartContract message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ITriggerSmartContract, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TriggerSmartContract message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TriggerSmartContract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.TriggerSmartContract;

                /**
                 * Verifies a TriggerSmartContract message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TriggerSmartContract message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TriggerSmartContract
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.TriggerSmartContract;

                /**
                 * Creates a plain object from a TriggerSmartContract message. Also converts values to other types if specified.
                 * @param message TriggerSmartContract
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.TriggerSmartContract, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TriggerSmartContract to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a BlockHeader. */
            interface IBlockHeader {

                /** BlockHeader timestamp */
                timestamp?: (Long|null);

                /** BlockHeader txTrieRoot */
                txTrieRoot?: (Uint8Array|null);

                /** BlockHeader parentHash */
                parentHash?: (Uint8Array|null);

                /** BlockHeader number */
                number?: (Long|null);

                /** BlockHeader witnessAddress */
                witnessAddress?: (Uint8Array|null);

                /** BlockHeader version */
                version?: (number|null);
            }

            /** Represents a BlockHeader. */
            class BlockHeader implements IBlockHeader {

                /**
                 * Constructs a new BlockHeader.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.IBlockHeader);

                /** BlockHeader timestamp. */
                public timestamp: Long;

                /** BlockHeader txTrieRoot. */
                public txTrieRoot: Uint8Array;

                /** BlockHeader parentHash. */
                public parentHash: Uint8Array;

                /** BlockHeader number. */
                public number: Long;

                /** BlockHeader witnessAddress. */
                public witnessAddress: Uint8Array;

                /** BlockHeader version. */
                public version: number;

                /**
                 * Creates a new BlockHeader instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns BlockHeader instance
                 */
                public static create(properties?: TW.Tron.Proto.IBlockHeader): TW.Tron.Proto.BlockHeader;

                /**
                 * Encodes the specified BlockHeader message. Does not implicitly {@link TW.Tron.Proto.BlockHeader.verify|verify} messages.
                 * @param message BlockHeader message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.IBlockHeader, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BlockHeader message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns BlockHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.BlockHeader;

                /**
                 * Verifies a BlockHeader message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns BlockHeader
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.BlockHeader;

                /**
                 * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
                 * @param message BlockHeader
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.BlockHeader, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this BlockHeader to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction timestamp */
                timestamp?: (Long|null);

                /** Transaction expiration */
                expiration?: (Long|null);

                /** Transaction blockHeader */
                blockHeader?: (TW.Tron.Proto.IBlockHeader|null);

                /** Transaction feeLimit */
                feeLimit?: (Long|null);

                /** Transaction transfer */
                transfer?: (TW.Tron.Proto.ITransferContract|null);

                /** Transaction transferAsset */
                transferAsset?: (TW.Tron.Proto.ITransferAssetContract|null);

                /** Transaction freezeBalance */
                freezeBalance?: (TW.Tron.Proto.IFreezeBalanceContract|null);

                /** Transaction unfreezeBalance */
                unfreezeBalance?: (TW.Tron.Proto.IUnfreezeBalanceContract|null);

                /** Transaction unfreezeAsset */
                unfreezeAsset?: (TW.Tron.Proto.IUnfreezeAssetContract|null);

                /** Transaction withdrawBalance */
                withdrawBalance?: (TW.Tron.Proto.IWithdrawBalanceContract|null);

                /** Transaction voteAsset */
                voteAsset?: (TW.Tron.Proto.IVoteAssetContract|null);

                /** Transaction voteWitness */
                voteWitness?: (TW.Tron.Proto.IVoteWitnessContract|null);

                /** Transaction triggerSmartContract */
                triggerSmartContract?: (TW.Tron.Proto.ITriggerSmartContract|null);

                /** Transaction transferTrc20Contract */
                transferTrc20Contract?: (TW.Tron.Proto.ITransferTRC20Contract|null);

                /** Transaction freezeBalanceV2 */
                freezeBalanceV2?: (TW.Tron.Proto.IFreezeBalanceV2Contract|null);

                /** Transaction unfreezeBalanceV2 */
                unfreezeBalanceV2?: (TW.Tron.Proto.IUnfreezeBalanceV2Contract|null);

                /** Transaction withdrawExpireUnfreeze */
                withdrawExpireUnfreeze?: (TW.Tron.Proto.IWithdrawExpireUnfreezeContract|null);

                /** Transaction delegateResource */
                delegateResource?: (TW.Tron.Proto.IDelegateResourceContract|null);

                /** Transaction undelegateResource */
                undelegateResource?: (TW.Tron.Proto.IUnDelegateResourceContract|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ITransaction);

                /** Transaction timestamp. */
                public timestamp: Long;

                /** Transaction expiration. */
                public expiration: Long;

                /** Transaction blockHeader. */
                public blockHeader?: (TW.Tron.Proto.IBlockHeader|null);

                /** Transaction feeLimit. */
                public feeLimit: Long;

                /** Transaction transfer. */
                public transfer?: (TW.Tron.Proto.ITransferContract|null);

                /** Transaction transferAsset. */
                public transferAsset?: (TW.Tron.Proto.ITransferAssetContract|null);

                /** Transaction freezeBalance. */
                public freezeBalance?: (TW.Tron.Proto.IFreezeBalanceContract|null);

                /** Transaction unfreezeBalance. */
                public unfreezeBalance?: (TW.Tron.Proto.IUnfreezeBalanceContract|null);

                /** Transaction unfreezeAsset. */
                public unfreezeAsset?: (TW.Tron.Proto.IUnfreezeAssetContract|null);

                /** Transaction withdrawBalance. */
                public withdrawBalance?: (TW.Tron.Proto.IWithdrawBalanceContract|null);

                /** Transaction voteAsset. */
                public voteAsset?: (TW.Tron.Proto.IVoteAssetContract|null);

                /** Transaction voteWitness. */
                public voteWitness?: (TW.Tron.Proto.IVoteWitnessContract|null);

                /** Transaction triggerSmartContract. */
                public triggerSmartContract?: (TW.Tron.Proto.ITriggerSmartContract|null);

                /** Transaction transferTrc20Contract. */
                public transferTrc20Contract?: (TW.Tron.Proto.ITransferTRC20Contract|null);

                /** Transaction freezeBalanceV2. */
                public freezeBalanceV2?: (TW.Tron.Proto.IFreezeBalanceV2Contract|null);

                /** Transaction unfreezeBalanceV2. */
                public unfreezeBalanceV2?: (TW.Tron.Proto.IUnfreezeBalanceV2Contract|null);

                /** Transaction withdrawExpireUnfreeze. */
                public withdrawExpireUnfreeze?: (TW.Tron.Proto.IWithdrawExpireUnfreezeContract|null);

                /** Transaction delegateResource. */
                public delegateResource?: (TW.Tron.Proto.IDelegateResourceContract|null);

                /** Transaction undelegateResource. */
                public undelegateResource?: (TW.Tron.Proto.IUnDelegateResourceContract|null);

                /** Transaction contractOneof. */
                public contractOneof?: ("transfer"|"transferAsset"|"freezeBalance"|"unfreezeBalance"|"unfreezeAsset"|"withdrawBalance"|"voteAsset"|"voteWitness"|"triggerSmartContract"|"transferTrc20Contract"|"freezeBalanceV2"|"unfreezeBalanceV2"|"withdrawExpireUnfreeze"|"delegateResource"|"undelegateResource");

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Tron.Proto.ITransaction): TW.Tron.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Tron.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput transaction */
                transaction?: (TW.Tron.Proto.ITransaction|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput txId */
                txId?: (string|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ISigningInput);

                /** SigningInput transaction. */
                public transaction?: (TW.Tron.Proto.ITransaction|null);

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput txId. */
                public txId: string;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Tron.Proto.ISigningInput): TW.Tron.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tron.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput id */
                id?: (Uint8Array|null);

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput refBlockBytes */
                refBlockBytes?: (Uint8Array|null);

                /** SigningOutput refBlockHash */
                refBlockHash?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Tron.Proto.ISigningOutput);

                /** SigningOutput id. */
                public id: Uint8Array;

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput refBlockBytes. */
                public refBlockBytes: Uint8Array;

                /** SigningOutput refBlockHash. */
                public refBlockHash: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Tron.Proto.ISigningOutput): TW.Tron.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tron.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Tron.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Tron.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Tron.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Tron.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace VeChain. */
    namespace VeChain {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Clause. */
            interface IClause {

                /** Recipient address. */
                to?: (string|null);

                /** Transaction amount (uint256, serialized little endian) */
                value?: (Uint8Array|null);

                /** Payload data. */
                data?: (Uint8Array|null);
            }

            /** Represents a Clause. */
            class Clause implements IClause {

                /**
                 * Constructs a new Clause.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.VeChain.Proto.IClause);

                /** Recipient address. */
                public to: string;

                /** Transaction amount (uint256, serialized little endian) */
                public value: Uint8Array;

                /** Payload data. */
                public data: Uint8Array;

                /**
                 * Creates a new Clause instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Clause instance
                 */
                public static create(properties?: TW.VeChain.Proto.IClause): TW.VeChain.Proto.Clause;

                /**
                 * Encodes the specified Clause message. Does not implicitly {@link TW.VeChain.Proto.Clause.verify|verify} messages.
                 * @param message Clause message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.VeChain.Proto.IClause, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Clause message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Clause
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.VeChain.Proto.Clause;

                /**
                 * Verifies a Clause message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Clause message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Clause
                 */
                public static fromObject(object: { [k: string]: any }): TW.VeChain.Proto.Clause;

                /**
                 * Creates a plain object from a Clause message. Also converts values to other types if specified.
                 * @param message Clause
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.VeChain.Proto.Clause, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Clause to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack. */
                chainTag?: (number|null);

                /** Reference to a specific block. */
                blockRef?: (Long|null);

                /** How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor. */
                expiration?: (number|null);

                /** by the transaction sender. */
                clauses?: (TW.VeChain.Proto.IClause[]|null);

                /** Coefficient used to calculate the gas price for the transaction. */
                gasPriceCoef?: (number|null);

                /** Maximum amount of gas allowed to pay for the transaction. */
                gas?: (Long|null);

                /** ID of the transaction on which the current transaction depends. */
                dependsOn?: (Uint8Array|null);

                /** Number set by user. */
                nonce?: (Long|null);

                /** The secret private key used for signing (32 bytes). */
                privateKey?: (Uint8Array|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.VeChain.Proto.ISigningInput);

                /** Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack. */
                public chainTag: number;

                /** Reference to a specific block. */
                public blockRef: Long;

                /** How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor. */
                public expiration: number;

                /** by the transaction sender. */
                public clauses: TW.VeChain.Proto.IClause[];

                /** Coefficient used to calculate the gas price for the transaction. */
                public gasPriceCoef: number;

                /** Maximum amount of gas allowed to pay for the transaction. */
                public gas: Long;

                /** ID of the transaction on which the current transaction depends. */
                public dependsOn: Uint8Array;

                /** Number set by user. */
                public nonce: Long;

                /** The secret private key used for signing (32 bytes). */
                public privateKey: Uint8Array;

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.VeChain.Proto.ISigningInput): TW.VeChain.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.VeChain.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.VeChain.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.VeChain.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.VeChain.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.VeChain.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput encoded */
                encoded?: (Uint8Array|null);

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput error */
                error?: (TW.Common.Proto.SigningError|null);

                /** SigningOutput errorMessage */
                errorMessage?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.VeChain.Proto.ISigningOutput);

                /** SigningOutput encoded. */
                public encoded: Uint8Array;

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput error. */
                public error: TW.Common.Proto.SigningError;

                /** SigningOutput errorMessage. */
                public errorMessage: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.VeChain.Proto.ISigningOutput): TW.VeChain.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.VeChain.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.VeChain.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.VeChain.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.VeChain.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.VeChain.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Waves. */
    namespace Waves {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a TransferMessage. */
            interface ITransferMessage {

                /** TransferMessage amount */
                amount?: (Long|null);

                /** TransferMessage asset */
                asset?: (string|null);

                /** TransferMessage fee */
                fee?: (Long|null);

                /** TransferMessage feeAsset */
                feeAsset?: (string|null);

                /** TransferMessage to */
                to?: (string|null);

                /** TransferMessage attachment */
                attachment?: (Uint8Array|null);
            }

            /** Represents a TransferMessage. */
            class TransferMessage implements ITransferMessage {

                /**
                 * Constructs a new TransferMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Waves.Proto.ITransferMessage);

                /** TransferMessage amount. */
                public amount: Long;

                /** TransferMessage asset. */
                public asset: string;

                /** TransferMessage fee. */
                public fee: Long;

                /** TransferMessage feeAsset. */
                public feeAsset: string;

                /** TransferMessage to. */
                public to: string;

                /** TransferMessage attachment. */
                public attachment: Uint8Array;

                /**
                 * Creates a new TransferMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns TransferMessage instance
                 */
                public static create(properties?: TW.Waves.Proto.ITransferMessage): TW.Waves.Proto.TransferMessage;

                /**
                 * Encodes the specified TransferMessage message. Does not implicitly {@link TW.Waves.Proto.TransferMessage.verify|verify} messages.
                 * @param message TransferMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Waves.Proto.ITransferMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a TransferMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns TransferMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Waves.Proto.TransferMessage;

                /**
                 * Verifies a TransferMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a TransferMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns TransferMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Waves.Proto.TransferMessage;

                /**
                 * Creates a plain object from a TransferMessage message. Also converts values to other types if specified.
                 * @param message TransferMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Waves.Proto.TransferMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this TransferMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a LeaseMessage. */
            interface ILeaseMessage {

                /** LeaseMessage amount */
                amount?: (Long|null);

                /** LeaseMessage to */
                to?: (string|null);

                /** LeaseMessage fee */
                fee?: (Long|null);
            }

            /** Represents a LeaseMessage. */
            class LeaseMessage implements ILeaseMessage {

                /**
                 * Constructs a new LeaseMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Waves.Proto.ILeaseMessage);

                /** LeaseMessage amount. */
                public amount: Long;

                /** LeaseMessage to. */
                public to: string;

                /** LeaseMessage fee. */
                public fee: Long;

                /**
                 * Creates a new LeaseMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns LeaseMessage instance
                 */
                public static create(properties?: TW.Waves.Proto.ILeaseMessage): TW.Waves.Proto.LeaseMessage;

                /**
                 * Encodes the specified LeaseMessage message. Does not implicitly {@link TW.Waves.Proto.LeaseMessage.verify|verify} messages.
                 * @param message LeaseMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Waves.Proto.ILeaseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LeaseMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns LeaseMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Waves.Proto.LeaseMessage;

                /**
                 * Verifies a LeaseMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a LeaseMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns LeaseMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Waves.Proto.LeaseMessage;

                /**
                 * Creates a plain object from a LeaseMessage message. Also converts values to other types if specified.
                 * @param message LeaseMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Waves.Proto.LeaseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this LeaseMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a CancelLeaseMessage. */
            interface ICancelLeaseMessage {

                /** CancelLeaseMessage leaseId */
                leaseId?: (string|null);

                /** CancelLeaseMessage fee */
                fee?: (Long|null);
            }

            /** Represents a CancelLeaseMessage. */
            class CancelLeaseMessage implements ICancelLeaseMessage {

                /**
                 * Constructs a new CancelLeaseMessage.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Waves.Proto.ICancelLeaseMessage);

                /** CancelLeaseMessage leaseId. */
                public leaseId: string;

                /** CancelLeaseMessage fee. */
                public fee: Long;

                /**
                 * Creates a new CancelLeaseMessage instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns CancelLeaseMessage instance
                 */
                public static create(properties?: TW.Waves.Proto.ICancelLeaseMessage): TW.Waves.Proto.CancelLeaseMessage;

                /**
                 * Encodes the specified CancelLeaseMessage message. Does not implicitly {@link TW.Waves.Proto.CancelLeaseMessage.verify|verify} messages.
                 * @param message CancelLeaseMessage message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Waves.Proto.ICancelLeaseMessage, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CancelLeaseMessage message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns CancelLeaseMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Waves.Proto.CancelLeaseMessage;

                /**
                 * Verifies a CancelLeaseMessage message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a CancelLeaseMessage message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns CancelLeaseMessage
                 */
                public static fromObject(object: { [k: string]: any }): TW.Waves.Proto.CancelLeaseMessage;

                /**
                 * Creates a plain object from a CancelLeaseMessage message. Also converts values to other types if specified.
                 * @param message CancelLeaseMessage
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Waves.Proto.CancelLeaseMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this CancelLeaseMessage to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput timestamp */
                timestamp?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transferMessage */
                transferMessage?: (TW.Waves.Proto.ITransferMessage|null);

                /** SigningInput leaseMessage */
                leaseMessage?: (TW.Waves.Proto.ILeaseMessage|null);

                /** SigningInput cancelLeaseMessage */
                cancelLeaseMessage?: (TW.Waves.Proto.ICancelLeaseMessage|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Waves.Proto.ISigningInput);

                /** SigningInput timestamp. */
                public timestamp: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transferMessage. */
                public transferMessage?: (TW.Waves.Proto.ITransferMessage|null);

                /** SigningInput leaseMessage. */
                public leaseMessage?: (TW.Waves.Proto.ILeaseMessage|null);

                /** SigningInput cancelLeaseMessage. */
                public cancelLeaseMessage?: (TW.Waves.Proto.ICancelLeaseMessage|null);

                /** SigningInput messageOneof. */
                public messageOneof?: ("transferMessage"|"leaseMessage"|"cancelLeaseMessage");

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Waves.Proto.ISigningInput): TW.Waves.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Waves.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Waves.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Waves.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Waves.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Waves.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Waves.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Waves.Proto.ISigningOutput): TW.Waves.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Waves.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Waves.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Waves.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Waves.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Waves.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /** Namespace Zilliqa. */
    namespace Zilliqa {

        /** Namespace Proto. */
        namespace Proto {

            /** Properties of a Transaction. */
            interface ITransaction {

                /** Transaction transfer */
                transfer?: (TW.Zilliqa.Proto.Transaction.ITransfer|null);

                /** Transaction rawTransaction */
                rawTransaction?: (TW.Zilliqa.Proto.Transaction.IRaw|null);
            }

            /** Represents a Transaction. */
            class Transaction implements ITransaction {

                /**
                 * Constructs a new Transaction.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Zilliqa.Proto.ITransaction);

                /** Transaction transfer. */
                public transfer?: (TW.Zilliqa.Proto.Transaction.ITransfer|null);

                /** Transaction rawTransaction. */
                public rawTransaction?: (TW.Zilliqa.Proto.Transaction.IRaw|null);

                /** Transaction messageOneof. */
                public messageOneof?: ("transfer"|"rawTransaction");

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns Transaction instance
                 */
                public static create(properties?: TW.Zilliqa.Proto.ITransaction): TW.Zilliqa.Proto.Transaction;

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.verify|verify} messages.
                 * @param message Transaction message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Zilliqa.Proto.ITransaction, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Zilliqa.Proto.Transaction;

                /**
                 * Verifies a Transaction message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns Transaction
                 */
                public static fromObject(object: { [k: string]: any }): TW.Zilliqa.Proto.Transaction;

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @param message Transaction
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Zilliqa.Proto.Transaction, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this Transaction to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Transaction {

                /** Properties of a Transfer. */
                interface ITransfer {

                    /** Transfer amount */
                    amount?: (Uint8Array|null);
                }

                /** Represents a Transfer. */
                class Transfer implements ITransfer {

                    /**
                     * Constructs a new Transfer.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Zilliqa.Proto.Transaction.ITransfer);

                    /** Transfer amount. */
                    public amount: Uint8Array;

                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Transfer instance
                     */
                    public static create(properties?: TW.Zilliqa.Proto.Transaction.ITransfer): TW.Zilliqa.Proto.Transaction.Transfer;

                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.Transfer.verify|verify} messages.
                     * @param message Transfer message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Zilliqa.Proto.Transaction.ITransfer, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Zilliqa.Proto.Transaction.Transfer;

                    /**
                     * Verifies a Transfer message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Transfer
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Zilliqa.Proto.Transaction.Transfer;

                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @param message Transfer
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Zilliqa.Proto.Transaction.Transfer, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Transfer to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                /** Properties of a Raw. */
                interface IRaw {

                    /** Raw amount */
                    amount?: (Uint8Array|null);

                    /** Raw code */
                    code?: (Uint8Array|null);

                    /** Raw data */
                    data?: (Uint8Array|null);
                }

                /** Represents a Raw. */
                class Raw implements IRaw {

                    /**
                     * Constructs a new Raw.
                     * @param [properties] Properties to set
                     */
                    constructor(properties?: TW.Zilliqa.Proto.Transaction.IRaw);

                    /** Raw amount. */
                    public amount: Uint8Array;

                    /** Raw code. */
                    public code: Uint8Array;

                    /** Raw data. */
                    public data: Uint8Array;

                    /**
                     * Creates a new Raw instance using the specified properties.
                     * @param [properties] Properties to set
                     * @returns Raw instance
                     */
                    public static create(properties?: TW.Zilliqa.Proto.Transaction.IRaw): TW.Zilliqa.Proto.Transaction.Raw;

                    /**
                     * Encodes the specified Raw message. Does not implicitly {@link TW.Zilliqa.Proto.Transaction.Raw.verify|verify} messages.
                     * @param message Raw message or plain object to encode
                     * @param [writer] Writer to encode to
                     * @returns Writer
                     */
                    public static encode(message: TW.Zilliqa.Proto.Transaction.IRaw, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Raw message from the specified reader or buffer.
                     * @param reader Reader or buffer to decode from
                     * @param [length] Message length if known beforehand
                     * @returns Raw
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Zilliqa.Proto.Transaction.Raw;

                    /**
                     * Verifies a Raw message.
                     * @param message Plain object to verify
                     * @returns `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): (string|null);

                    /**
                     * Creates a Raw message from a plain object. Also converts values to their respective internal types.
                     * @param object Plain object
                     * @returns Raw
                     */
                    public static fromObject(object: { [k: string]: any }): TW.Zilliqa.Proto.Transaction.Raw;

                    /**
                     * Creates a plain object from a Raw message. Also converts values to other types if specified.
                     * @param message Raw
                     * @param [options] Conversion options
                     * @returns Plain object
                     */
                    public static toObject(message: TW.Zilliqa.Proto.Transaction.Raw, options?: $protobuf.IConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Raw to JSON.
                     * @returns JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            /** Properties of a SigningInput. */
            interface ISigningInput {

                /** SigningInput version */
                version?: (number|null);

                /** SigningInput nonce */
                nonce?: (Long|null);

                /** SigningInput to */
                to?: (string|null);

                /** SigningInput gasPrice */
                gasPrice?: (Uint8Array|null);

                /** SigningInput gasLimit */
                gasLimit?: (Long|null);

                /** SigningInput privateKey */
                privateKey?: (Uint8Array|null);

                /** SigningInput transaction */
                transaction?: (TW.Zilliqa.Proto.ITransaction|null);
            }

            /** Represents a SigningInput. */
            class SigningInput implements ISigningInput {

                /**
                 * Constructs a new SigningInput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Zilliqa.Proto.ISigningInput);

                /** SigningInput version. */
                public version: number;

                /** SigningInput nonce. */
                public nonce: Long;

                /** SigningInput to. */
                public to: string;

                /** SigningInput gasPrice. */
                public gasPrice: Uint8Array;

                /** SigningInput gasLimit. */
                public gasLimit: Long;

                /** SigningInput privateKey. */
                public privateKey: Uint8Array;

                /** SigningInput transaction. */
                public transaction?: (TW.Zilliqa.Proto.ITransaction|null);

                /**
                 * Creates a new SigningInput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningInput instance
                 */
                public static create(properties?: TW.Zilliqa.Proto.ISigningInput): TW.Zilliqa.Proto.SigningInput;

                /**
                 * Encodes the specified SigningInput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningInput.verify|verify} messages.
                 * @param message SigningInput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Zilliqa.Proto.ISigningInput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningInput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningInput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Zilliqa.Proto.SigningInput;

                /**
                 * Verifies a SigningInput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningInput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Zilliqa.Proto.SigningInput;

                /**
                 * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                 * @param message SigningInput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Zilliqa.Proto.SigningInput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningInput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            /** Properties of a SigningOutput. */
            interface ISigningOutput {

                /** SigningOutput signature */
                signature?: (Uint8Array|null);

                /** SigningOutput json */
                json?: (string|null);
            }

            /** Represents a SigningOutput. */
            class SigningOutput implements ISigningOutput {

                /**
                 * Constructs a new SigningOutput.
                 * @param [properties] Properties to set
                 */
                constructor(properties?: TW.Zilliqa.Proto.ISigningOutput);

                /** SigningOutput signature. */
                public signature: Uint8Array;

                /** SigningOutput json. */
                public json: string;

                /**
                 * Creates a new SigningOutput instance using the specified properties.
                 * @param [properties] Properties to set
                 * @returns SigningOutput instance
                 */
                public static create(properties?: TW.Zilliqa.Proto.ISigningOutput): TW.Zilliqa.Proto.SigningOutput;

                /**
                 * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningOutput.verify|verify} messages.
                 * @param message SigningOutput message or plain object to encode
                 * @param [writer] Writer to encode to
                 * @returns Writer
                 */
                public static encode(message: TW.Zilliqa.Proto.ISigningOutput, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SigningOutput message from the specified reader or buffer.
                 * @param reader Reader or buffer to decode from
                 * @param [length] Message length if known beforehand
                 * @returns SigningOutput
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TW.Zilliqa.Proto.SigningOutput;

                /**
                 * Verifies a SigningOutput message.
                 * @param message Plain object to verify
                 * @returns `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): (string|null);

                /**
                 * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                 * @param object Plain object
                 * @returns SigningOutput
                 */
                public static fromObject(object: { [k: string]: any }): TW.Zilliqa.Proto.SigningOutput;

                /**
                 * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                 * @param message SigningOutput
                 * @param [options] Conversion options
                 * @returns Plain object
                 */
                public static toObject(message: TW.Zilliqa.Proto.SigningOutput, options?: $protobuf.IConversionOptions): { [k: string]: any };

                /**
                 * Converts this SigningOutput to JSON.
                 * @returns JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }
}
